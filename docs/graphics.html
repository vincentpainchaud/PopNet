<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>popnet.graphics documentation</title>
<meta name="description" content="Functions to draw figures representing results of numerical experiments â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding-left:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        "SVG": {
            availableFonts: ["TeX"], 
            scale: 90,
            blacker: 0
        },
        MMLorHTML: {prefer: "HTML"},
    });
    MathJax.Hub.Register.StartupHook("SVG Jax Ready",function () {
      var VARIANT = MathJax.OutputJax["SVG"].FONTDATA.VARIANT;
      VARIANT["normal"].fonts.unshift("MathJax_SansSerif");
      VARIANT["bold"].fonts.unshift("MathJax_SansSerif-bold");
      VARIANT["italic"].fonts.unshift("MathJax_SansSerif-italic");
      VARIANT["-tex-mathit"].fonts.unshift("MathJax_SansSerif-italic");
    });
    MathJax.Hub.Register.StartupHook("SVG Jax Ready",function () {
      var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;
      VARIANT["normal"].fonts.unshift("MathJax_SansSerif");
      VARIANT["bold"].fonts.unshift("MathJax_SansSerif-bold");
      VARIANT["italic"].fonts.unshift("MathJax_SansSerif-italic");
      VARIANT["-tex-mathit"].fonts.unshift("MathJax_SansSerif-italic");
    });
</script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_SVG"></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<style type="text/css">
    ul { 
        list-style-type: square; 
    }
    ul.hierarchy {
        list-style-type: none;
        padding-left: 2.5em;
        text-indent: -.8em;
    }
    ul.hierarchy > li:before {
        content: "\21B3 ";
    }
    ul.sidebar {
        border-left: 1px solid silver;
        margin-left: -.7em;
    }
    ol.references { 
        list-style-type: none; 
        margin-left: 0px; 
        padding-left: 2em; 
        position: relative; 
    }
    ol.references > li:before {
        content: "[" counter(enum, decimal) "]"; 
        left: 0.4em; 
        position: absolute; 
    }
    ol.references > li { 
        counter-increment: enum; 
    }
</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>popnet.graphics</code></h1>
</header>
<section id="section-intro">
<p>Functions to draw figures representing results of numerical experiments.</p>
<p>This module defines several classes to provide a consistent interface to
produce <a href="https://matplotlib.org/">Matplotlib</a> figures to represent results
obtained from numerical experiments performed with the rest of the package. The
classes it defines are briefly described in the
<a href="#classes-and-hierarchy">Classes And Hierarchy</a> section below.</p>
<p>The module also defines a function <code><a title="popnet.graphics.figure" href="#popnet.graphics.figure">figure()</a></code>, which allows to initialize a
Matplotlib figure with a format consistent with that used by the module's
classes, and a function <code><a title="popnet.graphics.draw" href="#popnet.graphics.draw">draw()</a></code> to draw such figures. Finally, it introduces
functions to load results from numerical experiments performed with the
<code><a title="popnet.executors" href="executors.html">popnet.executors</a></code> module, when these have been saved using
<code><a title="popnet.executors.Executor.save_output" href="executors.html#popnet.executors.Executor.save_output">Executor.save_output()</a></code>.</p>
<h2 id="classes-and-hierarchy">Classes And Hierarchy</h2>
<p>The important classes of the module are summarized below. The indentation
follows the hierarchy. </p>
<ul class="hierarchy">
<li><code><a title="popnet.graphics.Graphics" href="#popnet.graphics.Graphics">Graphics</a></code> : General base class to plot diagrams.<ul class="hierarchy sidebar">
<li><code><a title="popnet.graphics.PhasePlane" href="#popnet.graphics.PhasePlane">PhasePlane</a></code> : Draw phase planes of dynamical systems.</li>
<li><code><a title="popnet.graphics.Result" href="#popnet.graphics.Result">Result</a></code> : Represent results of numerical experiments.<ul class="hierarchy sidebar">
<li><code><a title="popnet.graphics.Solution" href="#popnet.graphics.Solution">Solution</a></code> : Outputs of numerical integrations where covariances are
not included.<ul class="hierarchy sidebar">
<li><code><a title="popnet.graphics.ExtendedSolution" href="#popnet.graphics.ExtendedSolution">ExtendedSolution</a></code> : Outputs of numerical integrations where
covariances are included.</li>
</ul>
</li>
<li><code><a title="popnet.graphics.Trajectory" href="#popnet.graphics.Trajectory">Trajectory</a></code> : Outputs of individual simulations.</li>
<li><code><a title="popnet.graphics.Statistics" href="#popnet.graphics.Statistics">Statistics</a></code> : Outputs of series of simulations.</li>
<li><code><a title="popnet.graphics.Spectrum" href="#popnet.graphics.Spectrum">Spectrum</a></code> : Fourier transform of another result.</li>
</ul>
</li>
</ul>
</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Functions to draw figures representing results of numerical experiments.

This module defines several classes to provide a consistent interface to
produce [Matplotlib](https://matplotlib.org/) figures to represent results
obtained from numerical experiments performed with the rest of the package. The
classes it defines are briefly described in the
[Classes And Hierarchy](#classes-and-hierarchy) section below.

The module also defines a function `figure`, which allows to initialize a
Matplotlib figure with a format consistent with that used by the module&#39;s
classes, and a function `draw` to draw such figures. Finally, it introduces
functions to load results from numerical experiments performed with the
`popnet.executors` module, when these have been saved using
`popnet.executors.Executor.save_output`.

Classes and hierarchy
---------------------
The important classes of the module are summarized below. The indentation
follows the hierarchy. 

 - `Graphics` : General base class to plot diagrams.
     - `PhasePlane` : Draw phase planes of dynamical systems.
     - `Result` : Represent results of numerical experiments.
         - `Solution` : Outputs of numerical integrations where covariances are
           not included.
             - `ExtendedSolution` : Outputs of numerical integrations where
               covariances are included.
         - `Trajectory` : Outputs of individual simulations.
         - `Statistics` : Outputs of series of simulations.
         - `Spectrum` : Fourier transform of another result.

&#34;&#34;&#34;

import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt
from scipy.optimize import root
from warnings import warn

from .exceptions import *
from . import _internals
from . import structures
from . import systems


class Graphics:
    &#34;&#34;&#34;General base class to plot various diagrams.

    This class provides basic tools to plot various diagrams related to
    numerical experiments performed by PopNet. It relies heavily on the
    [Matplotlib](https://matplotlib.org/) library. This class is intended to be
    used mainly through its subclasses.

    Parameters
    ----------
    config : popnet.structures.Configuration
        Configuration associated with the plot.
    name : str, optional
        Name to associate with the plot. Defaults to `None`, in which case it
        is replaced with `Graphics.default_name`.

    Attributes
    ----------
    config : popnet.structures.Configuration
        Configuration associated with the plot. See `Graphics.config`.
    name : str
        Name associated with the graphics. See `Graphics.name`.
    fig : matplotlib.figure.Figure
        A Matplotlib figure. See `Graphics.fig`.
    ax : matplotlib.axes.Axes
        Axes of `fig`. See `Graphics.ax`.

    &#34;&#34;&#34;

    default_name = &#39;Graphics&#39;
    &#34;&#34;&#34;Default name given to instances.&#34;&#34;&#34;

    def __init__(self, config, name=None):
        if not isinstance(config, structures.Configuration):
            raise TypeError(&#39;The configuration used with a \&#39;Graphics\&#39; &#39;
                            &#39;instance must be a \&#39;Configuration\&#39; instance.&#39;)
        self._config = config
        self.name = self._get_name(name)
        self.fig = None
        self.ax = None

    @property
    def config(self):
        &#34;&#34;&#34;Configuration associated with the figure.

        Configuration associated with the figure. It is set at initialization,
        and cannot be set or deleted afterwards.
        &#34;&#34;&#34;
        return self._config

    @property
    def name(self):
        &#34;&#34;&#34;Name of the figure. It has to be a string.&#34;&#34;&#34;
        return self._name

    @name.setter
    def name(self, new_name):
        if not isinstance(new_name, str):
            raise TypeError(f&#39;Graphics.name must be a string.&#39;)
        self._name = new_name

    @property
    def fig(self):
        &#34;&#34;&#34;A figure on which to draw various plots.

        A [`matplotlib.figure.Figure`](https://31c8.short.gy/mpl-figure-Figure)
        object that can be used to draw plots. This is the figure where
        `Graphics`&#39; methods can plot curves. It is set automatically when
        `Graphics.activate` is called. It cannot be deleted manually.
        &#34;&#34;&#34;
        return self._fig

    @fig.setter
    def fig(self, new_value):
        if new_value is None:
            pass
        elif not isinstance(new_value, mpl.figure.Figure):
            raise TypeError(&#39;Graphics.fig must be a &#39;
                            &#39;\&#39;matplotlib.figure.Figure\&#39; instance.&#39;)
        self._fig = new_value

    @property
    def ax(self):
        &#34;&#34;&#34;Axes of the current figure.

        A [`matplotlib.axes.Axes`](https://31c8.short.gy/mpl-axes-Axes) object
        correponding to the axes of `Graphics.fig`. It is set automatically
        when `Graphics.activate` is called. It cannot be deleted manually.
        &#34;&#34;&#34;
        return self._ax

    @ax.setter
    def ax(self, new_value):
        if new_value is None:
            pass
        elif not isinstance(new_value, mpl.axes.Axes):
            raise TypeError(f&#39;Graphics.ax must be a &#39;
                            &#39;\&#39;matplotlib.axes.Axes\&#39; instance.&#39;)
        self._ax = new_value

    def activate(self, figsize=(5,3.75), dpi=150, tight_layout=True, 
                 font_family=&#39;serif&#39;, usetex=False, preamble=None, **kwargs):
        &#34;&#34;&#34;Activate a figure.
        
        Create a Matplotlib figure to plot diagrams, and set `Graphics.fig` and
        `Graphics.ax` to refer to the
        [`matplotlib.figure.Figure`](https://31c8.short.gy/mpl-figure-Figure)
        and [`matplotlib.axes.Axes`](https://31c8.short.gy/mpl-axes-Axes)
        objects corresponding to this figure. The figure is initialized with
        the default formatting defined by `figure`: in fact, if `graphic` is a
        `Graphics` object, the calls
        
        &gt;&gt;&gt; graphic.activate(**kwargs)
        
        and
        
        &gt;&gt;&gt; graphic.fig, graphic.ax = figure(subplots=None, **kwargs)
        
        are equivalent.

        Parameters
        ----------
        figsize : tuple of float, optional
            Width and height of the figure in inches. Defaults to (5, 3.75).
        dpi : int
            Resolution of the figure in dots per inches. Defaults to 150.
        tight_layout : bool, optional
            Adjust automatically the padding between and aroung subplots using
            [`matplotlib.figure.Figure.tight_layout`](
            https://31c8.short.gy/mpl-tight-layout). Defaults to `True`.
        font_family : {&#39;serif&#39;, &#39;sans-serif&#39;}, optional
            Determines if a serif or sans serif font family is used. Defaults
            to `&#39;serif&#39;`.
        usetex : bool, optional
            Determines if LaTeX is used to draw the figure. Defaults to `False`.
        preamble : str, optional
            LaTeX preamble when `usetex` is `True`, in which case it case be
            used to load font packages. It has no effect when `usetex` is
            `False`. Defaults to `None`, in which case a default preamble is
            added.
        **kwargs
            Keyword arguments to be passed to
            [`matplotlib.pyplot.figure`](https://31c8.short.gy/plt-figure).
        &#34;&#34;&#34;
        if &#39;subplots&#39; in kwargs:
            raise TypeError(&#39;Graphics.activate() got an unexpected keyword &#39;
                            &#39;argument \&#39;subplots\&#39;&#39;)
        self.fig, self.ax = figure(
            figsize=figsize, dpi=dpi, tight_layout=tight_layout,
            font_family=font_family, usetex=usetex, preamble=preamble, **kwargs)

    def draw(self, name=None, show=True, savefig=False, folder=None, 
             format=None, **kwargs):
        &#34;&#34;&#34;Draw the plot.

        Draw a figure activated with `Graphics.activate`. If the figure is
        saved, it is named *ID - name*, where *ID* is the configuration&#39;s ID,
        *name* is `name`, and has the file format chosen with `format`.

        Parameters
        ----------
        name : str, optional
            Name to give to the figure if saved. Defaults to `None`, in which
            case `Graphics.name` is used.
        show : bool, optional
            Decides if the figure is shown or not. Defaults to `True`.
        savefig : bool, optional
            Decides if the figure is saved or not. Defaults to `False`.
        folder : str, optional
            A folder in which the figure can be saved. If it does not exist in
            the current directory and the figure is saved, it is created.
            Defaults to `None`, in which case the figure is saved in the
            current directory.
        format : str, optional
            The file format under which the figure is saved if `savefig` is
            `True`. It must be a format handled by Matplotlib, which includes
            &#39;png&#39;, &#39;jpg&#39;, &#39;pdf&#39; and &#39;svg&#39;. Defaults to `None`, in which case
            the file format is Matplotlib&#39;s `savefig.format` parameter, which
            defaults to &#39;png&#39;.
        **kwargs
            Keyword arguments passed to
            [`matplotlib.pyplot.savefig`](https://31c8.short.gy/plt-savefig)
            when `savefig` is `True`.

        Raises
        ------
        popnet.exceptions.PopNetError
            If the figure has not been activated yet.
        &#34;&#34;&#34;
        self._check_if_activated()
        if savefig:
            if name is None:
                name = self.name
            filename = _internals._format_filename(
                            folder, self.config.ID, name, extension=format)
            _internals._make_sure_folder_exists(folder)
            plt.savefig(filename, format=format, **kwargs)
        if show:
            plt.show()
        plt.close(self.fig)

    def legend(self, lw=2, fontsize=10, ncol=None, handletextpad=0.5, **kwargs):
        &#34;&#34;&#34;Generate a legend for the figure.

        Generate a legend for the figure with default options.

        Parameters
        ----------
        lw : float, optional
            Line width of the legend handles. Defaults to 2.
        fontsize : float, optional
            Fontsize of the legend labels. Defaults to 10.
        ncol : int, optional
            Number of columns of the legend. Defaults to `None`, in which case
            it is set to the number of populations of the configuration&#39;s
            network.
        handletextpad : float, optional
            Padding of the labels. Defaults to 0.5.
        **kwargs
            Keyword arguments to be passed to the
            [`legend`](https://31c8.short.gy/ax-legend) method of
            `Graphics.ax`, which actually adds the legend on the figure.

        Returns
        -------
        matplotlib.legend.Legend
            The figure&#39;s legend.
        &#34;&#34;&#34;
        if ncol is None:
            ncol = len(self.config.network.populations)
        leg = self.ax.legend(fontsize=fontsize, ncol=ncol, 
                             handletextpad=handletextpad, **kwargs)
        for lego in leg.legendHandles:
            lego.set_linewidth(lw)
        return leg

    def _check_if_activated(self):
        &#34;&#34;&#34;Check if the figure is already activated.&#34;&#34;&#34;
        if self.fig is None or self.ax is None:
            raise PopNetError(&#39;The figure must be activated before to be &#39;
                              &#39;drawn. Call Graphics.activate() first.&#39;)

    @classmethod
    def _get_name(cls, name):
        &#34;&#34;&#34;Return `name`, or the default name if `name` is `None`.&#34;&#34;&#34;
        if name is None:
            return cls.default_name
        return name


class PhasePlane(Graphics):
    &#34;&#34;&#34;Draw phase planes for dynamical systems.

    This class is dedicated to plot phase planes of dynamical systems
    implemented in `popnet.systems`. It should be emphasized that this class is
    intended to draw phase *planes*, not one- or three-dimensional phase spaces.

    Parameters
    ----------
    system : popnet.systems.DynamicalSystem
        Dynamical system for which to draw a phase plane.
    axes : tuple of int
        Components of the dynamical system that will be independant variables
        on the phase plane.
    fixed_axes : array_like
        Values of the remaining components other than the independent variables
        corresponding to `axes`.
    name : str, optional
        A name associated with the phase plane. Defaults to `None`, in which
        case it is replaced with `PhasePlane.default_name`.

    Attributes
    ----------
    config : popnet.structures.Configuration
        The configuration associated with the phase plane. See
        `PhasePlane.config`.
    name : str
        Name associated with the phase plane. See `PhasePlane.name`.
    fig : matplotlib.figure.Figure
        A Matplotlib figure. See `PhasePlane.fig`.
    ax : matplotlib.axes.Axes
        The axes of `fig`. See `PhasePlane.ax`.
    system : popnet.systems.DynamicalSystem
        Dynamical system for which to draw a phase plane. See
        `PhasePlane.system`.
    axes : tuple of int
        Components chosen as independant variables for the phase plane. See
        `PhasePlane.axes`.
    fixed_axes : array_like
        Values of the remaining state components other than independent ones.
        See `PhasePlane.fixed_axes`.

    Raises
    ------
    TypeError
        If `system` is not a `popnet.systems.DynamicalSystem` instance.

    Notes
    -----
    The cases where the dynamical system studied is the
    `popnet.systems.MeanFieldSystem` or the `popnet.systems.WilsonCowanSystem`
    are internally handled by private subclasses `_PhasePlaneMeanField` and
    `_PhasePlaneWilsonCowan`, which are automatically instantiated by the class
    constructor of `PhasePlane` when appropriate. The subclasses mentioned
    above are responsible to define the methods used to compute nullclines for
    the corresponding dynamical systems.

    This is considered to be an implementation detail, and should not be useful
    from a user perspective.

    &#34;&#34;&#34;

    default_name = &#39;Phase plane&#39;
    &#34;&#34;&#34;Default name given to instances.&#34;&#34;&#34;

    def __init__(self, system, axes, fixed_axes, name=None):
        if not isinstance(system, systems.DynamicalSystem):
            raise TypeError(&#39;The system associated with a \&#39;PhasePlane\&#39; &#39;
                            &#39;instance must be a \&#39;DynamicalSystem\&#39; instance.&#39;)
        self._system = system
        super().__init__(system.config, name=name)
        self.axes = axes
        if (n := self.system.dim - 2) == 0:
            self.fixed_axes = None
        else:
            self.fixed_axes = fixed_axes

    def __new__(cls, system, axes, fixed_axes, name=None):
        if isinstance(system, systems.WilsonCowanSystem):
            return super().__new__(_PhasePlaneWilsonCowan)
        if isinstance(system, (systems.MeanFieldSystem, systems.MixedSystem)):
            return super().__new__(_PhasePlaneMeanField)
        return super().__new__(cls)

    @property
    def system(self):
        &#34;&#34;&#34;Dynamical system for which to draw a phase plane.

        Dynamical system for which a phase plane is to be drawn. It must be
        a `popnet.systems.DynamicalSystem` instance. It is set at
        initialization, and afterwards it cannot be manually set nor deleted.
        &#34;&#34;&#34;
        return self._system

    @property
    def axes(self):
        &#34;&#34;&#34;Components chosen as independant variables for the phase plane.
        
        It must be a tuple of two integers corresponding to valid axes of the
        dynamical system. It cannot be deleted.
        &#34;&#34;&#34;
        return self._axes

    @axes.setter
    def axes(self, new_value):
        self._check_if_tuple_of_two_int(new_value)
        if max(new_value) &gt;= self.system.dim:
            if (L := self.system.dim) == 1:
                s = &#39;&#39;
            else:
                s = &#39;s&#39;
            raise ValueError(f&#39;{new_value} contains an invalid index: the &#39;
                             &#39;dynamical system has only &#39;
                             f&#39;{self.system.dim} component{s}.&#39;)
        self._axes = new_value

    @property
    def fixed_axes(self):
        &#34;&#34;&#34;Fixed values for remaining state components.

        Values given to state components other than those chosen as
        independent. It is a one-dimensional array, or `None` if the whole
        dynamical system is two-dimensional. 

        It can be set as a single float value, in which case this value is
        given to all fixed axes. It cannot be deleted.
        &#34;&#34;&#34;
        return self._fixed_axes

    @fixed_axes.setter
    def fixed_axes(self, new_value):
        if new_value is None:
            if (n := self.system.dim - 2) &gt; 0:
                warn(&#39;The fixed axes should be given values, since the system &#39;
                     &#39;has more dimensions than two. A zero array has been set.&#39;,
                     category=PopNetWarning, stacklevel=2)
                self._fixed_axes = np.zeros(n)
            else:
                self._fixed_axes = None
            return
        try:
            new_value = np.array(new_value, float)
        except Exception:
            raise TypeError(&#39;The fixed components must be given as an array &#39;
                            &#39;of floats.&#39;)
        if (n := self.system.dim - 2) &gt; 0:
            if new_value.shape == ():
                new_value = new_value * np.ones(n)
            elif new_value.shape != (n,):
                raise ValueError(&#39;The given fixed components array has shape &#39;
                                 f&#39;{new_value.shape} but it must have shape &#39;
                                 f&#39;{(n,)}.&#39;)
            self._fixed_axes = new_value
        else:
            warn(&#39;No state components should be fixed as the system does not &#39;
                 &#39;have more than two state components in total. The \&#39;fixed_&#39;
                 &#39;state\&#39; attribute has been set to \&#39;None\&#39;.&#39;,
                 category=PopNetWarning, stacklevel=2)
            self._fixed_axes = None

    def legend(self, lw=2, fontsize=10, ncol=1, handletextpad=0.5, 
               framealpha=1, **kwargs):
        &#34;&#34;&#34;Generate a legend for the figure.

        Generate a legend for the figure with default options. Same as the base
        class method `Graphics.legend`, but changes the defaults for `ncol` and
        `framealpha` to 1.
        &#34;&#34;&#34;
        return super().legend(lw=lw, fontsize=fontsize, ncol=ncol, 
                              handletextpad=handletextpad,
                              framealpha=framealpha, **kwargs)

    def plot_nullclines(self, which=&#39;both&#39;, num=1000, xcolor=None, ycolor=None,
                        xlim=(0,1), ylim=(0,1), **kwargs):
        &#34;&#34;&#34;Plot nullclines on the phase plane.

        Plot nullclines for independent variables on the phase plane. This
        method is mostly intended to be used with the Wilson--Cowan system,
        with its extension with refractory state, or with the &#39;mixed&#39; system
        that makes a transition between the first two. Indeed, with these
        systems nullclines can be computed easily.

        For dynamical systems that include covariances, nullclines are computed
        numerically using [`root`](https://31c8.short.gy/scipy-optimize-root)
        from SciPy&#39;s `optimize` module. However, this feature is still
        experimental, and could lead to unaccurate or unexpected results. A
        warning is issued when this method is used in such a case.

        Parameters
        ----------
        which : {&#39;x&#39;, &#39;y&#39;, &#39;both&#39;}, optional
            Which nullcline to plot. Defaults to `&#39;both&#39;`.
        num : int, optional
            Number of points on nullclines. Defaults to 1000.
        xcolor, ycolor : string or tuple, optional
            Colors given to nullclines. `zcolor` is the color for the nullcline
            where the component drawn on axis *z* does not vary. They must be
            valid Matplotlib colors. Both default to `None`, in which case
            default colors are used.
        xlim, ylim : tuple, optional
            Limits of the horizontal and vertical axis, respectively. Both
            default to (0,1).
        **kwargs
            Keyword arguments to be passed to the
            [`plot`](https://31c8.short.gy/ax-plot) method of `PhasePlane.ax`,
            which actually plots the nullclines.

        Warns
        -----
        popnet.exceptions.PopNetWarning
            If nullclines are computed numerically with the experimental
            algorithm.
        &#34;&#34;&#34;
        if which not in (valid_values := (&#39;x&#39;, &#39;y&#39;, &#39;both&#39;)):
            warn(f&#39;Unexpected value {which} for \&#39;which\&#39;. Valid values are &#39;
                 f&#39;{valid_values}. No nullclines will be plotted.&#39;,
                 stacklevel=2, category=PopNetWarning)
        plot = {&#39;x&#39;: True if which in (&#39;x&#39;, &#39;both&#39;) else False,
                &#39;y&#39;: True if which in (&#39;y&#39;, &#39;both&#39;) else False}
        x = np.linspace(xlim[0], xlim[1], num)
        y = np.linspace(ylim[0], ylim[1], num)
        if plot[&#39;x&#39;]:
            x1, y1 = self._nullcline(x, y, self.axes[0], self.axes[1])
            self.ax.plot(x1, y1, color=xcolor,
                         label=self._nullcline_label(self.axes[0]))
        if plot[&#39;y&#39;]:
            y2, x2 = self._nullcline(y, x, self.axes[1], self.axes[0])
            self.ax.plot(x2, y2, color=ycolor,
                         label=self._nullcline_label(self.axes[1]))

    def plot_solution(self, **kwargs):
        &#34;&#34;&#34;Plot a solution of the dynamical system on the phase plane.
        
        Run a numerical integration, and plot the resulting solution on the
        phase plane.

        Parameters
        ----------
        **kwargs
            Keyword arguments passed to the
            [`plot`](https://31c8.short.gy/ax-plot) method of `PhasePlane.ax`,
            which actually plots the solution.
        &#34;&#34;&#34;
        from .executors import get_integrator
        integrator = get_integrator(self.system)
        solution = self._run_experiment(integrator, &#39;ode&#39;)
        label = kwargs.pop(&#39;label&#39;, &#39;Solution&#39;)
        self.ax.plot(solution[0], solution[1], label=label, **kwargs)

    def plot_trajectory(self, act=&#39;step&#39;, **kwargs):
        &#34;&#34;&#34;Plot a trajectory of a stochastic process on the phase plane.

        Run a simulation of a stochastic process, and plot the resulting
        trajectory on the phase plane. The configuration used with the phase
        plane must have a defined microscopic structure.

        Parameters
        ----------
        act : {&#39;step&#39;, &#39;sigmoid&#39;}, optional
            Shape of neurons&#39; activation rates for the simulation. If `&#39;step&#39;`,
            a neuron&#39;s activation rate is a step function going from zero to
            `popnet.structures.MicroNetwork.alpha` at its threshold
            `popnet.structures.MicroNetwork.theta`. If `&#39;sigmoid&#39;`, a neuron&#39;s
            activation rate is the logistic function
            `popnet.structures.Population.F` of the population to which it
            belongs. Defaults to `&#39;step&#39;`.
        **kwargs
            Keyword arguments passed to the
            [`plot`](https://31c8.short.gy/ax-plot) method of `PhasePlane.ax`,
            which actually plots the trajectory.
        &#34;&#34;&#34;
        from .executors import get_simulator
        simulator = get_simulator(self.config, act=act, mode=&#39;individual&#39;)
        trajectory = self._run_experiment(simulator)
        label = kwargs.pop(&#39;label&#39;, &#39;Trajectory&#39;)
        self.ax.plot(trajectory[0], trajectory[1], label=label, **kwargs)

    def quiver(self, shape, xlim=(0,1), ylim=(0,1), **kwargs):
        &#34;&#34;&#34;Draw the vector field on the initialized figure.

        Draw the vector field on the figure `PhasePlane.fig`. The field is
        plotted as a 2D field of arrows with
        [`matplotlib.axes.Axes.quiver`](https://31c8.short.gy/ax-quiver)
        on the axes `PhasePlane.ax`.

        Parameters
        ----------
        shape : tuple of int
            Shape of the grid on which to plot the vector field.
        xlim, ylim : tuple, optional
            Limits of the horizontal and vertical axis, respectively. Both
            default to (0,1).
        **kwargs
            Keyword arguments passed to
            [`matplotlib.axes.Axes.quiver`](https://31c8.short.gy/ax-quiver)
        &#34;&#34;&#34;
        self._check_if_activated()
        X, Y, dX, dY = self._get_arrows(xlim, ylim, shape)
        self.ax.quiver(X, Y, dX, dY, **kwargs)

    def setup(self, xlim=(0,1), ylim=(0,1), fontsize=10, aspect=&#39;auto&#39;):
        &#34;&#34;&#34;Setup the figure.

        Setup the figure `PhasePlane.fig`. Allows to set limits to both axes,
        to choose a font size for labels, and to set the aspect ratio of the
        axes.

        Parameters
        ----------
        xlim, ylim : tuple, optional
            Limits of the horizontal and vertical axis, respectively. Both
            default to (0,1).
        fontsize : float, optional
            Fontsize of the axes&#39; labels. Defaults to 10.
        aspect : {&#39;auto&#39;, &#39;equal&#39;} or float, optional
            Aspect ratio of the axis scaling. If `&#39;auto&#39;`, the plot fills
            the available area, if `&#39;equal&#39;`, the scaling is the same for
            both axes, and if a float, a square would be stretched such that
            its height is `aspect` times its width. Defaults to `&#39;auto&#39;`.
        &#34;&#34;&#34;
        self.ax.set_xlim(xlim)
        self.ax.set_ylim(ylim)
        self.ax.set_xlabel(self._label(self.axes[0]), fontsize=fontsize)
        self.ax.set_ylabel(self._label(self.axes[1]), fontsize=fontsize, 
                           rotation=0)
        self.ax.axes.set_aspect(aspect)

    def streamplot(self, shape, xlim=(0,1), ylim=(0,1), colorbar=False, 
                   cmap=&#39;bone&#39;, color=None, density=1.5, **kwargs):
        &#34;&#34;&#34;Draw the vector field on the initialized figure.

        Draw the vector field on the figure `PhasePlane.fig`. The field is
        plotted as streamlines with
        [`matplotlib.axes.Axes.streamplot`](https://31c8.short.gy/ax-streamplot)
        on the axes `PhasePlane.ax`.

        Parameters
        ----------
        shape : tuple of int
            Shape of the grid on which to plot the vector field.
        xlim, ylim : tuple, optional
            Limits of the horizontal and vertical axis, respectively. Both
            default to (0,1).
        colorbar : bool, optional
            If `True`, a colorbar is added on the phase plane, where the color
            represents the euclidean norm of the derivative. Defaults to
            `False`.
        cmap : str, optional
            Colormap for the vector field when `colorbar` is `True`. See
            [this page](https://31c8.short.gy/mpl-colormap)
            of Matplotlib&#39;s documentation for a list of accepted values.
            Defaults to `&#39;bone&#39;`.
        color : str or tuple, optional
            Color of the vector field when `colorbar` is `False`. It must be a
            valid Matplotlib color. Defaults to `None`, in which case a default
            color is used.
        density : float, optional
            Density of the stream lines in the plot. Defaults to 1.5.
        **kwargs
            Keyword arguments passed to [`matplotlib.axes.Axes.streamplot`](
            https://31c8.short.gy/ax-streamplot)
        &#34;&#34;&#34;
        self._check_if_activated()
        X, Y, dX, dY = self._get_arrows(xlim, ylim, shape)
        if colorbar:
            color = np.sqrt(dX**2 + dY**2)
        strm = self.ax.streamplot(X, Y, dX, dY, color=color, cmap=cmap, 
                                  density=density, **kwargs)
        if colorbar:
            self.fig.colorbar(strm.lines, ax=self.ax)

    @staticmethod
    def _check_if_tuple_of_two_int(test_value):
        &#34;&#34;&#34;Check if `test_value` is a tuple of two int.&#34;&#34;&#34;
        msg = f&#39;{test_value} is not a tuple of non negative integers.&#39;
        if not isinstance(test_value, tuple):
            raise TypeError(msg)
        if len(test_value) != 2:
            raise ValueError(msg)
        if not all(isinstance(val, int) for val in test_value):
            raise ValueError(msg)
        if not all(val &gt;= 0 for val in test_value):
            raise ValueError(msg)

    def _get_arrows(self, xlim, ylim, shape):
        &#34;&#34;&#34;Get the arrows to plot the vector field.&#34;&#34;&#34;
        x = np.linspace(xlim[0], xlim[1], shape[0])
        y = np.linspace(ylim[0], ylim[1], shape[1])
        X, Y = np.meshgrid(x, y)
        dX, dY = self._vector_field(X, Y, shape)
        return X, Y, dX, dY

    def _label(self, j, derivative=False):
        &#34;&#34;&#34;Get the label associated with the *j*th state component.&#34;&#34;&#34;
        p = len(self.config.network.populations)
        if p == 1:
            return f&#39;${self._label_one(j, derivative)}$&#39;
        return f&#39;${self._label_many(j, p, derivative)}$&#39;

    def _label_many(self, j, p, derivative):
        &#34;&#34;&#34;Get the *j*th component&#39;s label for *p* populations.&#34;&#34;&#34;
        dot = &#39;\\dot&#39; if derivative else &#39;&#39;
        if 0 &lt;= j &lt; 2*p:
            m = j % p
            X = &#39;A&#39; if m == j else &#39;R&#39;
            J = self.config.network.populations[m].ID
            return f&#39;{dot}{{\\mathcal{{{X}}}}}_{{{J}}}&#39;
        triangle_indices = [(m,n) for m in range(p) for n in range(m,p)]
        if 2*p &lt;= j &lt; round(2*p + p*(p+1)/2):
            m, n = triangle_indices[j - 2*p]
            X = Y = &#39;A&#39;
        elif round(2*p + p*(p+1)/2) &lt;= j &lt; 2*p + p*(p+1):
            m, n = triangle_indices[j - round(2*p + p*(p+1)/2)]
            X = Y = &#39;R&#39;
        elif 2*p + p*(p+1) &lt;= j &lt; p*(2*p+3):
            m, n = np.ndindex((p,p))[j - 2*p - p*(p+1)]
            X = &#39;A&#39;
            Y = &#39;R&#39;
        J = self.config.network.populations[m].ID
        K = self.config.network.populations[n].ID
        return f&#39;{dot}{{\\mathrm{{C}}}}_{{{X}{Y}}}^{{{J}{K}}}&#39;

    def _label_one(self, j, derivative):
        &#34;&#34;&#34;Get the *j*th component&#39;s label for one population.&#34;&#34;&#34;
        dot = &#39;\\dot&#39; if derivative else &#39;&#39;
        if j == 0:
            return f&#39;{dot}{{\\mathcal{{A}}}}&#39;
        elif j == 1:
            return f&#39;{dot}{{\\mathcal{{R}}}}&#39;
        elif j == 2:
            return f&#39;{dot}{{\\mathrm{{C}}}}_{{AA}}&#39;
        elif j == 3:
            return f&#39;{dot}{{\\mathrm{{C}}}}_{{RR}}&#39;
        elif j == 4:
            return f&#39;{dot}{{\\mathrm{{C}}}}_{{AR}}&#39;

    def _nullcline(self, Z, W, j, k):
        &#34;&#34;&#34;Get *j*-nullcline with `Z` and `W` as axes `j` and `k`.&#34;&#34;&#34;
        warn(&#39;For this dynamical system, the algorithm that determines the &#39;
             &#39;nullclines is still experimental. The results might not be &#39;
             &#39;accurate.&#39;, category=PopNetWarning, stacklevel=3)
        others = np.arange(self.system.dim)
        others = np.setdiff1d(others, np.array(self.axes))
        state_0 = np.zeros(self.system.dim)
        state_0[others] = self.fixed_axes
        null = {j: [], k: []}
        successes = {j: 0, k: 0}
        U = {j: Z, k: W}
        for m in [j,k]:
            n = k if m == j else j
            for u in U[m]:
                state = state_0.copy()
                state[m] = u
                def f(v):
                    state[n] = v
                    return self.system.vector_field(state)[j]
                opt = root(f,0)
                successes[m] += int(opt.success)
                null[m].append(opt.x)
        if successes[j] / len(Z) &gt; successes[k] / len(W):
            return Z, np.array(null[j])
        return np.array(null[k]), W

    def _nullcline_label(self, j):
        &#34;&#34;&#34;Label for the nullcline of the axis *j*.&#34;&#34;&#34;
        p = len(self.config.network.populations)
        if p == 1:
            return f&#39;${self._label_one(j, True)} = 0$&#39;
        return f&#39;${self._label_many(j, p, True)} = 0$&#39;

    def _run_experiment(self, executor, *args, **kwargs):
        &#34;&#34;&#34;Run an experiment and get the output on `self.axes` versus time.&#34;&#34;&#34;
        executor.run(*args, **kwargs)
        return executor.states[:,self.axes].transpose()

    def _vector_field(self, X, Y, shape):
        &#34;&#34;&#34;Vector field to plot.

        Vector field to plot to draw the phase plane, as a function of the
        independant variables arranged as a grid.
        &#34;&#34;&#34;
        state_list = []
        indep_to_app = X
        k = 0
        for j in range(n := self.system.dim):
            if j in self.axes:
                state_list.append(indep_to_app)
                indep_to_app = Y
                k += 1
            else:
                state_list.append(self.fixed_axes[j-k] * np.ones(shape))
        states = np.array(state_list, float)
        try:
            field = self.system.vector_field(states)
        except Exception:
            field = np.zeros((n,) + shape)
            for j, k in np.ndindex(shape):
                field[:,j,k] = self.system.vector_field(states[:,j,k])
        return field[self.axes[0]], field[self.axes[1]]


class _PhasePlaneWilsonCowan(PhasePlane):
    &#34;&#34;&#34;Specializes `PhasePlane` for the Wilson--Cowan system.

    Specializes `PhasePlane` for the classical Wilson--Cowan dynamical system.
    All changes to the base class are implementation details.

    &#34;&#34;&#34;

    def _nullcline(self, Z, W, j, k):
        &#34;&#34;&#34;Get *j*-nullcline with `Z` and `W` as axes `j` and `k`.&#34;&#34;&#34;
        popJ = self.config.network.populations[j]
        c = self.config.network.c
        B_diff = np.zeros(Z.shape)
        for L in range(len(self.config.network.populations)):
            if L == k:
                continue
            A = Z if L == j else self.fixed_axes[L - int(L &gt; j) - int(L &gt; k)]
            B_diff += c[j,L] * A
        arg = popJ.beta / popJ.alpha * Z / (1 - (1 + popJ.beta/popJ.gamma) * Z)
        Finv_value = popJ.Finv(arg)
        return Z, 1 / c[j,k] * (Finv_value - self.config.Q[j] - B_diff)


class _PhasePlaneMeanField(PhasePlane):
    &#34;&#34;&#34;Specializes `PhasePlane` for the simple system.

    Specializes `PhasePlane` for the Wilson--Cowan dynamical system with
    refractory state. All changes to the base class are implementation details.

    &#34;&#34;&#34;

    def _nullcline(self, Z, W, j, k):
        &#34;&#34;&#34;Get *j*-nullcline with `Z` and `W` as axes `j` and `k`.&#34;&#34;&#34;
        p = len(self.config.network.populations)
        if j &lt; p:
            if k &lt; p or k == j + p:
                return self._nullcline_A_analytical(Z, W, j, k, p)
            return self._nullcline_A_numerical(Z, W, j, k, p)
        return self._nullcline_R(Z, W, j, k, p)

    def _nullcline_R(self, Z, W, j, k, p):
        &#34;&#34;&#34;Get the nullcline for an R component.&#34;&#34;&#34;
        popJ = self.config.network.populations[j % p]
        A = W if k == j-p else self.fixed_axes[j-p - int(j&gt;k)] * np.ones(W.shape)
        return popJ.beta / popJ.gamma * A, W

    def _nullcline_A_analytical(self, Z, W, j, k, p):
        &#34;&#34;&#34;Get analytically the nullcline for an A component.&#34;&#34;&#34;
        popJ = self.config.network.populations[j]
        c = self.config.network.c
        A = [Z if n == j else None if n == k else 
             self.fixed_axes[n - int(n&gt;j) - int(n&gt;k)] for n in range(p)]
        B = np.ones(Z.shape) * self.config.Q[j]
        for L in range(p):
            if L == k:
                continue
            B += c[j,L] * A[L]
        if k &lt; p:
            SJ = 1 - self.fixed_axes[p + j - 2] - A[j]
            with np.errstate(divide=&#39;ignore&#39;):
                Finv_value = popJ.Finv(popJ.beta * A[j] / (popJ.alpha * SJ))
            return Z, 1 / c[j,k] * (Finv_value - B)
        if k == j + p:
            return Z, 1 - (1 + popJ.beta / (popJ.alpha * popJ.F(B))) * Z

    def _nullcline_A_numerical(self, Z, W, j, k, p):
        &#34;&#34;&#34;Get numerically the nullcline for an A component.&#34;&#34;&#34;
        popJ = self.config.network.populations[j]
        R = self.fixed_axes[p + j - 1 - int(p+j&gt;k)]
        def f(a):
            A = [a if n == j else
                 self.fixed_axes[n - int(n&gt;j)] for n in range(p)]
            B = sum(self.config.network.c[j,L] * A[L] for L in range(p))
            return - popJ.beta * a + popJ.alpha * popJ.F(B) * (1 - a - R)
        a = root(f,0).x
        return a * np.ones(W.shape), W


class Result(Graphics):
    &#34;&#34;&#34;Results generated using PopNet executors.

    The purpose of `Result` is to handle easily the outputs of numerical
    experiments performed by PopNet. The class `Result` has several methods,
    listed in the [Methods](#result-methods) section below, to create and setup
    a [Matplotlib](https://matplotlib.org/) figure with predefined formatting,
    allowing to easily produce many figures in a consistent format. 

    Although some features would be available with the `Result` class alone,
    it is not inteded to be used by itself, but rather through its subclasses
    `Solution`, `ExtendedSolution`, `Trajectory`, `Statistics` and `Spectrum`.
    Each one of these subclasses implements other features specific to a given
    result case.

    Parameters
    ----------
    config : popnet.structures.Configuration
        Configuration used to obtain the result.
    states : array_like
        State of the network with respect to time.
    times : array_like
        Time.
    name : str, optional
        A name associated with the result. Defaults to `None`, in which case it
        is replaced with `Result.default_name`.

    Attributes
    ----------
    config : popnet.structures.Configuration
        Configuration used to obtain the result. See `Result.config`.
    name : str
        Name associated with the result. See `Result.name`.
    fig : matplotlib.figure.Figure
        A Matplotlib figure. See `Result.fig`.
    ax : matplotlib.axes.Axes
        Axes of `fig`. See `Result.ax`.
    times : array_like
        Time.
    colors : dict
        Colors for each state variable associated with the result. See
        `Result.colors`.
    plot : dict
        Plotting methods for each state variable associated with the result.
        See `Result.plot`.
    A, R, S : array_like
        Vectors of state variables with respect to time.
    CAA, CRR, CSS, CAR, CAS, CRS : array_like
        Covariance matrices between state variables with respect to time, or
        `None` if no such covariances are defined for a `Result` subclass.

    Methods {#result-methods}
    -------
     - `Result.activate` :
        Activate a Matplotlib figure.
     - `Result.legend` :
        Make a legend for the figure.
     - `Result.setup` :
        Setup the axes of the figure.
     - `Result.draw` :
        Draw the figure and show it or save it.

    Raises
    ------
    TypeError
        If `config` is not a `popnet.structures.Configuration` instance.

    Notes
    -----
    Some additional remarks should be made regarding the implementation, in
    case `Result` would have to be subclassed. Everything discussed here is
    considered to be implementation details, and should not be useful from a
    user perspective.

    The class `Result` itself is in fact intended to handle directly only the
    case where the network used in the configuration has more than one
    population. The one population case is internally handled by a private
    subclass `_ResultOne`, which is responsible to modify the state components
    attributes and the methods of the `plot` dictionary, to change them from
    one-element lists to the elements themselves. The same pattern is followed
    in `Result` subclasses: each one has a private subclass with the same name
    but with a suffix &#39;One&#39;.

    When creating a new `Result` instance, the constructor internally checks
    the number of populations of the network, and if this number is one, then
    the constructor looks in the `graphics` module for a private class of the
    same name suffixed with &#39;One&#39;, and rather instantiates this class if it
    exists.

    &#34;&#34;&#34;

    default_name = &#39;Result&#39;
    &#34;&#34;&#34;Default name given to instances.&#34;&#34;&#34;
    x_units = &#39;Time&#39;
    &#34;&#34;&#34;Units of the horizontal axis. The default is `&#39;Time&#39;`.&#34;&#34;&#34;
    _lim_valid_values = {&#39;x&#39;: (&#39;time&#39;, &#39;config&#39;, &#39;unbounded&#39;), 
                         &#39;y&#39;: (&#39;fractions&#39;, &#39;covariances&#39;, &#39;unbounded&#39;)}

    def __init__(self, config, states, times, name=None):
        super().__init__(config, name=name)
        self._init_abscissa(times)
        self._init_states_dict(states)
        self._init_colors()
        self._init_plot_methods()

    def __new__(cls, config, states, times, name=None):
        if not isinstance(config, structures.Configuration):
            raise TypeError(&#39;The configuration used with a \&#39;Result\&#39; &#39;
                            &#39;instance must be a \&#39;Configuration\&#39; instance.&#39;)
        if len(config.network.populations) == 1:
            prefix = &#39;&#39; if cls.__name__.startswith(&#39;_&#39;) else &#39;_&#39;
            suffix = &#39;&#39; if cls.__name__.endswith(&#39;One&#39;) else &#39;One&#39;
            try:
                one_pop_class = globals()[f&#39;{prefix}{cls.__name__}{suffix}&#39;]
            except KeyError:
                pass
            else:
                return super().__new__(one_pop_class)
        return super().__new__(cls)

    @classmethod
    def load(cls, ID, name=None, config=None, times=None, folder=None):
        &#34;&#34;&#34;Load the result associated with the ID.

        Load the result obtained when using the configuration of ID `ID`. The
        array representing the state of the network with respect to time is
        expected to be in a file named *ID - name.txt*, where *ID* and *name*
        are indeed `ID` and `name`. 

        Parameters
        ----------
        ID : str
            ID of the configuration used to obtain this result. 
        name : str, optional
            Name associated with the result. Defaults to `None`, in which case
            it is replaced with the name of the class.
        config : popnet.structures.Configuration, optional
            Configuration to associate with the result. If given, it must have
            the ID `ID`. Defaults to `None`, in which case it is loaded with
            `popnet.structures.load_config`, using the same ID.
        times : array_like, optional
            Times array to associate with the result. Defaults to `None`, in
            which case it is computed from the configuration.
        folder : str, optional
            Folder in which the file is located, which should be placed in the
            current directory. Defaults to `None`, in which case the file is
            assumed to be located in the current directory.

        Returns
        -------
        Result
            The loaded result. 

        Raises
        ------
        TypeError
            If `config` is neither `None` nor a
            `popnet.structures.Configuration` instance.
        popnet.exceptions.PopNetError
            If `config` has a different ID than `ID`. 
        FileNotFoundError
            If no file is found with the expected name.
        &#34;&#34;&#34;
        config = cls._check_config(config, ID)
        if times is None:
            times = np.linspace(config.initial_time, config.final_time,
                                1 + config.iterations)
        name = cls._get_name(name)
        filename = _internals._format_filename(folder, ID, name)
        try:
            states = np.loadtxt(filename, dtype=float, ndmin=2)
        except FileNotFoundError as error:
            raise FileNotFoundError(
                    f&#39;No result found for configuration {ID}.&#39;) from error
        return cls(config, states, times, name)

    @property
    def times(self):
        &#34;&#34;&#34;Time.

        An array representing time. It is the independant variable with respect
        to which state components are given. It cannot be set nor deleted.
        &#34;&#34;&#34;
        return self._times

    @property
    def colors(self):
        &#34;&#34;&#34;Colors associated with the result&#39;s components.

        Colors associated with the result&#39;s components, to be used in figures.
        It is a dictionary whose keys are strings representing possible
        components, and whose values are lists (or lists of lists) of valid
        Matplotlib colors associated with each population (or pair of
        populations). For example, `result.colors[&#39;A&#39;][J]` is the color
        associated with the activity of the *J*th population of the network for
        the result `result`. By default, in the case of a single population,
        a new color can be assigned as is, and it is automatically placed in a
        list (containing only the given color). It cannot be deleted.
        &#34;&#34;&#34;
        return self._colors

    @colors.setter
    def colors(self, new_colors):
        if not isinstance(new_colors, dict):
            raise TypeError(&#39;The colors passed to a \&#39;Result\&#39; instance must &#39;
                            &#39;be stored in a dictionary.&#39;)
        self._colors = new_colors

    @property
    def plot(self):
        &#34;&#34;&#34;Dictionary of methods to plot state variables.

        If *X* denotes a state variable (that is, either *A*, *R* or *S*), then
        `plot[&#39;X&#39;]` is a list whose *J*th element is a method that plots
        \\(X^J\\) (or its expectation, depending on the
        result) with respect to time. Similarly, if covariances are defined for
        this result, then `plot[&#39;CXY&#39;][J][K]` is a method which plots the
        covariances between \\(X^J\\) and \\(Y^K\\) with respect to time. A
        similar pattern works for third central moments as well if applicable,
        with keys of the form `&#39;XYZ&#39;`.

        In the case where the network has only one population, the lists are
        all replaced with the single element they would contain. For example,
        `plot[&#39;A&#39;]` is directly a method to plot the network&#39;s activity, that
        is, the activity of the single population of the network. In the same
        way, `plot[&#39;CRR&#39;]` is a method to plot the variance of the refractory
        fraction of the network.

        When called, these methods plot the corresponding state components with
        respect to time on the axes `Result.ax` of the figure `Result.fig`. They
        all accept keyword arguments that can be passed to the
        [`plot`](https://31c8.short.gy/ax-plot) method of `Result.ax`. This
        attribute cannot be set nor deleted.
        &#34;&#34;&#34;
        return self._plot

    @property
    def A(self):
        &#34;&#34;&#34;Active fractions of populations.

        List of active fractions of populations (or their expectations,
        depending on the result) as arrays indexed with respect to time. If
        the network has only one population, it is not a list, but directly the
        array giving the active fraction of the network with respect to time.

        It cannot be set nor deleted.
        &#34;&#34;&#34;
        return self._states_dict[&#39;A&#39;]

    @property
    def R(self):
        &#34;&#34;&#34;Refractory fractions of populations.

        List of refractory fractions of populations (or their expectations,
        depending on the result) as arrays indexed with respect to time. If
        the network has only one population, it is not a list, but directly the
        array giving the refractory fraction of the network with respect to
        time.

        It cannot be set nor deleted.
        &#34;&#34;&#34;
        return self._states_dict[&#39;R&#39;]

    @property
    def S(self):
        &#34;&#34;&#34;Sensitive fractions of population.

        List of sensitive fractions of populations (or their expectations,
        depending on the result) as arrays indexed with respect to time. If
        the network has only one population, it is not a list, but directly the
        array giving the sensitive fraction of the network with respect to time.

        It cannot be set nor deleted.
        &#34;&#34;&#34;
        return self._states_dict[&#39;S&#39;]

    @property
    def CAA(self):
        &#34;&#34;&#34;Covariances between active fractions of populations.

        Matrix (as a list of lists) of covariances between active fractions of
        populations with respect to time, or `None` if no such matrix is
        defined. If the network has only one population, it is not a list of
        lists, but directly the variance of the active fraction of the network.

        It cannot be set nor deleted. 
        &#34;&#34;&#34;
        try:
            return self._states_dict[&#39;CAA&#39;]
        except KeyError:
            pass

    @property
    def CRR(self):
        &#34;&#34;&#34;Covariances between refractory fractions of populations.

        Matrix (as a list of lists) of covariances between refractory fractions
        of populations with respect to time, or `None` if no such matrix is
        defined. If the network has only one population, it is not a list of
        lists, but directly the variance of the refractory fraction of the
        network.

        It cannot be set nor deleted. 
        &#34;&#34;&#34;
        try:
            return self._states_dict[&#39;CRR&#39;]
        except KeyError:
            pass

    @property
    def CSS(self):
        &#34;&#34;&#34;Covariances between sensitive fractions of populations.

        Matrix (as a list of lists) of covariances between sensitive fractions
        of populations with respect to time, or `None` if no such matrix is
        defined. If the network has only one population, it is not a list of
        lists, but directly the variance of the sensitive fraction of the
        network.

        It cannot be set nor deleted. 
        &#34;&#34;&#34;
        try:
            return self._states_dict[&#39;CSS&#39;]
        except KeyError:
            pass

    @property
    def CAR(self):
        &#34;&#34;&#34;Covariances between active and refractory fractions of populations.

        Matrix (as a list of lists) of covariances between active and refractory
        fractions of populations with respect to time, or `None` if no such
        matrix is defined. If the network has only one population, it is not a
        list of lists, but directly the covariance between the active and
        refractory fractions of the network.

        It cannot be set nor deleted.
        &#34;&#34;&#34;
        try:
            return self._states_dict[&#39;CAR&#39;]
        except KeyError:
            pass

    @property
    def CAS(self):
        &#34;&#34;&#34;Covariances between active and sensitive fractions of populations.

        Matrix (as a list of lists) of covariances between active and sensitive
        fractions of populations with respect to time, or `None` if no such
        matrix is defined. If the network has only one population, it is not a
        list of lists, but directly the covariance between the active and
        sensitive fractions of the network.

        It cannot be set nor deleted.
        &#34;&#34;&#34;
        try:
            return self._states_dict[&#39;CAS&#39;]
        except KeyError:
            pass

    @property
    def CRS(self):
        &#34;&#34;&#34;Covariances between refractory and sensitive fractions of populations.

        Matrix (as a list of lists) of covariances between refractory and
        sensitive fractions of populations with respect to time, or `None` if no
        such matrix is defined. If the network has only one population, it is
        not a list of lists, but directly the covariance between the refractory
        and sensitive fractions of the network.

        It cannot be set nor deleted.
        &#34;&#34;&#34;
        try:
            return self._states_dict[&#39;CRS&#39;]
        except KeyError:
            pass

    def default_figure(self, ncol=None, show=True, savefig=False, **kwargs):
        &#34;&#34;&#34;Draw a figure with default plots and parameters.

        Draw a figure with default plots and parameters. The curves plotted by
        default are all fractions of populations (or their expectations or
        averages) and their variances, if those are defined for the result. The
        keyword arguments listed in the [Other Parameters](#other-parameters)
        section below give a little more control over the curves which are
        plotted, for results with a lot of components. If the figure is saved,
        it is under *ID - name.png*, where *ID* and *name* are the
        corresponding attributes of the result, and it is placed in the
        current directory.

        Parameters
        ----------
        ncol : int, optional
            Number of columns of the legend, passed to `Graphics.legend`.
            Defaults to `None`, in which case a default value is replaced.
        show : bool
            Decides if the figure is shown or not. Defaults to `True`.
        savefig : bool, optional
            Decides if the figure is saved or not. Defaults to `False`.
        **kwargs
            Keyword arguments to be passed to an internal method that decides
            what is plotted on the figure. Valid keyword arguments are given in
            the [Other Parameters](#other-parameters) section below.
        
        Other Parameters
        ----------------
        expectations : bool, optional
            Decides whether expectations (or averages) are plotted on the
            figure. Valid in `ExtendedSolution`, `Statistics` and `Spectrum`.
            Defaults to `True` whenever it is valid.
        variances : bool, optional
            Decides whether variances are plotted on the figure. Valid in
            `ExtendedSolution`, `Statistics` and `Spectrum`. Defaults to `True`
            whenever it is valid.
        covariances : bool, optional
            Decides whether non-symmetric covariances are plotted on the figure.
            Valid in `ExtendedSolution`, `Statistics` and `Spectrum`. Defaults
            to `False`.
        third_moments : bool, optional
            Decides whether third central moments are plotted on the figure.
            Valid in `Statistics` and `Spectrum`. Defaults to `False`.
        &#34;&#34;&#34;
        self.activate()
        self._default_plots(**kwargs)
        self.setup()
        self.legend(ncol=ncol)
        self.draw(show=show, savefig=savefig)

    def get_spectrum(self, name=None):
        &#34;&#34;&#34;Get the spectrum of this result.

        Get a `Spectrum` instance corresponding to `self` where each state
        component is replaced by its real fast Fourier transform.

        Parameters
        ----------
        name : str, optional
            Name to associate with the spectrum. Defaults to `None`, in which
            case it is replaced with `&#39;Spectrum&#39;`.

        Returns
        -------
        Spectrum
            The spectrum of the result `self`.
        &#34;&#34;&#34;
        return Spectrum(self.config, self._states_dict, self.times, 
                        self.default_name, name)

    def setup(self, set_xlabel=True, units=&#39;ms&#39;, fontsize=10, xlim=&#39;time&#39;,
              ylim=&#39;fractions&#39;):
        &#34;&#34;&#34;Setup a figure.

        Setup the figure `Result.fig`. Allows to set an automatic label to the
        horizontal axis based on `Result.x_units`, to choose a font size for
        the labels, and to set limits to both axes.

        Parameters
        ----------
        set_xlabel : bool, optional
            Decides if the horizontal axis is labelled. Defaults to `True`.
        units : str, optional
            Time units for the horizontal axis, indicated in square brackets on
            the figure. If it is set to the empty string `&#39;&#39;`, no extra square
            brackets are added. Defaults to `&#39;ms&#39;`, which assumes that
            transition rates are given in kHz.
        fontsize : float, optional
            Font size in points for the horizontal axis&#39; label. Defaults to 10.
        xlim : {&#39;time&#39;, &#39;config&#39;, &#39;unbounded&#39;}, optional
            Decides how the horizontal axis is bounded. If `&#39;time`&#39;, it is
            bounded by the initial and final values of the times array. If
            `&#39;config&#39;`, it is bounded by the initial and final times of
            the configuration. If `&#39;unbounded&#39;`, it is not bounded.
            Defaults to `&#39;time&#39;`.
        ylim : {&#39;fractions&#39;, &#39;covariances&#39;, &#39;unbounded&#39;}, optional
            Decides how the vertical axis is bounded. If `&#39;fractions&#39;`, it is
            bounded between 0 and 1. If `&#39;covariances&#39;`, it is bounded between
            between -1/4 and 1. If `&#39;unbounded&#39;`, it is not bounded. Defaults
            to `&#39;fractions&#39;`.

        Raises
        ------
        popnet.exceptions.PopNetError
            If no figure and axes are bound to `Result.fig` and `Result.ax`.
        ValueError
            If `xlim` or `ylim` is given a non-valid value.
        &#34;&#34;&#34;
        self._check_if_activated()
        self._set_xlabel(set_xlabel, units, fontsize)
        self._check_lim_value(&#39;x&#39;, xlim)
        self._check_lim_value(&#39;y&#39;, ylim)
        self._set_xlim(xlim)
        self._set_ylim(ylim)

    def _add_colors_items_one(self):
        &#34;&#34;&#34;Add items to the `colors` dictionary. 

        Add to the `colors` dictionary items corresponding to state variables
        involving *one* population, and define some default colors.
        &#34;&#34;&#34;
        for X in [&#39;A&#39;, &#39;R&#39;, &#39;S&#39;]:
            self.colors[X] = [None for pop in self.config.network.populations]
        if (p := len(self.config.network.populations)) == 1:
            self.colors[&#39;A&#39;][0] = (150/255,10/255,47/255)
            self.colors[&#39;R&#39;][0] = &#39;midnightblue&#39;
            self.colors[&#39;S&#39;][0] = &#39;goldenrod&#39;
        elif p == 2:
            self.colors[&#39;A&#39;] = [&#39;midnightblue&#39;, (150/255,10/255,47/255)]
            self.colors[&#39;R&#39;] = [&#39;royalblue&#39;, &#39;crimson&#39;]
            self.colors[&#39;S&#39;] = [&#39;skyblue&#39;, (243/255,125/255,148/255)]

    def _add_colors_items_two(self):
        &#34;&#34;&#34;Add items to the `colors` dictionary. 

        Add to the `colors` dictionary items corresponding to variables
        involving *two* populations, and define some default colors.
        &#34;&#34;&#34;
        for XY in [&#39;AA&#39;, &#39;RR&#39;, &#39;SS&#39;, &#39;AR&#39;, &#39;AS&#39;, &#39;RS&#39;]:
            key = f&#39;C{XY}&#39;
            self.colors[key] = [[None for p1 in self.config.network.populations]
                                      for p2 in self.config.network.populations]
        if (p := len(self.config.network.populations)) == 1:
            self.colors[&#39;CAA&#39;][0][0] = &#39;salmon&#39;
            self.colors[&#39;CRR&#39;][0][0] = &#39;skyblue&#39;
            self.colors[&#39;CSS&#39;][0][0] = &#39;gold&#39;
            self.colors[&#39;CAR&#39;][0][0] = &#39;violet&#39;
            self.colors[&#39;CAS&#39;][0][0] = (255/255,180/255,0)
            self.colors[&#39;CRS&#39;][0][0] = &#39;springgreen&#39;
        elif p == 2:
            self.colors[&#39;CAA&#39;] = [[&#39;seagreen&#39;, None], [None, &#39;blueviolet&#39;]]
            self.colors[&#39;CRR&#39;] = [[&#39;mediumseagreen&#39;, None], 
                                  [None, &#39;mediumorchid&#39;]]
            self.colors[&#39;CSS&#39;] = [[&#39;springgreen&#39;, None], [None, &#39;violet&#39;]]

    def _add_colors_items_three(self):
        &#34;&#34;&#34;Add items to the `colors` dictionary. 

        Add to the `colors` dictionary items corresponding to variables
        involving *three* populations.
        &#34;&#34;&#34;
        keys = [&#39;AAA&#39;, &#39;AAR&#39;, &#39;AAS&#39;, &#39;ARR&#39;, &#39;ARS&#39;, 
                &#39;ASS&#39;, &#39;RRR&#39;, &#39;RRS&#39;, &#39;RSS&#39;, &#39;SSS&#39;]
        for k in keys:
            self.colors[k] = [[[None for p1 in self.config.network.populations]
                                     for p2 in self.config.network.populations]
                                     for p3 in self.config.network.populations]

    @staticmethod
    def _check_config(config, ID):
        &#34;&#34;&#34;Check if `config` is a valid configuration when loading a result.&#34;&#34;&#34;
        if config is None:
            return structures.load_config(ID)
        if not isinstance(config, structures.Configuration):
            raise TypeError(&#39;The configuration to associate with a loaded &#39;
                            &#39;result must be a \&#39;Configuration\&#39; instance.&#39;)
        if config.ID != ID:
            raise PopNetError(&#39;The configuration to associate with a result &#39;
                              f&#39;loaded from ID {ID} must have the same ID.&#39;)
        return config

    @classmethod
    def _check_lim_value(cls, axis, value):
        &#34;&#34;&#34;Check if `value` is valid to bound axis `axis`.&#34;&#34;&#34;
        if value not in cls._lim_valid_values[axis]:
            raise ValueError(f&#39;The value \&#39;{value}\&#39; is not valid for the &#39;
                             f&#39;parameter {axis}lim of setup(). Valid values &#39;
                             f&#39;are {cls._lim_valid_values[axis]}.&#39;)

    def _default_plots(self, one=True, symmetric=False, nonsymmetric=False,
                       three=False):
        &#34;&#34;&#34;Add plots on the default figure.&#34;&#34;&#34;
        if one: self._plot_all_one()
        self._plot_all_two(symmetric=symmetric, nonsymmetric=nonsymmetric)
        if three: self._plot_all_three()

    def _get_fractions_dict(self, states):
        &#34;&#34;&#34;Get the fractions variables dictionary.&#34;&#34;&#34;
        transposed_states = np.transpose(states)
        A = transposed_states[: (p := len(self.config.network.populations))]
        R = transposed_states[p : 2*p]
        S = 1 - A - R
        return {&#39;A&#39;: A, &#39;R&#39;: R, &#39;S&#39;: S}

    def _init_abscissa(self, times):
        &#34;&#34;&#34;Initialize array related to the independant variable.&#34;&#34;&#34;
        self._times = times

    def _init_colors(self):
        &#34;&#34;&#34;Initialize the colors associated with state variables.&#34;&#34;&#34;
        self.colors = _internals.PopNetDict()
        self._add_colors_items_one()

    def _init_plot_methods(self):
        &#34;&#34;&#34;Initialize plotting methods of state variables.&#34;&#34;&#34;
        self._plot = self._plot_dict_one()

    def _init_states_dict(self, states):
        &#34;&#34;&#34;Initialize the state variables dictionary.&#34;&#34;&#34;
        self._states_dict = self._get_fractions_dict(states)

    def _label_one(self, X, J):
        pass

    def _label_two(self, CXY, J, K):
        pass

    def _label_three(self, XYZ, J, K, L):
        pass

    def _make_plot_one(self, X, J, states=None, label_func=None, lw=None, ls=None):
        &#34;&#34;&#34;Define a plotting method for a given state variable.

        Define a method to plot the state variable `X` for the population `J`,
        labeling the curve with `label_func` and taking the data in `states`.
        &#34;&#34;&#34;
        if states is None:
            states = self._states_dict
        if label_func is None:
            label_func = self._label_one
        def f(add_label=True, lw=lw, ls=ls, color=None, label=None, **kwargs):
            self._check_if_activated()
            if color is None:
                color = self.colors[X][J]
            if add_label and label is None:
                label = label_func(X, J)
            line, = self.ax.plot(self.times, states[X][J], label=label, lw=lw,
                                 ls=ls, color=color, **kwargs)
            return line
        return f

    def _make_plot_two(self, CXY, J, K):
        &#34;&#34;&#34;Define a plotting method for a covariance.

        Define a method to plot the covariance `CXY` for the `J`th and `K`th
        population.
        &#34;&#34;&#34;
        def f(color=None, label=None, **kwargs):
            self._check_if_activated()
            if color is None:
                color = self.colors[CXY][J][K]
            if label is None:
                label = self._label_two(CXY[1:], J, K)
            covariance = self._states_dict[CXY][J][K]
            line, = self.ax.plot(self.times, covariance, label=label,
                                 color=color, **kwargs)
            return line
        return f

    def _make_plot_three(self, XYZ, J, K, L):
        &#34;&#34;&#34;Define a plotting method for a third central moment.
        
        Define a method to plot the third central moment for the state variables
        `X`, `Y` and `Z` for the `J`th, `K`th and `L`th population respectively.
        &#34;&#34;&#34;
        def f(verbose=True, color=None, label=None, **kwargs):
            self._check_if_activated()
            try:
                moment = self._states_dict[XYZ][J][K][L]
            except (KeyError, IndexError):
                moment = None
            if moment is None:
                if verbose:
                    warn(&#39;The third central moment requested to plot is not &#39;
                         &#39;available. If this result has third central moments, &#39;
                         &#39;there should be a transposition of indices that &#39;
                         &#39;allows to get the same moment in another way.&#39;,
                         category=PopNetWarning, stacklevel=2)
                return None
            if color is None:
                color = self.colors[XYZ][J][K][L]
            if label is None:
                label = self._label_three(XYZ, J, K, L)
            line, = self.ax.plot(self.times, moment, label=label, 
                                 color=color, **kwargs)
            return line
        return f

    def _plot_all_one(self, **kwargs):
        &#34;&#34;&#34;Plot all state variables associated with *one* population.&#34;&#34;&#34;
        for J in range(len(self.config.network.populations)):
            for X in [&#39;A&#39;, &#39;R&#39;, &#39;S&#39;]:
                self.plot[X][J](**kwargs)

    def _plot_all_two(self, symmetric=True, nonsymmetric=True, **kwargs):
        &#34;&#34;&#34;Plot all state variables associated with *two* populations.

        Parameters
        ----------
        symmetric : bool, optional
            Decides whether variances are plotted. Defaults to `True`.
        nonsymmetric : bool, optional
            Decides whether non-symmetric covariances are plotted. Defaults to
            `True`.
        &#34;&#34;&#34;
        p = len(self.config.network.populations)
        for J, K in np.ndindex((p,p)):
            for CXX in [&#39;CAA&#39;, &#39;CRR&#39;, &#39;CSS&#39;]:
                if J == K and symmetric:
                    self.plot[CXX][J][K](**kwargs)
                if J &lt; K and nonsymmetric:
                    self.plot[CXX][J][K](**kwargs)
            for CXY in [&#39;CAR&#39;, &#39;CAS&#39;, &#39;CRS&#39;]:
                if nonsymmetric:
                    self.plot[CXY][J][K](**kwargs)

    def _plot_all_three(self, **kwargs):
        &#34;&#34;&#34;Plot all state variables associated with *three* populations.&#34;&#34;&#34;
        p = len(self.config.network.populations)
        for XYZ in [&#39;AAA&#39;, &#39;AAR&#39;, &#39;AAS&#39;, &#39;ARR&#39;, &#39;ARR&#39;,
                    &#39;ASS&#39;, &#39;RRR&#39;, &#39;RRS&#39;, &#39;RSS&#39;, &#39;SSS&#39;]:
            for J, K, L in np.ndindex((p,p,p)):
                self.plot[XYZ][J][K][L](verbose=False, **kwargs)

    def _plot_dict_one(self, **kwargs):
        &#34;&#34;&#34;Return a dictionary of plotting methods for *one* population.&#34;&#34;&#34;
        p = len(self.config.network.populations)
        return {X: [self._make_plot_one(X, J, **kwargs) for J in range(p)]
                for X in [&#39;A&#39;, &#39;R&#39;, &#39;S&#39;]}

    def _plot_dict_two(self):
        &#34;&#34;&#34;Return a dictionary of plotting methods for *two* populations.&#34;&#34;&#34;
        p = len(self.config.network.populations)
        return {CXY: [[self._make_plot_two(CXY, J, K)
                       for K in range(p)] for J in range(p)]
                for CXY in [&#39;CAA&#39;, &#39;CRR&#39;, &#39;CSS&#39;, &#39;CAR&#39;, &#39;CAS&#39;, &#39;CRS&#39;]}

    def _plot_dict_three(self):
        &#34;&#34;&#34;Return a dictionary of plotting methods for *three* populations.&#34;&#34;&#34;
        p = len(self.config.network.populations)
        return {XYZ: [[[self._make_plot_three(XYZ, J, K, L) for L in range(p)]
                        for K in range(p)] for J in range(p)]
                for XYZ in [&#39;AAA&#39;, &#39;AAR&#39;, &#39;AAS&#39;, &#39;ARR&#39;, &#39;ARS&#39;,
                            &#39;ASS&#39;, &#39;RRR&#39;, &#39;RRS&#39;, &#39;RSS&#39;, &#39;SSS&#39;]}

    def _set_xlabel(self, set, units, fontsize):
        &#34;&#34;&#34;Set the label of the horizontal axis of a figure.&#34;&#34;&#34;
        if set:
            units = f&#39; [{units}]&#39; if units != &#39;&#39; else &#39;&#39;
            self.ax.set_xlabel(f&#39;{self.x_units}{units}&#39;, fontsize=fontsize)

    def _set_xlim(self, xlim):
        &#34;&#34;&#34;Set the limits of the horizontal axis of a figure.&#34;&#34;&#34;
        if xlim == &#39;time&#39;:
            self.ax.set_xlim(self.times[0], self.times[-1])
        elif xlim == &#39;config&#39;:
            self.ax.set_xlim(self.config.initial_time, self.config.final_time)
        elif xlim == &#39;unbounded&#39;:
            pass

    def _set_ylim(self, ylim):
        &#34;&#34;&#34;Set the limits of the vertical axis of a figure.&#34;&#34;&#34;
        if ylim == &#39;fractions&#39;:
            self.ax.set_ylim([0, 1])
        elif ylim == &#39;covariances&#39;:
            self.ax.set_ylim([-1/4, 1])
        elif ylim == &#39;unbounded&#39;:
            pass


class _ResultOne(Result):
    &#34;&#34;&#34;Adapts `Result` to the special case of a single population.

    `_ResultOne` adapts `Result` for the case where the network associated with
    the configuration used has only one population.

    The main changes are that the attributes of the form `X` or `CXY` are
    overridden to return directly the corresponding quantity with respect to
    time instead of returning them as lists containing a single element. In the
    same way, the `plot` dictionary values are overridden to be methods rather
    than lists of methods. Also, the default name for a `_ResultOne` class
    trims out the `&#39;One&#39;` suffix of the class&#39; name to leave only `Result`.

    &#34;&#34;&#34;

    @property
    def A(self):
        &#34;&#34;&#34;Get the active fraction of the network.&#34;&#34;&#34;
        return self._states_dict[&#39;A&#39;][0]

    @property
    def R(self):
        &#34;&#34;&#34;Get the refractory fraction of the network.&#34;&#34;&#34;
        return self._states_dict[&#39;R&#39;][0]

    @property
    def S(self):
        &#34;&#34;&#34;Get the sensitive fraction of the network.&#34;&#34;&#34;
        return self._states_dict[&#39;S&#39;][0]

    @property
    def CAA(self):
        &#34;&#34;&#34;Get the variance of the active fraction of the network.&#34;&#34;&#34;
        try:
            return self._states_dict[&#39;CAA&#39;][0][0]
        except KeyError:
            pass

    @property
    def CRR(self):
        &#34;&#34;&#34;Get the variance of the refractory fraction of network.&#34;&#34;&#34;
        try:
            return self._states_dict[&#39;CRR&#39;][0][0]
        except KeyError:
            pass

    @property
    def CSS(self):
        &#34;&#34;&#34;Get the variance of the sensitive fraction of network.&#34;&#34;&#34;
        try:
            return self._states_dict[&#39;CSS&#39;][0][0]
        except KeyError:
            pass

    @property
    def CAR(self):
        &#34;&#34;&#34;Covariance between active and refractory fractions of the network.&#34;&#34;&#34;
        try:
            return self._states_dict[&#39;CAR&#39;][0][0]
        except KeyError:
            pass

    @property
    def CAS(self):
        &#34;&#34;&#34;Covariance between active and sensitive fractions of the network.&#34;&#34;&#34;
        try:
            return self._states_dict[&#39;CAS&#39;][0][0]
        except KeyError:
            pass

    @property
    def CRS(self):
        &#34;&#34;&#34;Covariance between refractory and sensitive fractions of the network.
        &#34;&#34;&#34;
        try:
            return self._states_dict[&#39;CRS&#39;][0][0]
        except KeyError:
            pass

    def _plot_all_one(self, **kwargs):
        &#34;&#34;&#34;Plot all state variables associated with *one* population.&#34;&#34;&#34;
        for X in [&#39;A&#39;, &#39;R&#39;, &#39;S&#39;]:
            self.plot[X](**kwargs)

    def _plot_all_two(self, symmetric=True, nonsymmetric=True, **kwargs):
        &#34;&#34;&#34;Plot all state variables associated with *two* populations.&#34;&#34;&#34;
        if symmetric:
            for CXX in [&#39;CAA&#39;, &#39;CRR&#39;, &#39;CSS&#39;]:
                self.plot[CXX](**kwargs)
        if nonsymmetric:
            for CXY in [&#39;CAR&#39;, &#39;CAS&#39;, &#39;CRS&#39;]:
                self.plot[CXY](**kwargs)

    def _plot_all_three(self, **kwargs):
        &#34;&#34;&#34;Plot all state variables associated with *three* populations.&#34;&#34;&#34;
        p = len(self.config.network.populations)
        for XYZ in [&#39;AAA&#39;, &#39;AAR&#39;, &#39;AAS&#39;, &#39;ARR&#39;, &#39;ARR&#39;,
                    &#39;ASS&#39;, &#39;RRR&#39;, &#39;RRS&#39;, &#39;RSS&#39;, &#39;SSS&#39;]:
            self.plot[XYZ](verbose=False, **kwargs)

    def _plot_dict_one(self, **kwargs):
        &#34;&#34;&#34;Return a dictionary of plotting methods for *one* population.&#34;&#34;&#34;
        return {X: self._make_plot_one(X, 0, **kwargs) for X in [&#39;A&#39;, &#39;R&#39;, &#39;S&#39;]}

    def _plot_dict_two(self):
        &#34;&#34;&#34;Return a dictionary of plotting methods for *two* populations.&#34;&#34;&#34;
        return {CXY: self._make_plot_two(CXY, 0, 0)
                for CXY in [&#39;CAA&#39;, &#39;CRR&#39;, &#39;CSS&#39;, &#39;CAR&#39;, &#39;CAS&#39;, &#39;CRS&#39;]}

    def _plot_dict_three(self):
        &#34;&#34;&#34;Return a dictionary of plotting methods for *three* populations.&#34;&#34;&#34;
        return {XYZ: self._make_plot_three(XYZ, 0, 0, 0)
                for XYZ in [&#39;AAA&#39;, &#39;AAR&#39;, &#39;AAS&#39;, &#39;ARR&#39;, &#39;ARS&#39;,
                            &#39;ASS&#39;, &#39;RRR&#39;, &#39;RRS&#39;, &#39;RSS&#39;, &#39;SSS&#39;]}


class Solution(Result):
    &#34;&#34;&#34;Represent solutions of dynamical systems.

    `Solution` extends `Result` for the case where the result is a solution
    obtained from a numerical integration of a dynamical system related to the
    Wilson--Cowan model. It adds a method to the base class to plot the
    expectations of fractions of populations all at once. Other changes are
    implementation details.

    &#34;&#34;&#34;

    default_name = &#39;Solution&#39;
    &#34;&#34;&#34;Default name given to instances.&#34;&#34;&#34;

    def plot_expectations(self, **kwargs):
        &#34;&#34;&#34;Plot all expectations of fractions of populations.

        Plot all expectations of active, refractory and sensitive fractions of
        populations on the figure `Solution.fig`.
        
        Parameters
        ----------
        **kwargs
            Keyword arguments to be passed to the method that plots components,
            which is the [`plot`](https://31c8.short.gy/ax-plot) method of
            `Solution.ax`.

        Raises
        ------
        popnet.exceptions.PopNetError
            If no figure and axes are bound to `Solution.fig` and `Solution.ax`.
        &#34;&#34;&#34;
        self._plot_all_one(**kwargs)

    def _label_one(self, X, J):
        &#34;&#34;&#34;Label for the expectation of `X` for the `J`th population.&#34;&#34;&#34;
        return f&#39;$\\mathcal{{{X}}}_{{{self.config.network.populations[J].ID}}}$&#39;


class _SolutionOne(_ResultOne, Solution):
    &#34;&#34;&#34;Special case of `Solution` for a single population.

    Special case of `Solution` to use when the network has a single population.
    The only change from the base classes is the implementation of the
    components&#39; labels.

    &#34;&#34;&#34;

    def _label_one(self, X, J):
        &#34;&#34;&#34;Label for the expectation of `X`.&#34;&#34;&#34;
        return f&#39;$\\mathcal{{{X}}}$&#39;


class ExtendedSolution(Solution):
    &#34;&#34;&#34;Represent solutions of extended dynamical systems.

    `ExtendedSolution` extends `Solution` for cases where covariances are
    considered in the dynamical system that was integrated to obtain the
    solution. It adds methods to the base class to plot variances or
    non-symmetric covariances of fractions of populations all at once. Other
    changes are implementation details.

    &#34;&#34;&#34;

    default_name = &#39;Solution (extended)&#39;
    &#34;&#34;&#34;Default name given to instances.&#34;&#34;&#34;

    def plot_variances(self, **kwargs):
        &#34;&#34;&#34;Plot all variances of *A*&#39;s, *R*&#39;s and *S*&#39;s.

        Plot all variances of active, refractory and sensitive fractions of
        populations on the figure `ExtendedSolution.fig`.

        Parameters
        ----------
        **kwargs
            Keyword arguments to be passed to the method that plots components,
            which is the [`plot`](https://31c8.short.gy/ax-plot) method of
            `ExtendedSolution.ax`.

        Raises
        ------
        popnet.exceptions.PopNetError
            If no figure and axes are bound to `ExtendedSolution.fig` and
            `ExtendedSolution.ax`.
        &#34;&#34;&#34;
        self._plot_all_two(symmetric=True, nonsymmetric=False, **kwargs)

    def plot_covariances(self, **kwargs):
        &#34;&#34;&#34;Plot all non-symmetric covariances of *A*&#39;s, *R*&#39;s and *S*&#39;s.

        Plot all non-symmetric covariances of active, refractory and sensitive
        fractions of populations on the figure `ExtendedSolution.fig`.

        Parameters
        ----------
        **kwargs
            Keyword arguments to be passed to the method that plots components,
            which is the [`plot`](https://31c8.short.gy/ax-plot) method of
            `ExtendedSolution.ax`.

        Raises
        ------
        popnet.exceptions.PopNetError
            If no figure and axes are bound to `ExtendedSolution.fig` and
            `ExtendedSolution.ax`.
        &#34;&#34;&#34;
        self._plot_all_two(symmetric=False, nonsymmetric=True, **kwargs)

    def _default_plots(self, expectations=True, variances=True, 
                       covariances=False):
        &#34;&#34;&#34;Add plots on the default figure.&#34;&#34;&#34;
        super()._default_plots(one=expectations, symmetric=variances, 
                               nonsymmetric=covariances, three=False)

    def _init_colors(self):
        &#34;&#34;&#34;Initialize the colors associated with state variables.&#34;&#34;&#34;
        super()._init_colors()
        self._add_colors_items_two()

    def _init_plot_methods(self):
        &#34;&#34;&#34;Initialize plotting methods of state variables.&#34;&#34;&#34;
        super()._init_plot_methods()
        self._plot = {**self.plot, **self._plot_dict_two()}

    def _init_states_dict(self, states):
        &#34;&#34;&#34;Initialize the attributes associated with state variables.&#34;&#34;&#34;
        expects = self._get_fractions_dict(states)
        p = len(self.config.network.populations)
        transposed_states = np.transpose(states)
        CAA_flat = transposed_states[2*p : round(2*p + p*(p+1)/2)]
        CAA = _internals._unflat_vector_triangle(CAA_flat)
        CRR_flat = transposed_states[2*p + round(p*(p+1)/2) : 2*p + p*(p+1)]
        CRR = _internals._unflat_vector_triangle(CRR_flat)
        CAR_flat = transposed_states[2*p + p*(p+1) :]
        CAR = CAR_flat.reshape((p,p,len(CAR_flat[0])))
        CAS = - CAA - CAR
        CRS = - CRR - np.transpose(CAR, axes=(1,0,2))
        CSS = - CAS - CRS
        covs = {&#39;CAA&#39;: CAA, &#39;CRR&#39;: CRR, &#39;CSS&#39;: CSS,
                &#39;CAR&#39;: CAR, &#39;CAS&#39;: CAS, &#39;CRS&#39;: CRS}
        self._states_dict = {**expects, **covs}

    def _label_two(self, XY, J, K):
        &#34;&#34;&#34;Label for the covariance between `X` and `Y` for the `J`th and `K`th
        populations.&#34;&#34;&#34;
        IDs = &#39;&#39;.join([self.config.network.populations[P].ID for P in (J, K)])
        return f&#39;$\\mathrm{{C}}_{{{XY}}}^{{{IDs}}}$&#39;


class _ExtendedSolutionOne(_SolutionOne, ExtendedSolution):
    &#34;&#34;&#34;Special case of `ExtendedSolution` for a single population.

    Special case of `ExtendedSolution` to use when the network has a single
    population. The only change from the base classes is the implementation of
    the components&#39; labels.

    &#34;&#34;&#34;

    def _label_two(self, XY, J, K):
        &#34;&#34;&#34;Label for the covariance between `X` and `Y`.&#34;&#34;&#34;
        return f&#39;$\\mathrm{{C}}_{{{XY}}}$&#39;


class Trajectory(Result):
    &#34;&#34;&#34;Represent trajectories of stochastic processes.

    `Trajectory` extends `Result` for the case where the result is a possible
    trajectory of a stochastic process that rules the microscopic dynamics
    of the network. It adds a method to the base class to plot the fractions of
    populations all at once, and it adapts the loading method. Other changes
    are implementation details.

    &#34;&#34;&#34;

    default_name = &#39;Trajectory&#39;
    &#34;&#34;&#34;Default name given to instances.&#34;&#34;&#34;

    @classmethod
    def load(cls, ID, name=None, config=None, folder=None):
        &#34;&#34;&#34;Load the trajectory associated with the ID.

        Load the trajectory obtained when using the configuration of ID `ID`. It
        extends the base class method by loading the `times` array, which is
        assumed to be in a file named *ID - name (times).txt*, where *ID* and
        *name* are indeed `ID` and `name`. Returns a `Trajectory` instance.

        See Also
        --------
        Result.load
        &#34;&#34;&#34;
        name = cls._get_name(name)
        filename = _internals._format_filename(folder, ID, f&#39;{name} (times)&#39;)
        try:
            times = np.loadtxt(filename, dtype=float)
        except FileNotFoundError as error:
            raise FileNotFoundError(
                f&#39;No times array found for configuration {ID}&#39;) from error
        return super().load(ID, name, config=config, times=times, folder=folder)
        
    def plot_fractions(self, **kwargs):
        &#34;&#34;&#34;Plot all fractions of populations.

        Plot all active, refractory and sensitive fractions of population on
        the figure `Trajectory.fig`.
        
        Parameters
        ----------
        **kwargs
            Keyword arguments to be passed to the method that plots components,
            which is the [`plot`](https://31c8.short.gy/ax-plot) method of
            `Trajectory.ax`.

        Raises
        ------
        popnet.exceptions.PopNetError
            If no figure and axes are bound to `Trajectory.fig` and
            `Trajectory.ax`.
        &#34;&#34;&#34;
        self._plot_all_one(**kwargs)

    def _label_one(self, X, J):
        &#34;&#34;&#34;Label for the fraction `X` of the `J`th population.&#34;&#34;&#34;
        return f&#39;${X}^{{{self.config.network.populations[J].ID}}}$&#39;


class _TrajectoryOne(_ResultOne, Trajectory):
    &#34;&#34;&#34;Special case of `Trajectory` for a single population.

    Special case of `Trajectory` to use when the network has a single
    population. The only change from the base classes is the implementation of
    the components&#39; labels.

    &#34;&#34;&#34;

    def _label_one(self, X, J):
        &#34;&#34;&#34;Label for the fraction `X` of the population.&#34;&#34;&#34;
        return f&#39;${X}$&#39;


class Statistics(Result):
    &#34;&#34;&#34;Represent statistics obtained from sample trajectories.

    `Statistics` extends `Result` for the case where the result is a set of
    statistics obtained from multiple trajectories of a stochastic process
    that rules the microscopic evolution of the network.

    The most important extension from the `Result` class is a set of methods to
    plot fills between given bounds around a mean value, and methods to plot the
    minimum and maximum values of a variable at each time step. For details,
    see `Statistics.fill`, `Statistics.plot_max` and `Statistics.plot_min`.
    Besides these new methods, it also adds other methods to plot several state
    components at once, and it adapts the loading method. Other changes are
    implementation details.

    The parameters at initialization are the same as in the base class, except
    that `states` is now expected to be a three-dimensional array of *samples*
    of trajectories of the stochastic process, with time along the first axis,
    state variables along the second, and different simulations along the third.
    Note that this is the format of samples handled by
    `popnet.executors.ChainSimulator`.

    Warns
    -----
    popnet.exceptions.PopNetWarning
        If the given samples do not provide enough trajectories to compute
        unbiased estimates of central moments.

    &#34;&#34;&#34;

    default_name = &#39;Statistics&#39;
    &#34;&#34;&#34;Default name given to instances.&#34;&#34;&#34;
    default_sample_name = &#39;Sample&#39;
    &#34;&#34;&#34;Default name for samples used when loading them.&#34;&#34;&#34;

    @classmethod
    def load(cls, ID, sample_name=None, name=None, config=None, folder=None):
        &#34;&#34;&#34;Compute statistics from loaded sample trajectories.

        Compute statistics needed to define a `Statistics` instance from loaded
        samples. For each component *X*, the samples are assumed to be in a
        file named *ID - sample_name X.txt*, where *ID* and *sample_name* are
        indeed `ID` and `sample_name`. In the file for a component *X*, it is
        assumed that in each column are the values of *X* with respect to time
        for a given trajectory.

        Parameters
        ----------
        ID : str
            ID of the configuration used to obtain the samples. 
        sample_name : str, optional
            Name associated with the samples to be loaded. Defaults to `None`,
            in which case is it replaced with `&#39;Sample&#39;`.
        name : str, optional
            Name associated with the result. Defaults to `None`, in which case
            it is replaced with `&#39;Statistics&#39;`.
        config : popnet.structures.Configuration, optional
            Configuration to associate with the result. If given, it must have
            the ID `ID`. Defaults to `None`, in which case it is loaded from ID
            `ID`.
        folder : str, optional
            Folder in which the files are located, which should be placed in the
            current directory. Defaults to `None`, in which case the files are
            assumed to be located in the current directory.

        Returns
        -------
        Statistics
            Statistics computed from the loaded samples.

        Raises
        ------
        TypeError
            If `config` is neither `None` nor a
            `popnet.structures.Configuration` instance.
        popnet.exceptions.PopNetError
            If `config` has a different ID than `ID`. 
        FileNotFoundError
            If no file is found with the expected name for a component.
        &#34;&#34;&#34;
        config = cls._check_config(config, ID)
        sample_name = cls._get_sample_name(sample_name)
        samples = []
        p = len(config.network.populations)
        for J, X in enumerate(config._variables[:2*p]):
            filename = _internals._format_filename(
                            folder, ID, f&#39;{sample_name} {X}&#39;)
            try:
                samples.append(np.loadtxt(filename, dtype=float))
            except FileNotFoundError as e:
                raise FileNotFoundError(&#39;No samples found for the component &#39;
                                        f&#39;{X} with configuration {ID}.&#39;) from e
        samples = np.transpose(samples, axes=(1,0,2))
        times = np.linspace(config.initial_time, config.final_time, 
                            1 + config.iterations)
        name = cls._get_name(name)
        return cls(config, samples, times, name)

    @property
    def fill(self):
        &#34;&#34;&#34;Dictionary of methods to add fills for state variables.

        if *X* denotes a state variable (that is, either *A*, *R* or *S*), then
        `fill[&#39;X&#39;]` is a list whose *J*th element is a method which adds a fill
        around the mean value, between two bounds. By default, the bounds are
        given by one standard deviation on each side of the mean value. These
        methods all accept the same arguments as `Statistics.fill_all`.

        In the case where the network has only one population, the lists are all
        replaced with the single element they would contain. For example,
        `fill[&#39;A&#39;]` is directly a method to add a fill around the mean value of
        the network&#39;s activity.

        When called, these methods add fills for the corresponding state
        components on the axes `Statistics.ax` of the figure `Statistics.fig`.
        They all accept keyword arguments that can be passed to the
        [`fill_between`](https://31c8.short.gy/ax-fill-between) method of
        `Statistics.ax`. This attribute cannot be set nor deleted.
        &#34;&#34;&#34;
        return self._fill

    @property
    def plot_max(self):
        &#34;&#34;&#34;Dictionary of methods to plot maxima of state variables.

        Analogous dictionary as `Statistics.plot` with keys `&#39;A&#39;`, `&#39;R&#39;` and
        `&#39;S&#39;`, but were the methods plot *maxima* of state variables instead of
        their mean values.
        &#34;&#34;&#34;
        return self._plot_max

    @property
    def plot_min(self):
        &#34;&#34;&#34;Dictionary of methods to plot minima of state variables.

        Analogous dictionary as `Statistics.plot` with keys `&#39;A&#39;`, `&#39;R&#39;` and
        `&#39;S&#39;`, but were the methods plot *minima* of state variables instead of
        their mean values.
        &#34;&#34;&#34;
        return self._plot_min
        
    def fill_all(self, bound=&#39;std&#39;, alpha=.25, **kwargs):
        &#34;&#34;&#34;Add fills between given bounds.

        Add fills between given bounds around the mean values of all fractions
        of populations.

        Parameters
        ----------
        bound : {&#39;std&#39;, &#39;extrema&#39;}, optional
            Describes the bounds between which to fill. If `&#39;std&#39;`, the region
            bounded by one standard deviation around the mean value is filled.
            If `&#39;extrema&#39;`, the region bounded by the minimum and maximum
            values of the component is filled. Defaults to `&#39;std&#39;`.
        alpha : float
            Transparency parameter of the fill. Defaults to 0.25.
        **kwargs
            Keyword arguments to be passed to the method that adds the fills,
            which is the [`fill_between`](https://31c8.short.gy/ax-fill-between)
            method of `Statistics.ax`.
        &#34;&#34;&#34;
        self._fill_all(bound, alpha, **kwargs)

    def plot_averages(self, **kwargs):
        &#34;&#34;&#34;Plot all averages of fractions of populations.

        Plot all sample means of active, refractory and sensitive fractions of
        populations on the figure `Statistics.fig`.

        Parameters
        ----------
        **kwargs
            Keyword arguments to be passed to the method that plots components,
            which is the [`plot`](https://31c8.short.gy/ax-plot) method of
            `Statistics.ax`.

        Raises
        ------
        popnet.exceptions.PopNetError
            If no figure and axes are bound to `Statistics.fig` and
            `Statistics.ax`.
        &#34;&#34;&#34;
        self._plot_all_one(**kwargs)

    def plot_variances(self, **kwargs):
        &#34;&#34;&#34;Plot all variances of fractions of populations.

        Plot all sample variances of active, refractory and sensitive fractions
        of populations on the figure `Statistics.fig`.

        Parameters
        ----------
        **kwargs
            Keyword arguments to be passed to the method that plots components,
            which is the [`plot`](https://31c8.short.gy/ax-plot) method of
            `Statistics.ax`.

        Raises
        ------
        popnet.exceptions.PopNetError
            If no figure and axes are bound to `Statistics.fig` and
            `Statistics.ax`.
        &#34;&#34;&#34;
        self._plot_all_two(symmetric=True, nonsymmetric=False, **kwargs)

    def plot_covariances(self, **kwargs):
        &#34;&#34;&#34;Plot all non-symmetric covariances of fractions of populations.

        Plot all non-symmetric sample covariances between active, refractory and
        sensitive fractions of populations on the figure `Statistics.fig`.

        Parameters
        ----------
        **kwargs
            Keyword arguments to be passed to the method that plots components,
            which is the [`plot`](https://31c8.short.gy/ax-plot) method of
            `Statistics.ax`.

        Raises
        ------
        popnet.exceptions.PopNetError
            If no figure and axes are bound to `Statistics.fig` and
            `Statistics.ax`.
        &#34;&#34;&#34;
        self._plot_all_two(symmetric=False, nonsymmetric=True, **kwargs)

    def plot_third_moments(self, **kwargs):
        &#34;&#34;&#34;Plot all third central moments of fractions of population.

        Plot all sample third central moments of active, refractory and
        sensitive fractions of populations on the figure `Statistics.fig`.

        Parameters
        ----------
        **kwargs
            Keyword arguments to be passed to the method that plots components,
            which is the [`plot`](https://31c8.short.gy/ax-plot) method of
            `Statistics.ax`.

        Raises
        ------
        popnet.exceptions.PopNetError
            If no figure and axes are bound to `Statistics.fig` and
            `Statistics.ax`.
        &#34;&#34;&#34;
        self._plot_all_three(**kwargs)

    def _default_plots(self, expectations=True, variances=True,
                       covariances=False, third_moments=False):
        &#34;&#34;&#34;Add plots on the default figure.&#34;&#34;&#34;
        super()._default_plots(one=expectations, symmetric=variances, 
                               nonsymmetric=covariances, three=third_moments)

    def _fill_all(self, bound, alpha, **kwargs):
        &#34;&#34;&#34;Add fills for all *A*&#39;s, *R*&#39;s and *S*&#39;s.&#34;&#34;&#34;
        p = len(self.config.network.populations)
        for J in range(p):
            for X in [&#39;A&#39;, &#39;R&#39;, &#39;S&#39;]:
                self.fill[X][J](bound=bound, alpha=alpha, **kwargs)

    def _fill_dict(self):
        &#34;&#34;&#34;Return a dictionary of methods to add fills for each population.&#34;&#34;&#34;
        p = len(self.config.network.populations)
        return {X: [self._make_fill(X, J) for J in range(p)]
                for X in [&#39;A&#39;, &#39;R&#39;, &#39;S&#39;]}

    @staticmethod
    def _get_central_moment(samples, stacklevel=1):
        &#34;&#34;&#34;Compute a central moment from samples.

        Compute a central moment from samples. The axes of `samples` are assumed
        to be ordered in the same way as those handled by `ChainSimulator`, but
        the second axis is assumed to span only the relevant components. Hence,
        if the second axis has length *k*, the central moment computed is of
        order *k*.
        &#34;&#34;&#34;
        T = len(samples)
        order = len(samples[0])
        executions = len(samples[0,0])
        coeff = 1 / executions
        if order == 2:
            if executions &gt; 1:
                coeff = 1 / (executions - 1)
            else:
                warn(&#39;Not enough executions to compute an unbiased estimate of &#39;
                     &#39;a covariance. A biased one is computed instead.&#39;,
                     category=PopNetWarning, stacklevel=stacklevel)
        elif order == 3:
            if executions &gt; 2:
                coeff = executions / ((executions - 1) * (executions - 2))
            else:
                warn(&#39;Not enough executions to compute an unbiased estimate of &#39;
                     &#39;a third central moment. A biased one is computed &#39;
                     &#39;instead.&#39;, category=PopNetWarning, stacklevel=stacklevel)
        means = np.mean(samples, axis=2)
        means = np.resize(means, (executions, T, order)).transpose(1,2,0)
        prod = np.prod(samples - means, axis=1)
        return coeff * np.sum(prod, axis=1)

    @classmethod
    def _get_sample_name(cls, sample_name):
        &#34;&#34;&#34;Return `sample_name`, or the default sample name if it is `None`.&#34;&#34;&#34;
        if sample_name is None:
            return cls.default_sample_name
        else:
            return sample_name

    def _init_colors(self):
        &#34;&#34;&#34;Initialize the colors associated with state variables.&#34;&#34;&#34;
        super()._init_colors()
        self._add_colors_items_two()
        self._add_colors_items_three()

    def _init_plot_methods(self):
        &#34;&#34;&#34;Initialize plotting methods of state variables.&#34;&#34;&#34;
        super()._init_plot_methods()
        self._plot = {**self.plot, **self._plot_dict_two(), 
                      **self._plot_dict_three()}
        self._plot_min = self._plot_dict_one(states=self._min_dict, ls=&#39;--&#39;,
                                             lw=1, label_func=self._label_min)
        self._plot_max = self._plot_dict_one(states=self._max_dict, ls=&#39;--&#39;,
                                             lw=1, label_func=self._label_max)
        self._fill = self._fill_dict()

    def _init_states_dict(self, samples):
        &#34;&#34;&#34;Initialize the state variables dictionary.&#34;&#34;&#34;
        p = round(len(samples[0]) / 2)
        samples_S = 1 - samples[:,:p] - samples[:,p:]
        samples = np.concatenate((samples, samples_S), axis=1)
        zero = {&#39;A&#39;: 0, &#39;R&#39;: p, &#39;S&#39;: 2*p}

        self._min_dict = {X: [np.min(samples[:,zero[X]+J], axis=1) 
                              for J in range(p)]
                          for X in [&#39;A&#39;, &#39;R&#39;, &#39;S&#39;]}
        self._max_dict = {X: [np.max(samples[:,zero[X]+J], axis=1) 
                              for J in range(p)]
                          for X in [&#39;A&#39;, &#39;R&#39;, &#39;S&#39;]}
        expect = {X: [np.mean(samples[:,zero[X]+J], axis=1) for J in range(p)]
                  for X in [&#39;A&#39;, &#39;R&#39;, &#39;S&#39;]}

        def element(CXY, J, K):
            C, X, Y = CXY
            return self._get_central_moment(samples[:,[zero[X]+J, zero[Y]+K]], 
                                            stacklevel=9+int(p==1))

        cov = {CXY: [[element(CXY, J, K) for K in range(p)] for J in range(p)]
              for CXY in [&#39;CAA&#39;, &#39;CRR&#39;, &#39;CSS&#39;, &#39;CAR&#39;, &#39;CAS&#39;, &#39;CRS&#39;]}

        def has_to_be_set(X, Y, Z, J, K, L):
            if X == Y == Z:
                return J &lt;= K &lt;= L
            if X == Y:
                return J &lt;= K
            if Y == Z:
                return K &lt;= L
            return True

        def element(XYZ, J, K, L):
            X, Y, Z = XYZ
            if has_to_be_set(X, Y, Z, J, K, L):
                return self._get_central_moment(
                        samples[:,[zero[X]+J, zero[Y]+K, zero[Z]+L]], 
                        stacklevel=10+int(p==1))
            return None

        triplets = [&#39;AAA&#39;, &#39;AAR&#39;, &#39;AAS&#39;, &#39;ARR&#39;, &#39;ARS&#39;, 
                    &#39;ASS&#39;, &#39;RRR&#39;, &#39;RRS&#39;, &#39;RSS&#39;, &#39;SSS&#39;]
        thirds = {XYZ: [[[element(XYZ, J, K, L) for L in range(p)]
                         for K in range(p)] for J in range(p)]
                  for XYZ in triplets}

        self._states_dict = {**expect, **cov, **thirds}

    def _label_max(self, X, J):
        &#34;&#34;&#34;Label for the maximum of `X` for the `J`th population.&#34;&#34;&#34;
        pop = self.config.network.populations[J]
        return f&#39;$\\mathrm{{max}}\\, {{{X}}}_{{{pop.ID}}}$&#39;

    def _label_min(self, X, J):
        &#34;&#34;&#34;Label for the minimum of `X` for the `J`th population.&#34;&#34;&#34;
        pop = self.config.network.populations[J]
        return f&#39;$\\mathrm{{min}}\\, {{{X}}}_{{{pop.ID}}}$&#39;

    def _label_one(self, X, J):
        &#34;&#34;&#34;Label for the expectation of `X` for the `J`th population.&#34;&#34;&#34;
        return f&#39;$\\mathcal{{{X}}}_{{{self.config.network.populations[J].ID}}}$&#39;

    def _label_two(self, XY, J, K):
        &#34;&#34;&#34;Label for the covariance between `X` and `Y` for the `J`th and `K`th
        populations.&#34;&#34;&#34;
        IDs = &#39;&#39;.join([self.config.network.populations[P].ID for P in (J, K)])
        return f&#39;$\\mathrm{{C}}_{{{XY}}}^{{{IDs}}}$&#39;

    def _label_three(self, XYZ, J, K, L):
        &#34;&#34;&#34;Label for the third central moment for variables `X`, `Y` and `Z` for
        the `J`th, `K`th and `L`th populations.&#34;&#34;&#34;
        IDs = &#39;&#39;.join([self.config.network.populations[P].ID for P in (J, K, L)])
        return f&#39;$\\mathrm{{M}}_{{{XYZ}}}^{{{IDs}}}$&#39;

    def _make_fill(self, X, J):
        &#34;&#34;&#34;Define the method to add a fill around the fraction variable `X` for
        the `J`th population.&#34;&#34;&#34;
        def f(bound=&#39;std&#39;, alpha=.25, **kwargs):
            self._check_if_activated()
            if bound == &#39;std&#39;:
                CXX = f&#39;C{X}{X}&#39;
                low = (self._states_dict[X][J] 
                        - np.sqrt(self._states_dict[CXX][J][J]))
                high = (self._states_dict[X][J] 
                        + np.sqrt(self._states_dict[CXX][J][J]))
            elif bound == &#39;extrema&#39;:
                low = self._min_dict[X][J]
                high = self._max_dict[X][J]
            fill = self.ax.fill_between(self.times, low, high, alpha=alpha,
                                        color=self.colors[X][J], **kwargs)
            return fill
        return f


class _StatisticsOne(_ResultOne, Statistics):
    &#34;&#34;&#34;Special case of `Statistics` for a single population.

    Special case of `Statistics` to use when the network has a single
    population. There are essentially two changes from the base classes:
    the `fill` dictionary values are overridden to be methods rather than lists
    of methods, and components&#39; labels are implemented.

    &#34;&#34;&#34;
        
    def _fill_all(self, bound, alpha, **kwargs):
        &#34;&#34;&#34;Add fills for all *A*, *R* and *S*.&#34;&#34;&#34;
        for X in [&#39;A&#39;, &#39;R&#39;, &#39;S&#39;]:
            self.fill[X](bound=bound, alpha=alpha, **kwargs)

    def _fill_dict(self):
        &#34;&#34;&#34;Return a dictionary of methods to add a fill.&#34;&#34;&#34;
        return {X: self._make_fill(X, 0) for X in [&#39;A&#39;, &#39;R&#39;, &#39;S&#39;]}

    def _label_max(self, X, J):
        &#34;&#34;&#34;Label for the maximum of `X`.&#34;&#34;&#34;
        return f&#39;$\\mathrm{{max}}\\, {{{X}}}$&#39;

    def _label_min(self, X, J):
        &#34;&#34;&#34;Label for the minimum of `X`.&#34;&#34;&#34;
        return f&#39;$\\mathrm{{min}}\\, {{{X}}}$&#39;

    def _label_one(self, X, J):
        &#34;&#34;&#34;Label for the expectation of `X`.&#34;&#34;&#34;
        return f&#39;$\\mathcal{{{X}}}$&#39;

    def _label_two(self, XY, J, K):
        &#34;&#34;&#34;Label for the covariance between `X` and `Y`.&#34;&#34;&#34;
        return f&#39;$\\mathrm{{C}}_{{{XY}}}$&#39;

    def _label_three(self, XYZ, J, K, L):
        &#34;&#34;&#34;Label for the third central moment between `X`, `Y` and `Z`.&#34;&#34;&#34;
        return f&#39;$\\mathrm{{M}}_{{{XYZ}}}$&#39;


class Spectrum(Result):
    &#34;&#34;&#34;Represent spectra of other results.

    `Spectrum` extends `Result` for the case where the result is the spectrum
    of another result. Specifically, it defines methods to plot the spectra of
    state components, and it extends the options to setup a figure. Its data
    attributes are the same as in the base class, but here `times` is replaced
    with `freqs`; see `Spectrum.freqs`. Finally, `Spectrum` forgets
    `Result`&#39;s `load` and `get_spectrum` methods.

    The recommended way of instantiating a `Spectrum` instance is from another
    `Result` instance, with `Result.get_spectrum`. Parameters at initialization
    are a bit different here than in the base class, so they are listed again.

    Parameters
    ----------
    config : popnet.structures.Configuration
        Configuration used to obtain the result.
    states : dict of array_like
        Dictionary in which to each state component is associated with an array.
        Such an array should give the values, for each combination of
        populations, of the state component with respect to time. This is the
        format in which data is kept internally in `Result` classes.
    times : array_like
        An array representing time.
    source : str
        Name of the class from which comes the spectrum.
    name : str, optional
        A name associated with the result. Defaults to `None`, in which case it
        is replaced with `Spectrum.default_name`.

    &#34;&#34;&#34;

    default_name = &#39;Spectrum&#39;
    &#34;&#34;&#34;Default name given to instances.&#34;&#34;&#34;
    x_units = &#39;Frequency&#39;
    &#34;&#34;&#34;Units of the horizontal axis.&#34;&#34;&#34;
    _lim_valid_values = {&#39;x&#39;: (&#39;freqs&#39;, &#39;config&#39;, &#39;unbounded&#39;), 
                         &#39;y&#39;: (&#39;unbounded&#39;,)}
    _sources_inst = (&#39;Trajectory&#39;,)
    _sources_average = (&#39;Solution&#39;, &#39;Solution (extended)&#39;, &#39;Statistics&#39;)
    _sources_order_2 = (&#39;Solution (extended)&#39;, &#39;Statistics&#39;)
    _sources_order_3 = (&#39;Statistics&#39;,)

    def __init__(self, config, states, times, source, name=None):
        if source not in (&#39;Result&#39;, &#39;Solution&#39;, &#39;Solution (extended)&#39;,
                          &#39;Trajectory&#39;, &#39;Statistics&#39;):
            raise ValueError(f&#39;Unknown source \&#39;{source}\&#39;.&#39;)
        self._source = source
        super().__init__(config, states, times, name)

    def __new__(cls, config, states, times, source, name=None):
        return super().__new__(cls, config, states, times, name=name)

    @classmethod
    def load(cls):
        raise AttributeError(&#39;\&#39;Spectrum\&#39; object has no attribute \&#39;load\&#39;&#39;)

    @property
    def freqs(self):
        &#34;&#34;&#34;Frequencies.

        Frequencies for which the Fourier transforms gives the amplitudes.
        Replaces `Result.times`.
        &#34;&#34;&#34;
        return self.times

    @freqs.setter
    def freqs(self, new_value):
        self.times = new_value

    def get_spectrum(self):
        raise AttributeError(&#39;\&#39;Spectrum\&#39; object has no attribute &#39;
                             &#39;\&#39;get_spectrum\&#39;&#39;)

    def plot_fractions(self, **kwargs):
        &#34;&#34;&#34;Plot spectra for all fractions of populations.

        Plot spectra of all active, refractory and sensitive fractions of
        populations on the figure `Spectrum.fig`.

        Parameters
        ----------
        **kwargs
            Keyword arguments to be passed to the method that plots components,
            which is the [`plot`](https://31c8.short.gy/ax-plot) method of
            `Spectrum.ax`.

        Raises
        ------
        popnet.exceptions.PopNetError
            If no figure and axes are bound to `Spectrum.fig` and `Spectrum.ax`.
        &#34;&#34;&#34;
        self._plot_all_one(**kwargs)

    def plot_variances(self, **kwargs):
        &#34;&#34;&#34;Plot spectra of all variances.

        Plot spectra of all variances of active, refractory and sensitive
        fractions of populations on the figure `Spectrum.fig`, if such
        variances are defined.

        Parameters
        ----------
        **kwargs
            Keyword arguments to be passed to the method that plots components,
            which is the [`plot`](https://31c8.short.gy/ax-plot) method of
            `Spectrum.ax`.

        Raises
        ------
        popnet.exceptions.PopNetError
            If no figure and axes are bound to `Spectrum.fig` and `Spectrum.ax`,
            or if no variances are defined for this result.
        &#34;&#34;&#34;
        if self._source in self._sources_order_2:
            self._plot_all_two(symmetric=True, nonsymmetric=False, **kwargs)
            return
        raise PopNetError(&#39;No variances defined for this result.&#39;)

    def plot_covariances(self, **kwargs):
        &#34;&#34;&#34;Plot spectra of all non-symmetric covariances.

        Plot spectra of all non-symmetric covariances of active, refractory and
        sensitive fractions of populations on the figure `Spectrum.fig`, if
        such covariances are defined.

        Parameters
        ----------
        **kwargs
            Keyword arguments to be passed to the method that plots components,
            which is the [`plot`](https://31c8.short.gy/ax-plot) method of
            `Spectrum.ax`.

        Raises
        ------
        popnet.exceptions.PopNetError
            If no figure and axes are bound to `Spectrum.fig` and `Spectrum.ax`,
            or if no covariances are defined for this result.
        &#34;&#34;&#34;
        if self._source in self._sources_order_2:
            self._plot_all_two(symmetric=False, nonsymmetric=True, **kwargs)
            return
        raise PopNetError(&#39;No covariances defined for this result.&#39;)

    def plot_third_moments(self, **kwargs):
        &#34;&#34;&#34;Plot spectra of all third central moments.

        Plot spectra of all third central moments of active, refractory and
        sensitive fractions of populations on the figure `Spectrum.fig`, if
        such moments are defined.

        Parameters
        ----------
        **kwargs
            Keyword arguments to be passed to the method that plots components,
            which is the [`plot`](https://31c8.short.gy/ax-plot) method of
            `Spectrum.ax`.

        Raises
        ------
        popnet.exceptions.PopNetError
            If no figure and axes are bound to `Spectrum.fig` and `Spectrum.ax`,
            or if no third central moments are defined for this result.
        &#34;&#34;&#34;
        if self._source in self._sources_order_3:
            self._plot_all_three(**kwargs)
            return
        raise PopNetError(&#39;No third central moments defined for this result.&#39;)

    def setup(self, set_xlabel=True, units=&#39;kHz&#39;, fontsize=10, xlim=&#39;freqs&#39;,
              yscale=&#39;linear&#39;):
        &#34;&#34;&#34;Setup a figure.

        Setup the figure `Spectrum.fig`. Extends the base class method by
        allowing to set the scale of the vertical axis. Also overrides the
        accepted values for `xlim`, and removes the option to bound the
        vertical axis.

        Parameters
        ----------
        set_xlabel : bool, optional
            Decides if the horizontal axis is labelled. Defaults to `True`.
        units : str, optional
            Frequency units for the horizontal axis, which should be the units
            in which the transition rates are given in the configuration. These
            units are indicated in square brackets on the figure, except if it
            is set to the empty string `&#39;&#39;`, in which case no extra square
            brackets are added. Defaults to `&#39;kHz&#39;`.
        fontsize : float, optional
            Font size in points for the horizontal axis&#39; label. Defaults to 10.
        xlim : {&#39;freqs&#39;, &#39;config&#39;, &#39;unbounded&#39;}, optional
            Decides how the horizontal axis is bounded. If `&#39;freqs&#39;`, it is
            bounded between 0 and the highest frequency. If `&#39;config&#39;`, it is
            bounded between 0 and the highest frequency obtained from the times
            array given by the configuration. If `&#39;unbounded&#39;`, it is not
            bounded. Defaults to `&#39;freqs&#39;`.
        yscale : {&#39;linear&#39;, &#39;log&#39;}, optional
            Defines the scale of the vertical axis. Defaults to `&#39;linear&#39;`.

        Raises
        ------
        popnet.exceptions.PopNetError
            If no figure and axes are bound to `Result.fig` and `Result.ax`.
        ValueError
            If `xlim` is given a non-valid value.
        &#34;&#34;&#34;
        super().setup(set_xlabel=set_xlabel, units=units, fontsize=fontsize,
                      xlim=xlim, ylim=&#39;unbounded&#39;)
        try:
            self.ax.set_yscale(yscale)
        except AttributeError as error:
            raise TypeError(f&#39;\&#39;yscale\&#39; must be a string.&#39;) from error

    def _default_plots(self, expectations=True, variances=True, 
                       covariances=False, third_moments=False):
        &#34;&#34;&#34;Add plots on the default figure.&#34;&#34;&#34;
        sym = self._source in self._sources_order_2 and variances
        nonsym = self._source in self._sources_order_2 and covariances
        three = self._source in self._sources_order_3 and third_moments
        super()._default_plots(one=expectations, symmetric=sym, 
                               nonsymmetric=nonsym, three=three)

    def _init_abscissa(self, times):
        &#34;&#34;&#34;Initialize array related to the independant variable.&#34;&#34;&#34;
        size = round(len(times)/2+.8)
        # If n is the length of the times array, the size of freqs has to be
        # n/2 + 1 if n is even, and (n+1)/2 if n is odd.
        self._times = np.linspace(0, len(times) / times[-1], size)

    def _init_colors(self):
        &#34;&#34;&#34;Initialize the colors associated with state variables.&#34;&#34;&#34;
        super()._init_colors()
        if self._source in self._sources_order_2:
            self._add_colors_items_two()
        if self._source in self._sources_order_3:
            self._add_colors_items_three()

    def _init_plot_methods(self):
        &#34;&#34;&#34;Initialize plotting methods of state variables.&#34;&#34;&#34;
        super()._init_plot_methods()
        if self._source in self._sources_order_2:
            self._plot = {**self._plot, **self._plot_dict_two()}
        if self._source in self._sources_order_3:
            self._plot = {**self._plot, **self._plot_dict_three()}

    def _init_states_dict(self, states):
        &#34;&#34;&#34;Initialize the state variables dictionary.&#34;&#34;&#34;
        p = len(self.config.network.populations)
        self._states_dict = dict.fromkeys(states)
        axes = {&#39;A&#39;: 1, &#39;R&#39;: 1, &#39;S&#39;: 1, &#39;CAA&#39;: 2, &#39;CRR&#39;: 2, &#39;CSS&#39;: 2, &#39;CAR&#39;: 2,
                &#39;CAS&#39;: 2, &#39;CRS&#39;: 2, &#39;AAA&#39;: 3, &#39;AAR&#39;: 3, &#39;AAS&#39;: 3, &#39;ARR&#39;: 3,
                &#39;ARS&#39;: 3, &#39;ASS&#39;: 3, &#39;RRR&#39;: 3, &#39;RRS&#39;: 3, &#39;RSS&#39;: 3, &#39;SSS&#39;: 3}
        for key in states:
            if key in axes:
                transform = np.fft.rfft(states[key], axis=axes[key])
                self._states_dict[key] = np.abs(transform)
            else:
                raise ValueError(f&#39;{key} is not a valid state variable.&#39;)

    def _label_one(self, X, J):
        &#34;&#34;&#34;Label for the spectrum of `X` for the `J`th population.&#34;&#34;&#34;
        J_ID = self.config.network.populations[J].ID
        if self._source in self._sources_average:
            return f&#39;$\\hat{{\\mathcal{{{X}}}}}_{{{J_ID}}}$&#39;
        elif self._source in self._sources_inst:
            return f&#39;$\\hat{{{X}}}_{{{J_ID}}}$&#39;

    def _label_two(self, XY, J, K):
        &#34;&#34;&#34;Label for the spectrum of the covariance between `X` and `Y` for the
        `J`th and `K`th populations.&#34;&#34;&#34;
        IDs = &#39;&#39;.join([self.config.network.populations[P].ID for P in (J, K)])
        return f&#39;$\\hat{{\\mathrm{{C}}}}_{{{XY}}}^{{{IDs}}}$&#39;

    def _label_three(self, XYZ, J, K, L):
        &#34;&#34;&#34;Label for the spectrum of the third central between `X`, `Y` and `Z`
        for the `J`th, `K`th and `L`th populations.&#34;&#34;&#34;
        IDs = &#39;&#39;.join([self.config.network.populations[P].ID for P in (J, K, L)])
        return f&#39;$\\hat{{\\mathrm{{M}}}}_{{{XYZ}}}^{{{IDs}}}$&#39;

    def _set_xlim(self, xlim):
        &#34;&#34;&#34;Set the limits of the horizontal axis of a figure.&#34;&#34;&#34;
        super()._set_xlim(xlim)
        if xlim == &#39;freqs&#39;:
            self.ax.set_xlim([0, self.freqs[-1]])
        elif xlim == &#39;config&#39;:
            upper = (1+self.config.iterations) / self.config.final_time
            self.ax.set_xlim([0, upper])


class _SpectrumOne(Spectrum, _ResultOne):
    &#34;&#34;&#34;Special case of `Spectrum` for a single population.

    Special case of `Spectrum` to use when the network has a single population.
    The only change from the base classes is the implementation of the
    components&#39; labels.

    &#34;&#34;&#34;

    def _label_one(self, X, J):
        &#34;&#34;&#34;Label for the spectrum of `X`.&#34;&#34;&#34;
        if self._source in self._sources_average:
            return f&#39;$\\hat{{\\mathcal{{{X}}}}}$&#39;
        elif self._source in self._sources_inst:
            return f&#39;$\\hat{{{X}}}$&#39;

    def _label_two(self, XY, J, K):
        &#34;&#34;&#34;Label for the covariance between `X` and `Y` for the `J`th and `K`th
        populations.&#34;&#34;&#34;
        return f&#39;$\\hat{{\\mathrm{{C}}}}_{{{XY}}}$&#39;

    def _label_three(self, XYZ, J, K, L):
        &#34;&#34;&#34;Label for the third central moment between `X`, `Y` and `Z`.&#34;&#34;&#34;
        return f&#39;$\\hat{{\\mathrm{{M}}}}_{{{XYZ}}}$&#39;


def draw(name=&#39;Figure&#39;, show=True, savefig=False, folder=None, format=None,
         **kwargs):
    &#34;&#34;&#34;Draw a figure.

    Draw a figure previously activated and set up. If the figure is saved, it
    is named `name` and has the file format chosen with `format`.

    Parameters
    ----------
    name : str, optional
        Name to give the figure if saved. Defaults to `&#39;Figure&#39;`.
    show : bool, optional
        Decides if the figure is shown or not. Defaults to `True`.
    savefig : bool, optional
        Decides if the figure is saved or not. Defaults to `False`.
    folder : str, optional
        A folder in which the figure can be saved. If it does not exist in
        the current directory and the figure is saved, it is created. Defaults
        to `None`, in which case the figure is saved in the current directory.
    format : str, optional
        The file format under which the figure is saved if `savefig` is `True`.
        It must be a format handled by Matplotlib, which includes &#39;png&#39;, &#39;jpg&#39;,
        &#39;pdf&#39; and &#39;svg&#39;. Defaults to `None`, in which case the file format is
        Matplotlib&#39;s `savefig.format` parameter, which defaults to &#39;png&#39;.
    **kwargs
        Keyword arguments passed to [`matplotlib.pyplot.savefig`](
        https://31c8.short.gy/plt-savefig) when `savefig` is `True`.
    &#34;&#34;&#34;
    if savefig:
        _internals._make_sure_folder_exists(folder)
        filename = _internals._format_filename(folder, None, name, format)
        plt.savefig(filename, format=format, **kwargs)
    if show:
        plt.show()
    plt.close()


def figure(subplots=None, figsize=(5,3.75), dpi=150, tight_layout=True,
           font_family=&#39;serif&#39;, usetex=False, preamble=None, **kwargs):
    &#34;&#34;&#34;Initialize a figure.

    Create a Matplotlib figure with default formatting. The default color
    cycle is changed with default colors used in `Graphics` classes. The font
    is also changed to Times or Helvetica according to the font family.

    Parameters
    ----------
    subplots : list or tuple, optional
        If given, one subplot is defined on the figure for each element of
        `subplots`. Each subplot must be specified with an argument understood
        by the [`add_subplot`](https://31c8.short.gy/mpl-add-subplot)
        method of a
        [`matplotlib.figure.Figure`](https://31c8.short.gy/mpl-figure-Figure).
        Defaults to `None`, in which case a single plot is defined.
    figsize : tuple of float, optional
        Width and height of the figure in inches. Defaults to (5, 3.75).
    dpi : int
        Resolution of the figure in dots per inches. Defaults to 150.
    tight_layout : bool, optional
        Adjust automatically the padding between and aroung subplots using
        [`matplotlib.figure.Figure.tight_layout`](
        https://31c8.short.gy/mpl-tight-layout). Defaults to `True`.
    font_family : {&#39;serif&#39;, &#39;sans-serif&#39;}, optional
        Determines if a serif or a sans serif font is used. Defaults to
        `&#39;serif&#39;`.
    usetex : bool, optional
        Determines if LaTeX is used to draw the figure. Defaults to `False`.
    preamble : str, optional
        LaTeX preamble when `usetex` is `True`, in which case it can be used
        to load font packages. It has no effect when `usetex` is `False`.
        Defaults to `None`, in which case a default preamble is added.
    **kwargs
        Keyword arguments to be passed to
        [`matplotlib.pyplot.figure`](https://31c8.short.gy/plt-figure) when
        creating the figure.

    Returns
    -------
    fig : matplotlib.figure.Figure
        The initialized Matplotlib figure.
    ax : matplotlib.axes.Axes or list of matplotlib.axes.Axes
        The axes of `fig`, or a list of axes for every subplot of `fig` if
        multiple subplots have been defined on the figure.

    Warns
    -----
    PopNetWarning
        If an unknown font family is given.
    &#34;&#34;&#34;
    if font_family not in [&#39;serif&#39;, &#39;sans-serif&#39;]:
        warn(f&#39;Unknown font family {font_family}. Taking a default instead.&#39;,
             category=PopNetWarning, stacklevel=2)
        font_family = &#39;serif&#39;
    mpl.rcParams[&#39;font.family&#39;] = font_family
    mpl.rcParams[&#39;font.serif&#39;] = [&#39;Times New Roman&#39;]
    mpl.rcParams[&#39;font.sans-serif&#39;] = [&#39;Helvetica&#39;]
    if usetex:
        mpl.rcParams[&#39;text.usetex&#39;] = True
        if preamble is None:
            if font_family == &#39;serif&#39;:
                preamble = (&#39;\\usepackage{newtxtext}&#39;
                            &#39;\\usepackage{newtxmath}&#39;)
            elif font_family == &#39;sans-serif&#39;:
                preamble = (&#39;\\usepackage[cal=pxtx]{mathalpha}&#39;
                            &#39;\\usepackage{helvet}&#39;
                            &#39;\\usepackage{sansmath}&#39;
                            &#39;\\sansmath&#39;)
        mpl.rcParams[&#39;text.latex.preamble&#39;] = preamble
    else:
        math_font = {&#39;serif&#39;: &#39;stix&#39;, &#39;sans-serif&#39;: &#39;stixsans&#39;}
        mpl.rcParams[&#39;mathtext.fontset&#39;] = math_font[font_family]
    mpl.rcParams[&#39;axes.prop_cycle&#39;] = mpl.cycler(color=[
        &#39;midnightblue&#39;, (150/255,10/255,47/255), &#39;goldenrod&#39;, 
        &#39;seagreen&#39;, &#39;blueviolet&#39;])
    fig = plt.figure(figsize=figsize, dpi=dpi, **kwargs)
    if tight_layout:
        fig.set_tight_layout(True)
    if subplots is None:
        subplots = (111,)
    axes = []
    for subplot in subplots:
        if isinstance(subplot, tuple):
            ax = fig.add_subplot(*subplot)
        else:
            ax = fig.add_subplot(subplot)
        ax.tick_params(direction=&#39;in&#39;, top=True, right=True)
        axes.append(ax)
    if len(axes) == 1:
        return fig, axes[0]
    return fig, axes


def load_extended_solution(ID, name=None, config=None, times=None, folder=None):
    &#34;&#34;&#34;Load a solution from a text file.

    Load a solution of an extended dynamical system from a text file. This is
    an alias for the method `ExtendedSolution.load` inherited by
    `ExtendedSolution`.
    &#34;&#34;&#34;
    return ExtendedSolution.load(ID, name=name, config=config, times=times,
                                 folder=folder)


def load_solution(ID, name=None, config=None, times=None, folder=None):
    &#34;&#34;&#34;Load a solution from a text file.

    Load a solution of a (non extended) dynamical system from a text file.
    This is an alias for the method `Solution.load` inherited by `Solution`.
    &#34;&#34;&#34;
    return Solution.load(ID, name=name, config=config, times=times,
                         folder=folder)


def load_statistics(ID, sample_name=None, name=None, config=None, folder=None):
    &#34;&#34;&#34;Alias for `Statistics.load`.&#34;&#34;&#34;
    return Statistics.load(ID, sample_name=sample_name, name=name,
                           config=config, folder=folder)


def load_trajectory(ID, name=None, config=None, folder=None):
    &#34;&#34;&#34;Alias for `Trajectory.load`.&#34;&#34;&#34;
    return Trajectory.load(ID, name=name, config=config, folder=folder)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="popnet.graphics.draw"><code class="name flex">
<span>def <span class="ident">draw</span></span>(<span>name='Figure', show=True, savefig=False, folder=None, format=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Draw a figure.</p>
<p>Draw a figure previously activated and set up. If the figure is saved, it
is named <code>name</code> and has the file format chosen with <code>format</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name to give the figure if saved. Defaults to <code>'Figure'</code>.</dd>
<dt><strong><code>show</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Decides if the figure is shown or not. Defaults to <code>True</code>.</dd>
<dt><strong><code>savefig</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Decides if the figure is saved or not. Defaults to <code>False</code>.</dd>
<dt><strong><code>folder</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>A folder in which the figure can be saved. If it does not exist in
the current directory and the figure is saved, it is created. Defaults
to <code>None</code>, in which case the figure is saved in the current directory.</dd>
<dt><strong><code>format</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The file format under which the figure is saved if <code>savefig</code> is <code>True</code>.
It must be a format handled by Matplotlib, which includes 'png', 'jpg',
'pdf' and 'svg'. Defaults to <code>None</code>, in which case the file format is
Matplotlib's <code>savefig.format</code> parameter, which defaults to 'png'.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to <a href="https://31c8.short.gy/plt-savefig"><code>matplotlib.pyplot.savefig</code></a> when <code>savefig</code> is <code>True</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw(name=&#39;Figure&#39;, show=True, savefig=False, folder=None, format=None,
         **kwargs):
    &#34;&#34;&#34;Draw a figure.

    Draw a figure previously activated and set up. If the figure is saved, it
    is named `name` and has the file format chosen with `format`.

    Parameters
    ----------
    name : str, optional
        Name to give the figure if saved. Defaults to `&#39;Figure&#39;`.
    show : bool, optional
        Decides if the figure is shown or not. Defaults to `True`.
    savefig : bool, optional
        Decides if the figure is saved or not. Defaults to `False`.
    folder : str, optional
        A folder in which the figure can be saved. If it does not exist in
        the current directory and the figure is saved, it is created. Defaults
        to `None`, in which case the figure is saved in the current directory.
    format : str, optional
        The file format under which the figure is saved if `savefig` is `True`.
        It must be a format handled by Matplotlib, which includes &#39;png&#39;, &#39;jpg&#39;,
        &#39;pdf&#39; and &#39;svg&#39;. Defaults to `None`, in which case the file format is
        Matplotlib&#39;s `savefig.format` parameter, which defaults to &#39;png&#39;.
    **kwargs
        Keyword arguments passed to [`matplotlib.pyplot.savefig`](
        https://31c8.short.gy/plt-savefig) when `savefig` is `True`.
    &#34;&#34;&#34;
    if savefig:
        _internals._make_sure_folder_exists(folder)
        filename = _internals._format_filename(folder, None, name, format)
        plt.savefig(filename, format=format, **kwargs)
    if show:
        plt.show()
    plt.close()</code></pre>
</details>
</dd>
<dt id="popnet.graphics.figure"><code class="name flex">
<span>def <span class="ident">figure</span></span>(<span>subplots=None, figsize=(5, 3.75), dpi=150, tight_layout=True, font_family='serif', usetex=False, preamble=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize a figure.</p>
<p>Create a Matplotlib figure with default formatting. The default color
cycle is changed with default colors used in <code><a title="popnet.graphics.Graphics" href="#popnet.graphics.Graphics">Graphics</a></code> classes. The font
is also changed to Times or Helvetica according to the font family.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>subplots</code></strong> :&ensp;<code>list</code> or <code>tuple</code>, optional</dt>
<dd>If given, one subplot is defined on the figure for each element of
<code>subplots</code>. Each subplot must be specified with an argument understood
by the <a href="https://31c8.short.gy/mpl-add-subplot"><code>add_subplot</code></a>
method of a
<a href="https://31c8.short.gy/mpl-figure-Figure"><code>matplotlib.figure.Figure</code></a>.
Defaults to <code>None</code>, in which case a single plot is defined.</dd>
<dt><strong><code>figsize</code></strong> :&ensp;<code>tuple</code> of <code>float</code>, optional</dt>
<dd>Width and height of the figure in inches. Defaults to (5, 3.75).</dd>
<dt><strong><code>dpi</code></strong> :&ensp;<code>int</code></dt>
<dd>Resolution of the figure in dots per inches. Defaults to 150.</dd>
<dt><strong><code>tight_layout</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Adjust automatically the padding between and aroung subplots using
<a href="https://31c8.short.gy/mpl-tight-layout"><code>matplotlib.figure.Figure.tight_layout</code></a>. Defaults to <code>True</code>.</dd>
<dt><strong><code>font_family</code></strong> :&ensp;<code>{'serif', 'sans-serif'}</code>, optional</dt>
<dd>Determines if a serif or a sans serif font is used. Defaults to
<code>'serif'</code>.</dd>
<dt><strong><code>usetex</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Determines if LaTeX is used to draw the figure. Defaults to <code>False</code>.</dd>
<dt><strong><code>preamble</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>LaTeX preamble when <code>usetex</code> is <code>True</code>, in which case it can be used
to load font packages. It has no effect when <code>usetex</code> is <code>False</code>.
Defaults to <code>None</code>, in which case a default preamble is added.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments to be passed to
<a href="https://31c8.short.gy/plt-figure"><code>matplotlib.pyplot.figure</code></a> when
creating the figure.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>matplotlib.figure.Figure</code></dt>
<dd>The initialized Matplotlib figure.</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib.axes.Axes</code> or <code>list</code> of <code>matplotlib.axes.Axes</code></dt>
<dd>The axes of <code>fig</code>, or a list of axes for every subplot of <code>fig</code> if
multiple subplots have been defined on the figure.</dd>
</dl>
<h2 id="warns">Warns</h2>
<dl>
<dt><code>PopNetWarning</code></dt>
<dd>If an unknown font family is given.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def figure(subplots=None, figsize=(5,3.75), dpi=150, tight_layout=True,
           font_family=&#39;serif&#39;, usetex=False, preamble=None, **kwargs):
    &#34;&#34;&#34;Initialize a figure.

    Create a Matplotlib figure with default formatting. The default color
    cycle is changed with default colors used in `Graphics` classes. The font
    is also changed to Times or Helvetica according to the font family.

    Parameters
    ----------
    subplots : list or tuple, optional
        If given, one subplot is defined on the figure for each element of
        `subplots`. Each subplot must be specified with an argument understood
        by the [`add_subplot`](https://31c8.short.gy/mpl-add-subplot)
        method of a
        [`matplotlib.figure.Figure`](https://31c8.short.gy/mpl-figure-Figure).
        Defaults to `None`, in which case a single plot is defined.
    figsize : tuple of float, optional
        Width and height of the figure in inches. Defaults to (5, 3.75).
    dpi : int
        Resolution of the figure in dots per inches. Defaults to 150.
    tight_layout : bool, optional
        Adjust automatically the padding between and aroung subplots using
        [`matplotlib.figure.Figure.tight_layout`](
        https://31c8.short.gy/mpl-tight-layout). Defaults to `True`.
    font_family : {&#39;serif&#39;, &#39;sans-serif&#39;}, optional
        Determines if a serif or a sans serif font is used. Defaults to
        `&#39;serif&#39;`.
    usetex : bool, optional
        Determines if LaTeX is used to draw the figure. Defaults to `False`.
    preamble : str, optional
        LaTeX preamble when `usetex` is `True`, in which case it can be used
        to load font packages. It has no effect when `usetex` is `False`.
        Defaults to `None`, in which case a default preamble is added.
    **kwargs
        Keyword arguments to be passed to
        [`matplotlib.pyplot.figure`](https://31c8.short.gy/plt-figure) when
        creating the figure.

    Returns
    -------
    fig : matplotlib.figure.Figure
        The initialized Matplotlib figure.
    ax : matplotlib.axes.Axes or list of matplotlib.axes.Axes
        The axes of `fig`, or a list of axes for every subplot of `fig` if
        multiple subplots have been defined on the figure.

    Warns
    -----
    PopNetWarning
        If an unknown font family is given.
    &#34;&#34;&#34;
    if font_family not in [&#39;serif&#39;, &#39;sans-serif&#39;]:
        warn(f&#39;Unknown font family {font_family}. Taking a default instead.&#39;,
             category=PopNetWarning, stacklevel=2)
        font_family = &#39;serif&#39;
    mpl.rcParams[&#39;font.family&#39;] = font_family
    mpl.rcParams[&#39;font.serif&#39;] = [&#39;Times New Roman&#39;]
    mpl.rcParams[&#39;font.sans-serif&#39;] = [&#39;Helvetica&#39;]
    if usetex:
        mpl.rcParams[&#39;text.usetex&#39;] = True
        if preamble is None:
            if font_family == &#39;serif&#39;:
                preamble = (&#39;\\usepackage{newtxtext}&#39;
                            &#39;\\usepackage{newtxmath}&#39;)
            elif font_family == &#39;sans-serif&#39;:
                preamble = (&#39;\\usepackage[cal=pxtx]{mathalpha}&#39;
                            &#39;\\usepackage{helvet}&#39;
                            &#39;\\usepackage{sansmath}&#39;
                            &#39;\\sansmath&#39;)
        mpl.rcParams[&#39;text.latex.preamble&#39;] = preamble
    else:
        math_font = {&#39;serif&#39;: &#39;stix&#39;, &#39;sans-serif&#39;: &#39;stixsans&#39;}
        mpl.rcParams[&#39;mathtext.fontset&#39;] = math_font[font_family]
    mpl.rcParams[&#39;axes.prop_cycle&#39;] = mpl.cycler(color=[
        &#39;midnightblue&#39;, (150/255,10/255,47/255), &#39;goldenrod&#39;, 
        &#39;seagreen&#39;, &#39;blueviolet&#39;])
    fig = plt.figure(figsize=figsize, dpi=dpi, **kwargs)
    if tight_layout:
        fig.set_tight_layout(True)
    if subplots is None:
        subplots = (111,)
    axes = []
    for subplot in subplots:
        if isinstance(subplot, tuple):
            ax = fig.add_subplot(*subplot)
        else:
            ax = fig.add_subplot(subplot)
        ax.tick_params(direction=&#39;in&#39;, top=True, right=True)
        axes.append(ax)
    if len(axes) == 1:
        return fig, axes[0]
    return fig, axes</code></pre>
</details>
</dd>
<dt id="popnet.graphics.load_extended_solution"><code class="name flex">
<span>def <span class="ident">load_extended_solution</span></span>(<span>ID, name=None, config=None, times=None, folder=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Load a solution from a text file.</p>
<p>Load a solution of an extended dynamical system from a text file. This is
an alias for the method <code><a title="popnet.graphics.ExtendedSolution.load" href="#popnet.graphics.Result.load">Result.load()</a></code> inherited by
<code><a title="popnet.graphics.ExtendedSolution" href="#popnet.graphics.ExtendedSolution">ExtendedSolution</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_extended_solution(ID, name=None, config=None, times=None, folder=None):
    &#34;&#34;&#34;Load a solution from a text file.

    Load a solution of an extended dynamical system from a text file. This is
    an alias for the method `ExtendedSolution.load` inherited by
    `ExtendedSolution`.
    &#34;&#34;&#34;
    return ExtendedSolution.load(ID, name=name, config=config, times=times,
                                 folder=folder)</code></pre>
</details>
</dd>
<dt id="popnet.graphics.load_solution"><code class="name flex">
<span>def <span class="ident">load_solution</span></span>(<span>ID, name=None, config=None, times=None, folder=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Load a solution from a text file.</p>
<p>Load a solution of a (non extended) dynamical system from a text file.
This is an alias for the method <code><a title="popnet.graphics.Solution.load" href="#popnet.graphics.Result.load">Result.load()</a></code> inherited by <code><a title="popnet.graphics.Solution" href="#popnet.graphics.Solution">Solution</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_solution(ID, name=None, config=None, times=None, folder=None):
    &#34;&#34;&#34;Load a solution from a text file.

    Load a solution of a (non extended) dynamical system from a text file.
    This is an alias for the method `Solution.load` inherited by `Solution`.
    &#34;&#34;&#34;
    return Solution.load(ID, name=name, config=config, times=times,
                         folder=folder)</code></pre>
</details>
</dd>
<dt id="popnet.graphics.load_statistics"><code class="name flex">
<span>def <span class="ident">load_statistics</span></span>(<span>ID, sample_name=None, name=None, config=None, folder=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for <code><a title="popnet.graphics.Statistics.load" href="#popnet.graphics.Statistics.load">Statistics.load()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_statistics(ID, sample_name=None, name=None, config=None, folder=None):
    &#34;&#34;&#34;Alias for `Statistics.load`.&#34;&#34;&#34;
    return Statistics.load(ID, sample_name=sample_name, name=name,
                           config=config, folder=folder)</code></pre>
</details>
</dd>
<dt id="popnet.graphics.load_trajectory"><code class="name flex">
<span>def <span class="ident">load_trajectory</span></span>(<span>ID, name=None, config=None, folder=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for <code><a title="popnet.graphics.Trajectory.load" href="#popnet.graphics.Trajectory.load">Trajectory.load()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_trajectory(ID, name=None, config=None, folder=None):
    &#34;&#34;&#34;Alias for `Trajectory.load`.&#34;&#34;&#34;
    return Trajectory.load(ID, name=name, config=config, folder=folder)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="popnet.graphics.ExtendedSolution"><code class="flex name class">
<span>class <span class="ident">ExtendedSolution</span></span>
<span>(</span><span>config, states, times, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represent solutions of extended dynamical systems.</p>
<p><code><a title="popnet.graphics.ExtendedSolution" href="#popnet.graphics.ExtendedSolution">ExtendedSolution</a></code> extends <code><a title="popnet.graphics.Solution" href="#popnet.graphics.Solution">Solution</a></code> for cases where covariances are
considered in the dynamical system that was integrated to obtain the
solution. It adds methods to the base class to plot variances or
non-symmetric covariances of fractions of populations all at once. Other
changes are implementation details.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ExtendedSolution(Solution):
    &#34;&#34;&#34;Represent solutions of extended dynamical systems.

    `ExtendedSolution` extends `Solution` for cases where covariances are
    considered in the dynamical system that was integrated to obtain the
    solution. It adds methods to the base class to plot variances or
    non-symmetric covariances of fractions of populations all at once. Other
    changes are implementation details.

    &#34;&#34;&#34;

    default_name = &#39;Solution (extended)&#39;
    &#34;&#34;&#34;Default name given to instances.&#34;&#34;&#34;

    def plot_variances(self, **kwargs):
        &#34;&#34;&#34;Plot all variances of *A*&#39;s, *R*&#39;s and *S*&#39;s.

        Plot all variances of active, refractory and sensitive fractions of
        populations on the figure `ExtendedSolution.fig`.

        Parameters
        ----------
        **kwargs
            Keyword arguments to be passed to the method that plots components,
            which is the [`plot`](https://31c8.short.gy/ax-plot) method of
            `ExtendedSolution.ax`.

        Raises
        ------
        popnet.exceptions.PopNetError
            If no figure and axes are bound to `ExtendedSolution.fig` and
            `ExtendedSolution.ax`.
        &#34;&#34;&#34;
        self._plot_all_two(symmetric=True, nonsymmetric=False, **kwargs)

    def plot_covariances(self, **kwargs):
        &#34;&#34;&#34;Plot all non-symmetric covariances of *A*&#39;s, *R*&#39;s and *S*&#39;s.

        Plot all non-symmetric covariances of active, refractory and sensitive
        fractions of populations on the figure `ExtendedSolution.fig`.

        Parameters
        ----------
        **kwargs
            Keyword arguments to be passed to the method that plots components,
            which is the [`plot`](https://31c8.short.gy/ax-plot) method of
            `ExtendedSolution.ax`.

        Raises
        ------
        popnet.exceptions.PopNetError
            If no figure and axes are bound to `ExtendedSolution.fig` and
            `ExtendedSolution.ax`.
        &#34;&#34;&#34;
        self._plot_all_two(symmetric=False, nonsymmetric=True, **kwargs)

    def _default_plots(self, expectations=True, variances=True, 
                       covariances=False):
        &#34;&#34;&#34;Add plots on the default figure.&#34;&#34;&#34;
        super()._default_plots(one=expectations, symmetric=variances, 
                               nonsymmetric=covariances, three=False)

    def _init_colors(self):
        &#34;&#34;&#34;Initialize the colors associated with state variables.&#34;&#34;&#34;
        super()._init_colors()
        self._add_colors_items_two()

    def _init_plot_methods(self):
        &#34;&#34;&#34;Initialize plotting methods of state variables.&#34;&#34;&#34;
        super()._init_plot_methods()
        self._plot = {**self.plot, **self._plot_dict_two()}

    def _init_states_dict(self, states):
        &#34;&#34;&#34;Initialize the attributes associated with state variables.&#34;&#34;&#34;
        expects = self._get_fractions_dict(states)
        p = len(self.config.network.populations)
        transposed_states = np.transpose(states)
        CAA_flat = transposed_states[2*p : round(2*p + p*(p+1)/2)]
        CAA = _internals._unflat_vector_triangle(CAA_flat)
        CRR_flat = transposed_states[2*p + round(p*(p+1)/2) : 2*p + p*(p+1)]
        CRR = _internals._unflat_vector_triangle(CRR_flat)
        CAR_flat = transposed_states[2*p + p*(p+1) :]
        CAR = CAR_flat.reshape((p,p,len(CAR_flat[0])))
        CAS = - CAA - CAR
        CRS = - CRR - np.transpose(CAR, axes=(1,0,2))
        CSS = - CAS - CRS
        covs = {&#39;CAA&#39;: CAA, &#39;CRR&#39;: CRR, &#39;CSS&#39;: CSS,
                &#39;CAR&#39;: CAR, &#39;CAS&#39;: CAS, &#39;CRS&#39;: CRS}
        self._states_dict = {**expects, **covs}

    def _label_two(self, XY, J, K):
        &#34;&#34;&#34;Label for the covariance between `X` and `Y` for the `J`th and `K`th
        populations.&#34;&#34;&#34;
        IDs = &#39;&#39;.join([self.config.network.populations[P].ID for P in (J, K)])
        return f&#39;$\\mathrm{{C}}_{{{XY}}}^{{{IDs}}}$&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="popnet.graphics.Solution" href="#popnet.graphics.Solution">Solution</a></li>
<li><a title="popnet.graphics.Result" href="#popnet.graphics.Result">Result</a></li>
<li><a title="popnet.graphics.Graphics" href="#popnet.graphics.Graphics">Graphics</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>popnet.graphics._ExtendedSolutionOne</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="popnet.graphics.ExtendedSolution.plot_covariances"><code class="name flex">
<span>def <span class="ident">plot_covariances</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot all non-symmetric covariances of <em>A</em>'s, <em>R</em>'s and <em>S</em>'s.</p>
<p>Plot all non-symmetric covariances of active, refractory and sensitive
fractions of populations on the figure <code><a title="popnet.graphics.ExtendedSolution.fig" href="#popnet.graphics.Graphics.fig">ExtendedSolution.fig</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments to be passed to the method that plots components,
which is the <a href="https://31c8.short.gy/ax-plot"><code>plot</code></a> method of
<code><a title="popnet.graphics.ExtendedSolution.ax" href="#popnet.graphics.Graphics.ax">ExtendedSolution.ax</a></code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="popnet.exceptions.PopNetError" href="exceptions.html#popnet.exceptions.PopNetError">PopNetError</a></code></dt>
<dd>If no figure and axes are bound to <code><a title="popnet.graphics.ExtendedSolution.fig" href="#popnet.graphics.Graphics.fig">ExtendedSolution.fig</a></code> and
<code><a title="popnet.graphics.ExtendedSolution.ax" href="#popnet.graphics.Graphics.ax">ExtendedSolution.ax</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_covariances(self, **kwargs):
    &#34;&#34;&#34;Plot all non-symmetric covariances of *A*&#39;s, *R*&#39;s and *S*&#39;s.

    Plot all non-symmetric covariances of active, refractory and sensitive
    fractions of populations on the figure `ExtendedSolution.fig`.

    Parameters
    ----------
    **kwargs
        Keyword arguments to be passed to the method that plots components,
        which is the [`plot`](https://31c8.short.gy/ax-plot) method of
        `ExtendedSolution.ax`.

    Raises
    ------
    popnet.exceptions.PopNetError
        If no figure and axes are bound to `ExtendedSolution.fig` and
        `ExtendedSolution.ax`.
    &#34;&#34;&#34;
    self._plot_all_two(symmetric=False, nonsymmetric=True, **kwargs)</code></pre>
</details>
</dd>
<dt id="popnet.graphics.ExtendedSolution.plot_variances"><code class="name flex">
<span>def <span class="ident">plot_variances</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot all variances of <em>A</em>'s, <em>R</em>'s and <em>S</em>'s.</p>
<p>Plot all variances of active, refractory and sensitive fractions of
populations on the figure <code><a title="popnet.graphics.ExtendedSolution.fig" href="#popnet.graphics.Graphics.fig">ExtendedSolution.fig</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments to be passed to the method that plots components,
which is the <a href="https://31c8.short.gy/ax-plot"><code>plot</code></a> method of
<code><a title="popnet.graphics.ExtendedSolution.ax" href="#popnet.graphics.Graphics.ax">ExtendedSolution.ax</a></code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="popnet.exceptions.PopNetError" href="exceptions.html#popnet.exceptions.PopNetError">PopNetError</a></code></dt>
<dd>If no figure and axes are bound to <code><a title="popnet.graphics.ExtendedSolution.fig" href="#popnet.graphics.Graphics.fig">ExtendedSolution.fig</a></code> and
<code><a title="popnet.graphics.ExtendedSolution.ax" href="#popnet.graphics.Graphics.ax">ExtendedSolution.ax</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_variances(self, **kwargs):
    &#34;&#34;&#34;Plot all variances of *A*&#39;s, *R*&#39;s and *S*&#39;s.

    Plot all variances of active, refractory and sensitive fractions of
    populations on the figure `ExtendedSolution.fig`.

    Parameters
    ----------
    **kwargs
        Keyword arguments to be passed to the method that plots components,
        which is the [`plot`](https://31c8.short.gy/ax-plot) method of
        `ExtendedSolution.ax`.

    Raises
    ------
    popnet.exceptions.PopNetError
        If no figure and axes are bound to `ExtendedSolution.fig` and
        `ExtendedSolution.ax`.
    &#34;&#34;&#34;
    self._plot_all_two(symmetric=True, nonsymmetric=False, **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="popnet.graphics.Solution" href="#popnet.graphics.Solution">Solution</a></b></code>:
<ul class="hlist">
<li><code><a title="popnet.graphics.Solution.A" href="#popnet.graphics.Result.A">A</a></code></li>
<li><code><a title="popnet.graphics.Solution.CAA" href="#popnet.graphics.Result.CAA">CAA</a></code></li>
<li><code><a title="popnet.graphics.Solution.CAR" href="#popnet.graphics.Result.CAR">CAR</a></code></li>
<li><code><a title="popnet.graphics.Solution.CAS" href="#popnet.graphics.Result.CAS">CAS</a></code></li>
<li><code><a title="popnet.graphics.Solution.CRR" href="#popnet.graphics.Result.CRR">CRR</a></code></li>
<li><code><a title="popnet.graphics.Solution.CRS" href="#popnet.graphics.Result.CRS">CRS</a></code></li>
<li><code><a title="popnet.graphics.Solution.CSS" href="#popnet.graphics.Result.CSS">CSS</a></code></li>
<li><code><a title="popnet.graphics.Solution.R" href="#popnet.graphics.Result.R">R</a></code></li>
<li><code><a title="popnet.graphics.Solution.S" href="#popnet.graphics.Result.S">S</a></code></li>
<li><code><a title="popnet.graphics.Solution.activate" href="#popnet.graphics.Graphics.activate">activate</a></code></li>
<li><code><a title="popnet.graphics.Solution.ax" href="#popnet.graphics.Graphics.ax">ax</a></code></li>
<li><code><a title="popnet.graphics.Solution.colors" href="#popnet.graphics.Result.colors">colors</a></code></li>
<li><code><a title="popnet.graphics.Solution.config" href="#popnet.graphics.Graphics.config">config</a></code></li>
<li><code><a title="popnet.graphics.Solution.default_figure" href="#popnet.graphics.Result.default_figure">default_figure</a></code></li>
<li><code><a title="popnet.graphics.Solution.default_name" href="#popnet.graphics.Graphics.default_name">default_name</a></code></li>
<li><code><a title="popnet.graphics.Solution.draw" href="#popnet.graphics.Graphics.draw">draw</a></code></li>
<li><code><a title="popnet.graphics.Solution.fig" href="#popnet.graphics.Graphics.fig">fig</a></code></li>
<li><code><a title="popnet.graphics.Solution.get_spectrum" href="#popnet.graphics.Result.get_spectrum">get_spectrum</a></code></li>
<li><code><a title="popnet.graphics.Solution.legend" href="#popnet.graphics.Graphics.legend">legend</a></code></li>
<li><code><a title="popnet.graphics.Solution.load" href="#popnet.graphics.Result.load">load</a></code></li>
<li><code><a title="popnet.graphics.Solution.name" href="#popnet.graphics.Graphics.name">name</a></code></li>
<li><code><a title="popnet.graphics.Solution.plot" href="#popnet.graphics.Result.plot">plot</a></code></li>
<li><code><a title="popnet.graphics.Solution.plot_expectations" href="#popnet.graphics.Solution.plot_expectations">plot_expectations</a></code></li>
<li><code><a title="popnet.graphics.Solution.setup" href="#popnet.graphics.Result.setup">setup</a></code></li>
<li><code><a title="popnet.graphics.Solution.times" href="#popnet.graphics.Result.times">times</a></code></li>
<li><code><a title="popnet.graphics.Solution.x_units" href="#popnet.graphics.Result.x_units">x_units</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="popnet.graphics.Graphics"><code class="flex name class">
<span>class <span class="ident">Graphics</span></span>
<span>(</span><span>config, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>General base class to plot various diagrams.</p>
<p>This class provides basic tools to plot various diagrams related to
numerical experiments performed by PopNet. It relies heavily on the
<a href="https://matplotlib.org/">Matplotlib</a> library. This class is intended to be
used mainly through its subclasses.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>config</code></strong> :&ensp;<code><a title="popnet.structures.Configuration" href="structures.html#popnet.structures.Configuration">Configuration</a></code></dt>
<dd>Configuration associated with the plot.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name to associate with the plot. Defaults to <code>None</code>, in which case it
is replaced with <code><a title="popnet.graphics.Graphics.default_name" href="#popnet.graphics.Graphics.default_name">Graphics.default_name</a></code>.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>config</code></strong> :&ensp;<code><a title="popnet.structures.Configuration" href="structures.html#popnet.structures.Configuration">Configuration</a></code></dt>
<dd>Configuration associated with the plot. See <code><a title="popnet.graphics.Graphics.config" href="#popnet.graphics.Graphics.config">Graphics.config</a></code>.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name associated with the graphics. See <code><a title="popnet.graphics.Graphics.name" href="#popnet.graphics.Graphics.name">Graphics.name</a></code>.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>matplotlib.figure.Figure</code></dt>
<dd>A Matplotlib figure. See <code><a title="popnet.graphics.Graphics.fig" href="#popnet.graphics.Graphics.fig">Graphics.fig</a></code>.</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib.axes.Axes</code></dt>
<dd>Axes of <code>fig</code>. See <code><a title="popnet.graphics.Graphics.ax" href="#popnet.graphics.Graphics.ax">Graphics.ax</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Graphics:
    &#34;&#34;&#34;General base class to plot various diagrams.

    This class provides basic tools to plot various diagrams related to
    numerical experiments performed by PopNet. It relies heavily on the
    [Matplotlib](https://matplotlib.org/) library. This class is intended to be
    used mainly through its subclasses.

    Parameters
    ----------
    config : popnet.structures.Configuration
        Configuration associated with the plot.
    name : str, optional
        Name to associate with the plot. Defaults to `None`, in which case it
        is replaced with `Graphics.default_name`.

    Attributes
    ----------
    config : popnet.structures.Configuration
        Configuration associated with the plot. See `Graphics.config`.
    name : str
        Name associated with the graphics. See `Graphics.name`.
    fig : matplotlib.figure.Figure
        A Matplotlib figure. See `Graphics.fig`.
    ax : matplotlib.axes.Axes
        Axes of `fig`. See `Graphics.ax`.

    &#34;&#34;&#34;

    default_name = &#39;Graphics&#39;
    &#34;&#34;&#34;Default name given to instances.&#34;&#34;&#34;

    def __init__(self, config, name=None):
        if not isinstance(config, structures.Configuration):
            raise TypeError(&#39;The configuration used with a \&#39;Graphics\&#39; &#39;
                            &#39;instance must be a \&#39;Configuration\&#39; instance.&#39;)
        self._config = config
        self.name = self._get_name(name)
        self.fig = None
        self.ax = None

    @property
    def config(self):
        &#34;&#34;&#34;Configuration associated with the figure.

        Configuration associated with the figure. It is set at initialization,
        and cannot be set or deleted afterwards.
        &#34;&#34;&#34;
        return self._config

    @property
    def name(self):
        &#34;&#34;&#34;Name of the figure. It has to be a string.&#34;&#34;&#34;
        return self._name

    @name.setter
    def name(self, new_name):
        if not isinstance(new_name, str):
            raise TypeError(f&#39;Graphics.name must be a string.&#39;)
        self._name = new_name

    @property
    def fig(self):
        &#34;&#34;&#34;A figure on which to draw various plots.

        A [`matplotlib.figure.Figure`](https://31c8.short.gy/mpl-figure-Figure)
        object that can be used to draw plots. This is the figure where
        `Graphics`&#39; methods can plot curves. It is set automatically when
        `Graphics.activate` is called. It cannot be deleted manually.
        &#34;&#34;&#34;
        return self._fig

    @fig.setter
    def fig(self, new_value):
        if new_value is None:
            pass
        elif not isinstance(new_value, mpl.figure.Figure):
            raise TypeError(&#39;Graphics.fig must be a &#39;
                            &#39;\&#39;matplotlib.figure.Figure\&#39; instance.&#39;)
        self._fig = new_value

    @property
    def ax(self):
        &#34;&#34;&#34;Axes of the current figure.

        A [`matplotlib.axes.Axes`](https://31c8.short.gy/mpl-axes-Axes) object
        correponding to the axes of `Graphics.fig`. It is set automatically
        when `Graphics.activate` is called. It cannot be deleted manually.
        &#34;&#34;&#34;
        return self._ax

    @ax.setter
    def ax(self, new_value):
        if new_value is None:
            pass
        elif not isinstance(new_value, mpl.axes.Axes):
            raise TypeError(f&#39;Graphics.ax must be a &#39;
                            &#39;\&#39;matplotlib.axes.Axes\&#39; instance.&#39;)
        self._ax = new_value

    def activate(self, figsize=(5,3.75), dpi=150, tight_layout=True, 
                 font_family=&#39;serif&#39;, usetex=False, preamble=None, **kwargs):
        &#34;&#34;&#34;Activate a figure.
        
        Create a Matplotlib figure to plot diagrams, and set `Graphics.fig` and
        `Graphics.ax` to refer to the
        [`matplotlib.figure.Figure`](https://31c8.short.gy/mpl-figure-Figure)
        and [`matplotlib.axes.Axes`](https://31c8.short.gy/mpl-axes-Axes)
        objects corresponding to this figure. The figure is initialized with
        the default formatting defined by `figure`: in fact, if `graphic` is a
        `Graphics` object, the calls
        
        &gt;&gt;&gt; graphic.activate(**kwargs)
        
        and
        
        &gt;&gt;&gt; graphic.fig, graphic.ax = figure(subplots=None, **kwargs)
        
        are equivalent.

        Parameters
        ----------
        figsize : tuple of float, optional
            Width and height of the figure in inches. Defaults to (5, 3.75).
        dpi : int
            Resolution of the figure in dots per inches. Defaults to 150.
        tight_layout : bool, optional
            Adjust automatically the padding between and aroung subplots using
            [`matplotlib.figure.Figure.tight_layout`](
            https://31c8.short.gy/mpl-tight-layout). Defaults to `True`.
        font_family : {&#39;serif&#39;, &#39;sans-serif&#39;}, optional
            Determines if a serif or sans serif font family is used. Defaults
            to `&#39;serif&#39;`.
        usetex : bool, optional
            Determines if LaTeX is used to draw the figure. Defaults to `False`.
        preamble : str, optional
            LaTeX preamble when `usetex` is `True`, in which case it case be
            used to load font packages. It has no effect when `usetex` is
            `False`. Defaults to `None`, in which case a default preamble is
            added.
        **kwargs
            Keyword arguments to be passed to
            [`matplotlib.pyplot.figure`](https://31c8.short.gy/plt-figure).
        &#34;&#34;&#34;
        if &#39;subplots&#39; in kwargs:
            raise TypeError(&#39;Graphics.activate() got an unexpected keyword &#39;
                            &#39;argument \&#39;subplots\&#39;&#39;)
        self.fig, self.ax = figure(
            figsize=figsize, dpi=dpi, tight_layout=tight_layout,
            font_family=font_family, usetex=usetex, preamble=preamble, **kwargs)

    def draw(self, name=None, show=True, savefig=False, folder=None, 
             format=None, **kwargs):
        &#34;&#34;&#34;Draw the plot.

        Draw a figure activated with `Graphics.activate`. If the figure is
        saved, it is named *ID - name*, where *ID* is the configuration&#39;s ID,
        *name* is `name`, and has the file format chosen with `format`.

        Parameters
        ----------
        name : str, optional
            Name to give to the figure if saved. Defaults to `None`, in which
            case `Graphics.name` is used.
        show : bool, optional
            Decides if the figure is shown or not. Defaults to `True`.
        savefig : bool, optional
            Decides if the figure is saved or not. Defaults to `False`.
        folder : str, optional
            A folder in which the figure can be saved. If it does not exist in
            the current directory and the figure is saved, it is created.
            Defaults to `None`, in which case the figure is saved in the
            current directory.
        format : str, optional
            The file format under which the figure is saved if `savefig` is
            `True`. It must be a format handled by Matplotlib, which includes
            &#39;png&#39;, &#39;jpg&#39;, &#39;pdf&#39; and &#39;svg&#39;. Defaults to `None`, in which case
            the file format is Matplotlib&#39;s `savefig.format` parameter, which
            defaults to &#39;png&#39;.
        **kwargs
            Keyword arguments passed to
            [`matplotlib.pyplot.savefig`](https://31c8.short.gy/plt-savefig)
            when `savefig` is `True`.

        Raises
        ------
        popnet.exceptions.PopNetError
            If the figure has not been activated yet.
        &#34;&#34;&#34;
        self._check_if_activated()
        if savefig:
            if name is None:
                name = self.name
            filename = _internals._format_filename(
                            folder, self.config.ID, name, extension=format)
            _internals._make_sure_folder_exists(folder)
            plt.savefig(filename, format=format, **kwargs)
        if show:
            plt.show()
        plt.close(self.fig)

    def legend(self, lw=2, fontsize=10, ncol=None, handletextpad=0.5, **kwargs):
        &#34;&#34;&#34;Generate a legend for the figure.

        Generate a legend for the figure with default options.

        Parameters
        ----------
        lw : float, optional
            Line width of the legend handles. Defaults to 2.
        fontsize : float, optional
            Fontsize of the legend labels. Defaults to 10.
        ncol : int, optional
            Number of columns of the legend. Defaults to `None`, in which case
            it is set to the number of populations of the configuration&#39;s
            network.
        handletextpad : float, optional
            Padding of the labels. Defaults to 0.5.
        **kwargs
            Keyword arguments to be passed to the
            [`legend`](https://31c8.short.gy/ax-legend) method of
            `Graphics.ax`, which actually adds the legend on the figure.

        Returns
        -------
        matplotlib.legend.Legend
            The figure&#39;s legend.
        &#34;&#34;&#34;
        if ncol is None:
            ncol = len(self.config.network.populations)
        leg = self.ax.legend(fontsize=fontsize, ncol=ncol, 
                             handletextpad=handletextpad, **kwargs)
        for lego in leg.legendHandles:
            lego.set_linewidth(lw)
        return leg

    def _check_if_activated(self):
        &#34;&#34;&#34;Check if the figure is already activated.&#34;&#34;&#34;
        if self.fig is None or self.ax is None:
            raise PopNetError(&#39;The figure must be activated before to be &#39;
                              &#39;drawn. Call Graphics.activate() first.&#39;)

    @classmethod
    def _get_name(cls, name):
        &#34;&#34;&#34;Return `name`, or the default name if `name` is `None`.&#34;&#34;&#34;
        if name is None:
            return cls.default_name
        return name</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="popnet.graphics.PhasePlane" href="#popnet.graphics.PhasePlane">PhasePlane</a></li>
<li><a title="popnet.graphics.Result" href="#popnet.graphics.Result">Result</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="popnet.graphics.Graphics.default_name"><code class="name">var <span class="ident">default_name</span></code></dt>
<dd>
<div class="desc"><p>Default name given to instances.</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="popnet.graphics.Graphics.ax"><code class="name">var <span class="ident">ax</span></code></dt>
<dd>
<div class="desc"><p>Axes of the current figure.</p>
<p>A <a href="https://31c8.short.gy/mpl-axes-Axes"><code>matplotlib.axes.Axes</code></a> object
correponding to the axes of <code><a title="popnet.graphics.Graphics.fig" href="#popnet.graphics.Graphics.fig">Graphics.fig</a></code>. It is set automatically
when <code><a title="popnet.graphics.Graphics.activate" href="#popnet.graphics.Graphics.activate">Graphics.activate()</a></code> is called. It cannot be deleted manually.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ax(self):
    &#34;&#34;&#34;Axes of the current figure.

    A [`matplotlib.axes.Axes`](https://31c8.short.gy/mpl-axes-Axes) object
    correponding to the axes of `Graphics.fig`. It is set automatically
    when `Graphics.activate` is called. It cannot be deleted manually.
    &#34;&#34;&#34;
    return self._ax</code></pre>
</details>
</dd>
<dt id="popnet.graphics.Graphics.config"><code class="name">var <span class="ident">config</span></code></dt>
<dd>
<div class="desc"><p>Configuration associated with the figure.</p>
<p>Configuration associated with the figure. It is set at initialization,
and cannot be set or deleted afterwards.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def config(self):
    &#34;&#34;&#34;Configuration associated with the figure.

    Configuration associated with the figure. It is set at initialization,
    and cannot be set or deleted afterwards.
    &#34;&#34;&#34;
    return self._config</code></pre>
</details>
</dd>
<dt id="popnet.graphics.Graphics.fig"><code class="name">var <span class="ident">fig</span></code></dt>
<dd>
<div class="desc"><p>A figure on which to draw various plots.</p>
<p>A <a href="https://31c8.short.gy/mpl-figure-Figure"><code>matplotlib.figure.Figure</code></a>
object that can be used to draw plots. This is the figure where
<code><a title="popnet.graphics.Graphics" href="#popnet.graphics.Graphics">Graphics</a></code>' methods can plot curves. It is set automatically when
<code><a title="popnet.graphics.Graphics.activate" href="#popnet.graphics.Graphics.activate">Graphics.activate()</a></code> is called. It cannot be deleted manually.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def fig(self):
    &#34;&#34;&#34;A figure on which to draw various plots.

    A [`matplotlib.figure.Figure`](https://31c8.short.gy/mpl-figure-Figure)
    object that can be used to draw plots. This is the figure where
    `Graphics`&#39; methods can plot curves. It is set automatically when
    `Graphics.activate` is called. It cannot be deleted manually.
    &#34;&#34;&#34;
    return self._fig</code></pre>
</details>
</dd>
<dt id="popnet.graphics.Graphics.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>Name of the figure. It has to be a string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self):
    &#34;&#34;&#34;Name of the figure. It has to be a string.&#34;&#34;&#34;
    return self._name</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="popnet.graphics.Graphics.activate"><code class="name flex">
<span>def <span class="ident">activate</span></span>(<span>self, figsize=(5, 3.75), dpi=150, tight_layout=True, font_family='serif', usetex=False, preamble=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Activate a figure.</p>
<p>Create a Matplotlib figure to plot diagrams, and set <code><a title="popnet.graphics.Graphics.fig" href="#popnet.graphics.Graphics.fig">Graphics.fig</a></code> and
<code><a title="popnet.graphics.Graphics.ax" href="#popnet.graphics.Graphics.ax">Graphics.ax</a></code> to refer to the
<a href="https://31c8.short.gy/mpl-figure-Figure"><code>matplotlib.figure.Figure</code></a>
and <a href="https://31c8.short.gy/mpl-axes-Axes"><code>matplotlib.axes.Axes</code></a>
objects corresponding to this figure. The figure is initialized with
the default formatting defined by <code><a title="popnet.graphics.figure" href="#popnet.graphics.figure">figure()</a></code>: in fact, if <code>graphic</code> is a
<code><a title="popnet.graphics.Graphics" href="#popnet.graphics.Graphics">Graphics</a></code> object, the calls</p>
<pre><code class="python-repl">&gt;&gt;&gt; graphic.activate(**kwargs)
</code></pre>
<p>and</p>
<pre><code class="python-repl">&gt;&gt;&gt; graphic.fig, graphic.ax = figure(subplots=None, **kwargs)
</code></pre>
<p>are equivalent.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>figsize</code></strong> :&ensp;<code>tuple</code> of <code>float</code>, optional</dt>
<dd>Width and height of the figure in inches. Defaults to (5, 3.75).</dd>
<dt><strong><code>dpi</code></strong> :&ensp;<code>int</code></dt>
<dd>Resolution of the figure in dots per inches. Defaults to 150.</dd>
<dt><strong><code>tight_layout</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Adjust automatically the padding between and aroung subplots using
<a href="https://31c8.short.gy/mpl-tight-layout"><code>matplotlib.figure.Figure.tight_layout</code></a>. Defaults to <code>True</code>.</dd>
<dt><strong><code>font_family</code></strong> :&ensp;<code>{'serif', 'sans-serif'}</code>, optional</dt>
<dd>Determines if a serif or sans serif font family is used. Defaults
to <code>'serif'</code>.</dd>
<dt><strong><code>usetex</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Determines if LaTeX is used to draw the figure. Defaults to <code>False</code>.</dd>
<dt><strong><code>preamble</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>LaTeX preamble when <code>usetex</code> is <code>True</code>, in which case it case be
used to load font packages. It has no effect when <code>usetex</code> is
<code>False</code>. Defaults to <code>None</code>, in which case a default preamble is
added.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments to be passed to
<a href="https://31c8.short.gy/plt-figure"><code>matplotlib.pyplot.figure</code></a>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def activate(self, figsize=(5,3.75), dpi=150, tight_layout=True, 
             font_family=&#39;serif&#39;, usetex=False, preamble=None, **kwargs):
    &#34;&#34;&#34;Activate a figure.
    
    Create a Matplotlib figure to plot diagrams, and set `Graphics.fig` and
    `Graphics.ax` to refer to the
    [`matplotlib.figure.Figure`](https://31c8.short.gy/mpl-figure-Figure)
    and [`matplotlib.axes.Axes`](https://31c8.short.gy/mpl-axes-Axes)
    objects corresponding to this figure. The figure is initialized with
    the default formatting defined by `figure`: in fact, if `graphic` is a
    `Graphics` object, the calls
    
    &gt;&gt;&gt; graphic.activate(**kwargs)
    
    and
    
    &gt;&gt;&gt; graphic.fig, graphic.ax = figure(subplots=None, **kwargs)
    
    are equivalent.

    Parameters
    ----------
    figsize : tuple of float, optional
        Width and height of the figure in inches. Defaults to (5, 3.75).
    dpi : int
        Resolution of the figure in dots per inches. Defaults to 150.
    tight_layout : bool, optional
        Adjust automatically the padding between and aroung subplots using
        [`matplotlib.figure.Figure.tight_layout`](
        https://31c8.short.gy/mpl-tight-layout). Defaults to `True`.
    font_family : {&#39;serif&#39;, &#39;sans-serif&#39;}, optional
        Determines if a serif or sans serif font family is used. Defaults
        to `&#39;serif&#39;`.
    usetex : bool, optional
        Determines if LaTeX is used to draw the figure. Defaults to `False`.
    preamble : str, optional
        LaTeX preamble when `usetex` is `True`, in which case it case be
        used to load font packages. It has no effect when `usetex` is
        `False`. Defaults to `None`, in which case a default preamble is
        added.
    **kwargs
        Keyword arguments to be passed to
        [`matplotlib.pyplot.figure`](https://31c8.short.gy/plt-figure).
    &#34;&#34;&#34;
    if &#39;subplots&#39; in kwargs:
        raise TypeError(&#39;Graphics.activate() got an unexpected keyword &#39;
                        &#39;argument \&#39;subplots\&#39;&#39;)
    self.fig, self.ax = figure(
        figsize=figsize, dpi=dpi, tight_layout=tight_layout,
        font_family=font_family, usetex=usetex, preamble=preamble, **kwargs)</code></pre>
</details>
</dd>
<dt id="popnet.graphics.Graphics.draw"><code class="name flex">
<span>def <span class="ident">draw</span></span>(<span>self, name=None, show=True, savefig=False, folder=None, format=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Draw the plot.</p>
<p>Draw a figure activated with <code><a title="popnet.graphics.Graphics.activate" href="#popnet.graphics.Graphics.activate">Graphics.activate()</a></code>. If the figure is
saved, it is named <em>ID - name</em>, where <em>ID</em> is the configuration's ID,
<em>name</em> is <code>name</code>, and has the file format chosen with <code>format</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name to give to the figure if saved. Defaults to <code>None</code>, in which
case <code><a title="popnet.graphics.Graphics.name" href="#popnet.graphics.Graphics.name">Graphics.name</a></code> is used.</dd>
<dt><strong><code>show</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Decides if the figure is shown or not. Defaults to <code>True</code>.</dd>
<dt><strong><code>savefig</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Decides if the figure is saved or not. Defaults to <code>False</code>.</dd>
<dt><strong><code>folder</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>A folder in which the figure can be saved. If it does not exist in
the current directory and the figure is saved, it is created.
Defaults to <code>None</code>, in which case the figure is saved in the
current directory.</dd>
<dt><strong><code>format</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The file format under which the figure is saved if <code>savefig</code> is
<code>True</code>. It must be a format handled by Matplotlib, which includes
'png', 'jpg', 'pdf' and 'svg'. Defaults to <code>None</code>, in which case
the file format is Matplotlib's <code>savefig.format</code> parameter, which
defaults to 'png'.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to
<a href="https://31c8.short.gy/plt-savefig"><code>matplotlib.pyplot.savefig</code></a>
when <code>savefig</code> is <code>True</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="popnet.exceptions.PopNetError" href="exceptions.html#popnet.exceptions.PopNetError">PopNetError</a></code></dt>
<dd>If the figure has not been activated yet.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw(self, name=None, show=True, savefig=False, folder=None, 
         format=None, **kwargs):
    &#34;&#34;&#34;Draw the plot.

    Draw a figure activated with `Graphics.activate`. If the figure is
    saved, it is named *ID - name*, where *ID* is the configuration&#39;s ID,
    *name* is `name`, and has the file format chosen with `format`.

    Parameters
    ----------
    name : str, optional
        Name to give to the figure if saved. Defaults to `None`, in which
        case `Graphics.name` is used.
    show : bool, optional
        Decides if the figure is shown or not. Defaults to `True`.
    savefig : bool, optional
        Decides if the figure is saved or not. Defaults to `False`.
    folder : str, optional
        A folder in which the figure can be saved. If it does not exist in
        the current directory and the figure is saved, it is created.
        Defaults to `None`, in which case the figure is saved in the
        current directory.
    format : str, optional
        The file format under which the figure is saved if `savefig` is
        `True`. It must be a format handled by Matplotlib, which includes
        &#39;png&#39;, &#39;jpg&#39;, &#39;pdf&#39; and &#39;svg&#39;. Defaults to `None`, in which case
        the file format is Matplotlib&#39;s `savefig.format` parameter, which
        defaults to &#39;png&#39;.
    **kwargs
        Keyword arguments passed to
        [`matplotlib.pyplot.savefig`](https://31c8.short.gy/plt-savefig)
        when `savefig` is `True`.

    Raises
    ------
    popnet.exceptions.PopNetError
        If the figure has not been activated yet.
    &#34;&#34;&#34;
    self._check_if_activated()
    if savefig:
        if name is None:
            name = self.name
        filename = _internals._format_filename(
                        folder, self.config.ID, name, extension=format)
        _internals._make_sure_folder_exists(folder)
        plt.savefig(filename, format=format, **kwargs)
    if show:
        plt.show()
    plt.close(self.fig)</code></pre>
</details>
</dd>
<dt id="popnet.graphics.Graphics.legend"><code class="name flex">
<span>def <span class="ident">legend</span></span>(<span>self, lw=2, fontsize=10, ncol=None, handletextpad=0.5, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a legend for the figure.</p>
<p>Generate a legend for the figure with default options.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>lw</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Line width of the legend handles. Defaults to 2.</dd>
<dt><strong><code>fontsize</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Fontsize of the legend labels. Defaults to 10.</dd>
<dt><strong><code>ncol</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of columns of the legend. Defaults to <code>None</code>, in which case
it is set to the number of populations of the configuration's
network.</dd>
<dt><strong><code>handletextpad</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Padding of the labels. Defaults to 0.5.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments to be passed to the
<a href="https://31c8.short.gy/ax-legend"><code>legend</code></a> method of
<code><a title="popnet.graphics.Graphics.ax" href="#popnet.graphics.Graphics.ax">Graphics.ax</a></code>, which actually adds the legend on the figure.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>matplotlib.legend.Legend</code></dt>
<dd>The figure's legend.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def legend(self, lw=2, fontsize=10, ncol=None, handletextpad=0.5, **kwargs):
    &#34;&#34;&#34;Generate a legend for the figure.

    Generate a legend for the figure with default options.

    Parameters
    ----------
    lw : float, optional
        Line width of the legend handles. Defaults to 2.
    fontsize : float, optional
        Fontsize of the legend labels. Defaults to 10.
    ncol : int, optional
        Number of columns of the legend. Defaults to `None`, in which case
        it is set to the number of populations of the configuration&#39;s
        network.
    handletextpad : float, optional
        Padding of the labels. Defaults to 0.5.
    **kwargs
        Keyword arguments to be passed to the
        [`legend`](https://31c8.short.gy/ax-legend) method of
        `Graphics.ax`, which actually adds the legend on the figure.

    Returns
    -------
    matplotlib.legend.Legend
        The figure&#39;s legend.
    &#34;&#34;&#34;
    if ncol is None:
        ncol = len(self.config.network.populations)
    leg = self.ax.legend(fontsize=fontsize, ncol=ncol, 
                         handletextpad=handletextpad, **kwargs)
    for lego in leg.legendHandles:
        lego.set_linewidth(lw)
    return leg</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="popnet.graphics.PhasePlane"><code class="flex name class">
<span>class <span class="ident">PhasePlane</span></span>
<span>(</span><span>system, axes, fixed_axes, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Draw phase planes for dynamical systems.</p>
<p>This class is dedicated to plot phase planes of dynamical systems
implemented in <code><a title="popnet.systems" href="systems.html">popnet.systems</a></code>. It should be emphasized that this class is
intended to draw phase <em>planes</em>, not one- or three-dimensional phase spaces.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>system</code></strong> :&ensp;<code><a title="popnet.systems.DynamicalSystem" href="systems.html#popnet.systems.DynamicalSystem">DynamicalSystem</a></code></dt>
<dd>Dynamical system for which to draw a phase plane.</dd>
<dt><strong><code>axes</code></strong> :&ensp;<code>tuple</code> of <code>int</code></dt>
<dd>Components of the dynamical system that will be independant variables
on the phase plane.</dd>
<dt><strong><code>fixed_axes</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Values of the remaining components other than the independent variables
corresponding to <code>axes</code>.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>A name associated with the phase plane. Defaults to <code>None</code>, in which
case it is replaced with <code><a title="popnet.graphics.PhasePlane.default_name" href="#popnet.graphics.Graphics.default_name">PhasePlane.default_name</a></code>.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>config</code></strong> :&ensp;<code><a title="popnet.structures.Configuration" href="structures.html#popnet.structures.Configuration">Configuration</a></code></dt>
<dd>The configuration associated with the phase plane. See
<code><a title="popnet.graphics.PhasePlane.config" href="#popnet.graphics.Graphics.config">PhasePlane.config</a></code>.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name associated with the phase plane. See <code><a title="popnet.graphics.PhasePlane.name" href="#popnet.graphics.Graphics.name">PhasePlane.name</a></code>.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>matplotlib.figure.Figure</code></dt>
<dd>A Matplotlib figure. See <code><a title="popnet.graphics.PhasePlane.fig" href="#popnet.graphics.Graphics.fig">PhasePlane.fig</a></code>.</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib.axes.Axes</code></dt>
<dd>The axes of <code>fig</code>. See <code><a title="popnet.graphics.PhasePlane.ax" href="#popnet.graphics.Graphics.ax">PhasePlane.ax</a></code>.</dd>
<dt><strong><code>system</code></strong> :&ensp;<code><a title="popnet.systems.DynamicalSystem" href="systems.html#popnet.systems.DynamicalSystem">DynamicalSystem</a></code></dt>
<dd>Dynamical system for which to draw a phase plane. See
<code><a title="popnet.graphics.PhasePlane.system" href="#popnet.graphics.PhasePlane.system">PhasePlane.system</a></code>.</dd>
<dt><strong><code>axes</code></strong> :&ensp;<code>tuple</code> of <code>int</code></dt>
<dd>Components chosen as independant variables for the phase plane. See
<code><a title="popnet.graphics.PhasePlane.axes" href="#popnet.graphics.PhasePlane.axes">PhasePlane.axes</a></code>.</dd>
<dt><strong><code>fixed_axes</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Values of the remaining state components other than independent ones.
See <code><a title="popnet.graphics.PhasePlane.fixed_axes" href="#popnet.graphics.PhasePlane.fixed_axes">PhasePlane.fixed_axes</a></code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>system</code> is not a <code><a title="popnet.systems.DynamicalSystem" href="systems.html#popnet.systems.DynamicalSystem">DynamicalSystem</a></code> instance.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The cases where the dynamical system studied is the
<code><a title="popnet.systems.MeanFieldSystem" href="systems.html#popnet.systems.MeanFieldSystem">MeanFieldSystem</a></code> or the <code><a title="popnet.systems.WilsonCowanSystem" href="systems.html#popnet.systems.WilsonCowanSystem">WilsonCowanSystem</a></code>
are internally handled by private subclasses <code>_PhasePlaneMeanField</code> and
<code>_PhasePlaneWilsonCowan</code>, which are automatically instantiated by the class
constructor of <code><a title="popnet.graphics.PhasePlane" href="#popnet.graphics.PhasePlane">PhasePlane</a></code> when appropriate. The subclasses mentioned
above are responsible to define the methods used to compute nullclines for
the corresponding dynamical systems.</p>
<p>This is considered to be an implementation detail, and should not be useful
from a user perspective.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PhasePlane(Graphics):
    &#34;&#34;&#34;Draw phase planes for dynamical systems.

    This class is dedicated to plot phase planes of dynamical systems
    implemented in `popnet.systems`. It should be emphasized that this class is
    intended to draw phase *planes*, not one- or three-dimensional phase spaces.

    Parameters
    ----------
    system : popnet.systems.DynamicalSystem
        Dynamical system for which to draw a phase plane.
    axes : tuple of int
        Components of the dynamical system that will be independant variables
        on the phase plane.
    fixed_axes : array_like
        Values of the remaining components other than the independent variables
        corresponding to `axes`.
    name : str, optional
        A name associated with the phase plane. Defaults to `None`, in which
        case it is replaced with `PhasePlane.default_name`.

    Attributes
    ----------
    config : popnet.structures.Configuration
        The configuration associated with the phase plane. See
        `PhasePlane.config`.
    name : str
        Name associated with the phase plane. See `PhasePlane.name`.
    fig : matplotlib.figure.Figure
        A Matplotlib figure. See `PhasePlane.fig`.
    ax : matplotlib.axes.Axes
        The axes of `fig`. See `PhasePlane.ax`.
    system : popnet.systems.DynamicalSystem
        Dynamical system for which to draw a phase plane. See
        `PhasePlane.system`.
    axes : tuple of int
        Components chosen as independant variables for the phase plane. See
        `PhasePlane.axes`.
    fixed_axes : array_like
        Values of the remaining state components other than independent ones.
        See `PhasePlane.fixed_axes`.

    Raises
    ------
    TypeError
        If `system` is not a `popnet.systems.DynamicalSystem` instance.

    Notes
    -----
    The cases where the dynamical system studied is the
    `popnet.systems.MeanFieldSystem` or the `popnet.systems.WilsonCowanSystem`
    are internally handled by private subclasses `_PhasePlaneMeanField` and
    `_PhasePlaneWilsonCowan`, which are automatically instantiated by the class
    constructor of `PhasePlane` when appropriate. The subclasses mentioned
    above are responsible to define the methods used to compute nullclines for
    the corresponding dynamical systems.

    This is considered to be an implementation detail, and should not be useful
    from a user perspective.

    &#34;&#34;&#34;

    default_name = &#39;Phase plane&#39;
    &#34;&#34;&#34;Default name given to instances.&#34;&#34;&#34;

    def __init__(self, system, axes, fixed_axes, name=None):
        if not isinstance(system, systems.DynamicalSystem):
            raise TypeError(&#39;The system associated with a \&#39;PhasePlane\&#39; &#39;
                            &#39;instance must be a \&#39;DynamicalSystem\&#39; instance.&#39;)
        self._system = system
        super().__init__(system.config, name=name)
        self.axes = axes
        if (n := self.system.dim - 2) == 0:
            self.fixed_axes = None
        else:
            self.fixed_axes = fixed_axes

    def __new__(cls, system, axes, fixed_axes, name=None):
        if isinstance(system, systems.WilsonCowanSystem):
            return super().__new__(_PhasePlaneWilsonCowan)
        if isinstance(system, (systems.MeanFieldSystem, systems.MixedSystem)):
            return super().__new__(_PhasePlaneMeanField)
        return super().__new__(cls)

    @property
    def system(self):
        &#34;&#34;&#34;Dynamical system for which to draw a phase plane.

        Dynamical system for which a phase plane is to be drawn. It must be
        a `popnet.systems.DynamicalSystem` instance. It is set at
        initialization, and afterwards it cannot be manually set nor deleted.
        &#34;&#34;&#34;
        return self._system

    @property
    def axes(self):
        &#34;&#34;&#34;Components chosen as independant variables for the phase plane.
        
        It must be a tuple of two integers corresponding to valid axes of the
        dynamical system. It cannot be deleted.
        &#34;&#34;&#34;
        return self._axes

    @axes.setter
    def axes(self, new_value):
        self._check_if_tuple_of_two_int(new_value)
        if max(new_value) &gt;= self.system.dim:
            if (L := self.system.dim) == 1:
                s = &#39;&#39;
            else:
                s = &#39;s&#39;
            raise ValueError(f&#39;{new_value} contains an invalid index: the &#39;
                             &#39;dynamical system has only &#39;
                             f&#39;{self.system.dim} component{s}.&#39;)
        self._axes = new_value

    @property
    def fixed_axes(self):
        &#34;&#34;&#34;Fixed values for remaining state components.

        Values given to state components other than those chosen as
        independent. It is a one-dimensional array, or `None` if the whole
        dynamical system is two-dimensional. 

        It can be set as a single float value, in which case this value is
        given to all fixed axes. It cannot be deleted.
        &#34;&#34;&#34;
        return self._fixed_axes

    @fixed_axes.setter
    def fixed_axes(self, new_value):
        if new_value is None:
            if (n := self.system.dim - 2) &gt; 0:
                warn(&#39;The fixed axes should be given values, since the system &#39;
                     &#39;has more dimensions than two. A zero array has been set.&#39;,
                     category=PopNetWarning, stacklevel=2)
                self._fixed_axes = np.zeros(n)
            else:
                self._fixed_axes = None
            return
        try:
            new_value = np.array(new_value, float)
        except Exception:
            raise TypeError(&#39;The fixed components must be given as an array &#39;
                            &#39;of floats.&#39;)
        if (n := self.system.dim - 2) &gt; 0:
            if new_value.shape == ():
                new_value = new_value * np.ones(n)
            elif new_value.shape != (n,):
                raise ValueError(&#39;The given fixed components array has shape &#39;
                                 f&#39;{new_value.shape} but it must have shape &#39;
                                 f&#39;{(n,)}.&#39;)
            self._fixed_axes = new_value
        else:
            warn(&#39;No state components should be fixed as the system does not &#39;
                 &#39;have more than two state components in total. The \&#39;fixed_&#39;
                 &#39;state\&#39; attribute has been set to \&#39;None\&#39;.&#39;,
                 category=PopNetWarning, stacklevel=2)
            self._fixed_axes = None

    def legend(self, lw=2, fontsize=10, ncol=1, handletextpad=0.5, 
               framealpha=1, **kwargs):
        &#34;&#34;&#34;Generate a legend for the figure.

        Generate a legend for the figure with default options. Same as the base
        class method `Graphics.legend`, but changes the defaults for `ncol` and
        `framealpha` to 1.
        &#34;&#34;&#34;
        return super().legend(lw=lw, fontsize=fontsize, ncol=ncol, 
                              handletextpad=handletextpad,
                              framealpha=framealpha, **kwargs)

    def plot_nullclines(self, which=&#39;both&#39;, num=1000, xcolor=None, ycolor=None,
                        xlim=(0,1), ylim=(0,1), **kwargs):
        &#34;&#34;&#34;Plot nullclines on the phase plane.

        Plot nullclines for independent variables on the phase plane. This
        method is mostly intended to be used with the Wilson--Cowan system,
        with its extension with refractory state, or with the &#39;mixed&#39; system
        that makes a transition between the first two. Indeed, with these
        systems nullclines can be computed easily.

        For dynamical systems that include covariances, nullclines are computed
        numerically using [`root`](https://31c8.short.gy/scipy-optimize-root)
        from SciPy&#39;s `optimize` module. However, this feature is still
        experimental, and could lead to unaccurate or unexpected results. A
        warning is issued when this method is used in such a case.

        Parameters
        ----------
        which : {&#39;x&#39;, &#39;y&#39;, &#39;both&#39;}, optional
            Which nullcline to plot. Defaults to `&#39;both&#39;`.
        num : int, optional
            Number of points on nullclines. Defaults to 1000.
        xcolor, ycolor : string or tuple, optional
            Colors given to nullclines. `zcolor` is the color for the nullcline
            where the component drawn on axis *z* does not vary. They must be
            valid Matplotlib colors. Both default to `None`, in which case
            default colors are used.
        xlim, ylim : tuple, optional
            Limits of the horizontal and vertical axis, respectively. Both
            default to (0,1).
        **kwargs
            Keyword arguments to be passed to the
            [`plot`](https://31c8.short.gy/ax-plot) method of `PhasePlane.ax`,
            which actually plots the nullclines.

        Warns
        -----
        popnet.exceptions.PopNetWarning
            If nullclines are computed numerically with the experimental
            algorithm.
        &#34;&#34;&#34;
        if which not in (valid_values := (&#39;x&#39;, &#39;y&#39;, &#39;both&#39;)):
            warn(f&#39;Unexpected value {which} for \&#39;which\&#39;. Valid values are &#39;
                 f&#39;{valid_values}. No nullclines will be plotted.&#39;,
                 stacklevel=2, category=PopNetWarning)
        plot = {&#39;x&#39;: True if which in (&#39;x&#39;, &#39;both&#39;) else False,
                &#39;y&#39;: True if which in (&#39;y&#39;, &#39;both&#39;) else False}
        x = np.linspace(xlim[0], xlim[1], num)
        y = np.linspace(ylim[0], ylim[1], num)
        if plot[&#39;x&#39;]:
            x1, y1 = self._nullcline(x, y, self.axes[0], self.axes[1])
            self.ax.plot(x1, y1, color=xcolor,
                         label=self._nullcline_label(self.axes[0]))
        if plot[&#39;y&#39;]:
            y2, x2 = self._nullcline(y, x, self.axes[1], self.axes[0])
            self.ax.plot(x2, y2, color=ycolor,
                         label=self._nullcline_label(self.axes[1]))

    def plot_solution(self, **kwargs):
        &#34;&#34;&#34;Plot a solution of the dynamical system on the phase plane.
        
        Run a numerical integration, and plot the resulting solution on the
        phase plane.

        Parameters
        ----------
        **kwargs
            Keyword arguments passed to the
            [`plot`](https://31c8.short.gy/ax-plot) method of `PhasePlane.ax`,
            which actually plots the solution.
        &#34;&#34;&#34;
        from .executors import get_integrator
        integrator = get_integrator(self.system)
        solution = self._run_experiment(integrator, &#39;ode&#39;)
        label = kwargs.pop(&#39;label&#39;, &#39;Solution&#39;)
        self.ax.plot(solution[0], solution[1], label=label, **kwargs)

    def plot_trajectory(self, act=&#39;step&#39;, **kwargs):
        &#34;&#34;&#34;Plot a trajectory of a stochastic process on the phase plane.

        Run a simulation of a stochastic process, and plot the resulting
        trajectory on the phase plane. The configuration used with the phase
        plane must have a defined microscopic structure.

        Parameters
        ----------
        act : {&#39;step&#39;, &#39;sigmoid&#39;}, optional
            Shape of neurons&#39; activation rates for the simulation. If `&#39;step&#39;`,
            a neuron&#39;s activation rate is a step function going from zero to
            `popnet.structures.MicroNetwork.alpha` at its threshold
            `popnet.structures.MicroNetwork.theta`. If `&#39;sigmoid&#39;`, a neuron&#39;s
            activation rate is the logistic function
            `popnet.structures.Population.F` of the population to which it
            belongs. Defaults to `&#39;step&#39;`.
        **kwargs
            Keyword arguments passed to the
            [`plot`](https://31c8.short.gy/ax-plot) method of `PhasePlane.ax`,
            which actually plots the trajectory.
        &#34;&#34;&#34;
        from .executors import get_simulator
        simulator = get_simulator(self.config, act=act, mode=&#39;individual&#39;)
        trajectory = self._run_experiment(simulator)
        label = kwargs.pop(&#39;label&#39;, &#39;Trajectory&#39;)
        self.ax.plot(trajectory[0], trajectory[1], label=label, **kwargs)

    def quiver(self, shape, xlim=(0,1), ylim=(0,1), **kwargs):
        &#34;&#34;&#34;Draw the vector field on the initialized figure.

        Draw the vector field on the figure `PhasePlane.fig`. The field is
        plotted as a 2D field of arrows with
        [`matplotlib.axes.Axes.quiver`](https://31c8.short.gy/ax-quiver)
        on the axes `PhasePlane.ax`.

        Parameters
        ----------
        shape : tuple of int
            Shape of the grid on which to plot the vector field.
        xlim, ylim : tuple, optional
            Limits of the horizontal and vertical axis, respectively. Both
            default to (0,1).
        **kwargs
            Keyword arguments passed to
            [`matplotlib.axes.Axes.quiver`](https://31c8.short.gy/ax-quiver)
        &#34;&#34;&#34;
        self._check_if_activated()
        X, Y, dX, dY = self._get_arrows(xlim, ylim, shape)
        self.ax.quiver(X, Y, dX, dY, **kwargs)

    def setup(self, xlim=(0,1), ylim=(0,1), fontsize=10, aspect=&#39;auto&#39;):
        &#34;&#34;&#34;Setup the figure.

        Setup the figure `PhasePlane.fig`. Allows to set limits to both axes,
        to choose a font size for labels, and to set the aspect ratio of the
        axes.

        Parameters
        ----------
        xlim, ylim : tuple, optional
            Limits of the horizontal and vertical axis, respectively. Both
            default to (0,1).
        fontsize : float, optional
            Fontsize of the axes&#39; labels. Defaults to 10.
        aspect : {&#39;auto&#39;, &#39;equal&#39;} or float, optional
            Aspect ratio of the axis scaling. If `&#39;auto&#39;`, the plot fills
            the available area, if `&#39;equal&#39;`, the scaling is the same for
            both axes, and if a float, a square would be stretched such that
            its height is `aspect` times its width. Defaults to `&#39;auto&#39;`.
        &#34;&#34;&#34;
        self.ax.set_xlim(xlim)
        self.ax.set_ylim(ylim)
        self.ax.set_xlabel(self._label(self.axes[0]), fontsize=fontsize)
        self.ax.set_ylabel(self._label(self.axes[1]), fontsize=fontsize, 
                           rotation=0)
        self.ax.axes.set_aspect(aspect)

    def streamplot(self, shape, xlim=(0,1), ylim=(0,1), colorbar=False, 
                   cmap=&#39;bone&#39;, color=None, density=1.5, **kwargs):
        &#34;&#34;&#34;Draw the vector field on the initialized figure.

        Draw the vector field on the figure `PhasePlane.fig`. The field is
        plotted as streamlines with
        [`matplotlib.axes.Axes.streamplot`](https://31c8.short.gy/ax-streamplot)
        on the axes `PhasePlane.ax`.

        Parameters
        ----------
        shape : tuple of int
            Shape of the grid on which to plot the vector field.
        xlim, ylim : tuple, optional
            Limits of the horizontal and vertical axis, respectively. Both
            default to (0,1).
        colorbar : bool, optional
            If `True`, a colorbar is added on the phase plane, where the color
            represents the euclidean norm of the derivative. Defaults to
            `False`.
        cmap : str, optional
            Colormap for the vector field when `colorbar` is `True`. See
            [this page](https://31c8.short.gy/mpl-colormap)
            of Matplotlib&#39;s documentation for a list of accepted values.
            Defaults to `&#39;bone&#39;`.
        color : str or tuple, optional
            Color of the vector field when `colorbar` is `False`. It must be a
            valid Matplotlib color. Defaults to `None`, in which case a default
            color is used.
        density : float, optional
            Density of the stream lines in the plot. Defaults to 1.5.
        **kwargs
            Keyword arguments passed to [`matplotlib.axes.Axes.streamplot`](
            https://31c8.short.gy/ax-streamplot)
        &#34;&#34;&#34;
        self._check_if_activated()
        X, Y, dX, dY = self._get_arrows(xlim, ylim, shape)
        if colorbar:
            color = np.sqrt(dX**2 + dY**2)
        strm = self.ax.streamplot(X, Y, dX, dY, color=color, cmap=cmap, 
                                  density=density, **kwargs)
        if colorbar:
            self.fig.colorbar(strm.lines, ax=self.ax)

    @staticmethod
    def _check_if_tuple_of_two_int(test_value):
        &#34;&#34;&#34;Check if `test_value` is a tuple of two int.&#34;&#34;&#34;
        msg = f&#39;{test_value} is not a tuple of non negative integers.&#39;
        if not isinstance(test_value, tuple):
            raise TypeError(msg)
        if len(test_value) != 2:
            raise ValueError(msg)
        if not all(isinstance(val, int) for val in test_value):
            raise ValueError(msg)
        if not all(val &gt;= 0 for val in test_value):
            raise ValueError(msg)

    def _get_arrows(self, xlim, ylim, shape):
        &#34;&#34;&#34;Get the arrows to plot the vector field.&#34;&#34;&#34;
        x = np.linspace(xlim[0], xlim[1], shape[0])
        y = np.linspace(ylim[0], ylim[1], shape[1])
        X, Y = np.meshgrid(x, y)
        dX, dY = self._vector_field(X, Y, shape)
        return X, Y, dX, dY

    def _label(self, j, derivative=False):
        &#34;&#34;&#34;Get the label associated with the *j*th state component.&#34;&#34;&#34;
        p = len(self.config.network.populations)
        if p == 1:
            return f&#39;${self._label_one(j, derivative)}$&#39;
        return f&#39;${self._label_many(j, p, derivative)}$&#39;

    def _label_many(self, j, p, derivative):
        &#34;&#34;&#34;Get the *j*th component&#39;s label for *p* populations.&#34;&#34;&#34;
        dot = &#39;\\dot&#39; if derivative else &#39;&#39;
        if 0 &lt;= j &lt; 2*p:
            m = j % p
            X = &#39;A&#39; if m == j else &#39;R&#39;
            J = self.config.network.populations[m].ID
            return f&#39;{dot}{{\\mathcal{{{X}}}}}_{{{J}}}&#39;
        triangle_indices = [(m,n) for m in range(p) for n in range(m,p)]
        if 2*p &lt;= j &lt; round(2*p + p*(p+1)/2):
            m, n = triangle_indices[j - 2*p]
            X = Y = &#39;A&#39;
        elif round(2*p + p*(p+1)/2) &lt;= j &lt; 2*p + p*(p+1):
            m, n = triangle_indices[j - round(2*p + p*(p+1)/2)]
            X = Y = &#39;R&#39;
        elif 2*p + p*(p+1) &lt;= j &lt; p*(2*p+3):
            m, n = np.ndindex((p,p))[j - 2*p - p*(p+1)]
            X = &#39;A&#39;
            Y = &#39;R&#39;
        J = self.config.network.populations[m].ID
        K = self.config.network.populations[n].ID
        return f&#39;{dot}{{\\mathrm{{C}}}}_{{{X}{Y}}}^{{{J}{K}}}&#39;

    def _label_one(self, j, derivative):
        &#34;&#34;&#34;Get the *j*th component&#39;s label for one population.&#34;&#34;&#34;
        dot = &#39;\\dot&#39; if derivative else &#39;&#39;
        if j == 0:
            return f&#39;{dot}{{\\mathcal{{A}}}}&#39;
        elif j == 1:
            return f&#39;{dot}{{\\mathcal{{R}}}}&#39;
        elif j == 2:
            return f&#39;{dot}{{\\mathrm{{C}}}}_{{AA}}&#39;
        elif j == 3:
            return f&#39;{dot}{{\\mathrm{{C}}}}_{{RR}}&#39;
        elif j == 4:
            return f&#39;{dot}{{\\mathrm{{C}}}}_{{AR}}&#39;

    def _nullcline(self, Z, W, j, k):
        &#34;&#34;&#34;Get *j*-nullcline with `Z` and `W` as axes `j` and `k`.&#34;&#34;&#34;
        warn(&#39;For this dynamical system, the algorithm that determines the &#39;
             &#39;nullclines is still experimental. The results might not be &#39;
             &#39;accurate.&#39;, category=PopNetWarning, stacklevel=3)
        others = np.arange(self.system.dim)
        others = np.setdiff1d(others, np.array(self.axes))
        state_0 = np.zeros(self.system.dim)
        state_0[others] = self.fixed_axes
        null = {j: [], k: []}
        successes = {j: 0, k: 0}
        U = {j: Z, k: W}
        for m in [j,k]:
            n = k if m == j else j
            for u in U[m]:
                state = state_0.copy()
                state[m] = u
                def f(v):
                    state[n] = v
                    return self.system.vector_field(state)[j]
                opt = root(f,0)
                successes[m] += int(opt.success)
                null[m].append(opt.x)
        if successes[j] / len(Z) &gt; successes[k] / len(W):
            return Z, np.array(null[j])
        return np.array(null[k]), W

    def _nullcline_label(self, j):
        &#34;&#34;&#34;Label for the nullcline of the axis *j*.&#34;&#34;&#34;
        p = len(self.config.network.populations)
        if p == 1:
            return f&#39;${self._label_one(j, True)} = 0$&#39;
        return f&#39;${self._label_many(j, p, True)} = 0$&#39;

    def _run_experiment(self, executor, *args, **kwargs):
        &#34;&#34;&#34;Run an experiment and get the output on `self.axes` versus time.&#34;&#34;&#34;
        executor.run(*args, **kwargs)
        return executor.states[:,self.axes].transpose()

    def _vector_field(self, X, Y, shape):
        &#34;&#34;&#34;Vector field to plot.

        Vector field to plot to draw the phase plane, as a function of the
        independant variables arranged as a grid.
        &#34;&#34;&#34;
        state_list = []
        indep_to_app = X
        k = 0
        for j in range(n := self.system.dim):
            if j in self.axes:
                state_list.append(indep_to_app)
                indep_to_app = Y
                k += 1
            else:
                state_list.append(self.fixed_axes[j-k] * np.ones(shape))
        states = np.array(state_list, float)
        try:
            field = self.system.vector_field(states)
        except Exception:
            field = np.zeros((n,) + shape)
            for j, k in np.ndindex(shape):
                field[:,j,k] = self.system.vector_field(states[:,j,k])
        return field[self.axes[0]], field[self.axes[1]]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="popnet.graphics.Graphics" href="#popnet.graphics.Graphics">Graphics</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>popnet.graphics._PhasePlaneMeanField</li>
<li>popnet.graphics._PhasePlaneWilsonCowan</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="popnet.graphics.PhasePlane.axes"><code class="name">var <span class="ident">axes</span></code></dt>
<dd>
<div class="desc"><p>Components chosen as independant variables for the phase plane.</p>
<p>It must be a tuple of two integers corresponding to valid axes of the
dynamical system. It cannot be deleted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def axes(self):
    &#34;&#34;&#34;Components chosen as independant variables for the phase plane.
    
    It must be a tuple of two integers corresponding to valid axes of the
    dynamical system. It cannot be deleted.
    &#34;&#34;&#34;
    return self._axes</code></pre>
</details>
</dd>
<dt id="popnet.graphics.PhasePlane.fixed_axes"><code class="name">var <span class="ident">fixed_axes</span></code></dt>
<dd>
<div class="desc"><p>Fixed values for remaining state components.</p>
<p>Values given to state components other than those chosen as
independent. It is a one-dimensional array, or <code>None</code> if the whole
dynamical system is two-dimensional. </p>
<p>It can be set as a single float value, in which case this value is
given to all fixed axes. It cannot be deleted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def fixed_axes(self):
    &#34;&#34;&#34;Fixed values for remaining state components.

    Values given to state components other than those chosen as
    independent. It is a one-dimensional array, or `None` if the whole
    dynamical system is two-dimensional. 

    It can be set as a single float value, in which case this value is
    given to all fixed axes. It cannot be deleted.
    &#34;&#34;&#34;
    return self._fixed_axes</code></pre>
</details>
</dd>
<dt id="popnet.graphics.PhasePlane.system"><code class="name">var <span class="ident">system</span></code></dt>
<dd>
<div class="desc"><p>Dynamical system for which to draw a phase plane.</p>
<p>Dynamical system for which a phase plane is to be drawn. It must be
a <code><a title="popnet.systems.DynamicalSystem" href="systems.html#popnet.systems.DynamicalSystem">DynamicalSystem</a></code> instance. It is set at
initialization, and afterwards it cannot be manually set nor deleted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def system(self):
    &#34;&#34;&#34;Dynamical system for which to draw a phase plane.

    Dynamical system for which a phase plane is to be drawn. It must be
    a `popnet.systems.DynamicalSystem` instance. It is set at
    initialization, and afterwards it cannot be manually set nor deleted.
    &#34;&#34;&#34;
    return self._system</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="popnet.graphics.PhasePlane.legend"><code class="name flex">
<span>def <span class="ident">legend</span></span>(<span>self, lw=2, fontsize=10, ncol=1, handletextpad=0.5, framealpha=1, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a legend for the figure.</p>
<p>Generate a legend for the figure with default options. Same as the base
class method <code><a title="popnet.graphics.Graphics.legend" href="#popnet.graphics.Graphics.legend">Graphics.legend()</a></code>, but changes the defaults for <code>ncol</code> and
<code>framealpha</code> to 1.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def legend(self, lw=2, fontsize=10, ncol=1, handletextpad=0.5, 
           framealpha=1, **kwargs):
    &#34;&#34;&#34;Generate a legend for the figure.

    Generate a legend for the figure with default options. Same as the base
    class method `Graphics.legend`, but changes the defaults for `ncol` and
    `framealpha` to 1.
    &#34;&#34;&#34;
    return super().legend(lw=lw, fontsize=fontsize, ncol=ncol, 
                          handletextpad=handletextpad,
                          framealpha=framealpha, **kwargs)</code></pre>
</details>
</dd>
<dt id="popnet.graphics.PhasePlane.plot_nullclines"><code class="name flex">
<span>def <span class="ident">plot_nullclines</span></span>(<span>self, which='both', num=1000, xcolor=None, ycolor=None, xlim=(0, 1), ylim=(0, 1), **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot nullclines on the phase plane.</p>
<p>Plot nullclines for independent variables on the phase plane. This
method is mostly intended to be used with the Wilson&ndash;Cowan system,
with its extension with refractory state, or with the 'mixed' system
that makes a transition between the first two. Indeed, with these
systems nullclines can be computed easily.</p>
<p>For dynamical systems that include covariances, nullclines are computed
numerically using <a href="https://31c8.short.gy/scipy-optimize-root"><code>root</code></a>
from SciPy's <code>optimize</code> module. However, this feature is still
experimental, and could lead to unaccurate or unexpected results. A
warning is issued when this method is used in such a case.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>which</code></strong> :&ensp;<code>{'x', 'y', 'both'}</code>, optional</dt>
<dd>Which nullcline to plot. Defaults to <code>'both'</code>.</dd>
<dt><strong><code>num</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of points on nullclines. Defaults to 1000.</dd>
<dt><strong><code>xcolor</code></strong>, <strong><code>ycolor</code></strong> :&ensp;<code>string</code> or <code>tuple</code>, optional</dt>
<dd>Colors given to nullclines. <code>zcolor</code> is the color for the nullcline
where the component drawn on axis <em>z</em> does not vary. They must be
valid Matplotlib colors. Both default to <code>None</code>, in which case
default colors are used.</dd>
<dt><strong><code>xlim</code></strong>, <strong><code>ylim</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>Limits of the horizontal and vertical axis, respectively. Both
default to (0,1).</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments to be passed to the
<a href="https://31c8.short.gy/ax-plot"><code>plot</code></a> method of <code><a title="popnet.graphics.PhasePlane.ax" href="#popnet.graphics.Graphics.ax">PhasePlane.ax</a></code>,
which actually plots the nullclines.</dd>
</dl>
<h2 id="warns">Warns</h2>
<dl>
<dt><code><a title="popnet.exceptions.PopNetWarning" href="exceptions.html#popnet.exceptions.PopNetWarning">PopNetWarning</a></code></dt>
<dd>If nullclines are computed numerically with the experimental
algorithm.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_nullclines(self, which=&#39;both&#39;, num=1000, xcolor=None, ycolor=None,
                    xlim=(0,1), ylim=(0,1), **kwargs):
    &#34;&#34;&#34;Plot nullclines on the phase plane.

    Plot nullclines for independent variables on the phase plane. This
    method is mostly intended to be used with the Wilson--Cowan system,
    with its extension with refractory state, or with the &#39;mixed&#39; system
    that makes a transition between the first two. Indeed, with these
    systems nullclines can be computed easily.

    For dynamical systems that include covariances, nullclines are computed
    numerically using [`root`](https://31c8.short.gy/scipy-optimize-root)
    from SciPy&#39;s `optimize` module. However, this feature is still
    experimental, and could lead to unaccurate or unexpected results. A
    warning is issued when this method is used in such a case.

    Parameters
    ----------
    which : {&#39;x&#39;, &#39;y&#39;, &#39;both&#39;}, optional
        Which nullcline to plot. Defaults to `&#39;both&#39;`.
    num : int, optional
        Number of points on nullclines. Defaults to 1000.
    xcolor, ycolor : string or tuple, optional
        Colors given to nullclines. `zcolor` is the color for the nullcline
        where the component drawn on axis *z* does not vary. They must be
        valid Matplotlib colors. Both default to `None`, in which case
        default colors are used.
    xlim, ylim : tuple, optional
        Limits of the horizontal and vertical axis, respectively. Both
        default to (0,1).
    **kwargs
        Keyword arguments to be passed to the
        [`plot`](https://31c8.short.gy/ax-plot) method of `PhasePlane.ax`,
        which actually plots the nullclines.

    Warns
    -----
    popnet.exceptions.PopNetWarning
        If nullclines are computed numerically with the experimental
        algorithm.
    &#34;&#34;&#34;
    if which not in (valid_values := (&#39;x&#39;, &#39;y&#39;, &#39;both&#39;)):
        warn(f&#39;Unexpected value {which} for \&#39;which\&#39;. Valid values are &#39;
             f&#39;{valid_values}. No nullclines will be plotted.&#39;,
             stacklevel=2, category=PopNetWarning)
    plot = {&#39;x&#39;: True if which in (&#39;x&#39;, &#39;both&#39;) else False,
            &#39;y&#39;: True if which in (&#39;y&#39;, &#39;both&#39;) else False}
    x = np.linspace(xlim[0], xlim[1], num)
    y = np.linspace(ylim[0], ylim[1], num)
    if plot[&#39;x&#39;]:
        x1, y1 = self._nullcline(x, y, self.axes[0], self.axes[1])
        self.ax.plot(x1, y1, color=xcolor,
                     label=self._nullcline_label(self.axes[0]))
    if plot[&#39;y&#39;]:
        y2, x2 = self._nullcline(y, x, self.axes[1], self.axes[0])
        self.ax.plot(x2, y2, color=ycolor,
                     label=self._nullcline_label(self.axes[1]))</code></pre>
</details>
</dd>
<dt id="popnet.graphics.PhasePlane.plot_solution"><code class="name flex">
<span>def <span class="ident">plot_solution</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot a solution of the dynamical system on the phase plane.</p>
<p>Run a numerical integration, and plot the resulting solution on the
phase plane.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to the
<a href="https://31c8.short.gy/ax-plot"><code>plot</code></a> method of <code><a title="popnet.graphics.PhasePlane.ax" href="#popnet.graphics.Graphics.ax">PhasePlane.ax</a></code>,
which actually plots the solution.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_solution(self, **kwargs):
    &#34;&#34;&#34;Plot a solution of the dynamical system on the phase plane.
    
    Run a numerical integration, and plot the resulting solution on the
    phase plane.

    Parameters
    ----------
    **kwargs
        Keyword arguments passed to the
        [`plot`](https://31c8.short.gy/ax-plot) method of `PhasePlane.ax`,
        which actually plots the solution.
    &#34;&#34;&#34;
    from .executors import get_integrator
    integrator = get_integrator(self.system)
    solution = self._run_experiment(integrator, &#39;ode&#39;)
    label = kwargs.pop(&#39;label&#39;, &#39;Solution&#39;)
    self.ax.plot(solution[0], solution[1], label=label, **kwargs)</code></pre>
</details>
</dd>
<dt id="popnet.graphics.PhasePlane.plot_trajectory"><code class="name flex">
<span>def <span class="ident">plot_trajectory</span></span>(<span>self, act='step', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot a trajectory of a stochastic process on the phase plane.</p>
<p>Run a simulation of a stochastic process, and plot the resulting
trajectory on the phase plane. The configuration used with the phase
plane must have a defined microscopic structure.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>act</code></strong> :&ensp;<code>{'step', 'sigmoid'}</code>, optional</dt>
<dd>Shape of neurons' activation rates for the simulation. If <code>'step'</code>,
a neuron's activation rate is a step function going from zero to
<code><a title="popnet.structures.MicroNetwork.alpha" href="structures.html#popnet.structures.MicroNetwork.alpha">MicroNetwork.alpha</a></code> at its threshold
<code><a title="popnet.structures.MicroNetwork.theta" href="structures.html#popnet.structures.MicroNetwork.theta">MicroNetwork.theta</a></code>. If <code>'sigmoid'</code>, a neuron's
activation rate is the logistic function
<code><a title="popnet.structures.Population.F" href="structures.html#popnet.structures.Population.F">Population.F()</a></code> of the population to which it
belongs. Defaults to <code>'step'</code>.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to the
<a href="https://31c8.short.gy/ax-plot"><code>plot</code></a> method of <code><a title="popnet.graphics.PhasePlane.ax" href="#popnet.graphics.Graphics.ax">PhasePlane.ax</a></code>,
which actually plots the trajectory.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_trajectory(self, act=&#39;step&#39;, **kwargs):
    &#34;&#34;&#34;Plot a trajectory of a stochastic process on the phase plane.

    Run a simulation of a stochastic process, and plot the resulting
    trajectory on the phase plane. The configuration used with the phase
    plane must have a defined microscopic structure.

    Parameters
    ----------
    act : {&#39;step&#39;, &#39;sigmoid&#39;}, optional
        Shape of neurons&#39; activation rates for the simulation. If `&#39;step&#39;`,
        a neuron&#39;s activation rate is a step function going from zero to
        `popnet.structures.MicroNetwork.alpha` at its threshold
        `popnet.structures.MicroNetwork.theta`. If `&#39;sigmoid&#39;`, a neuron&#39;s
        activation rate is the logistic function
        `popnet.structures.Population.F` of the population to which it
        belongs. Defaults to `&#39;step&#39;`.
    **kwargs
        Keyword arguments passed to the
        [`plot`](https://31c8.short.gy/ax-plot) method of `PhasePlane.ax`,
        which actually plots the trajectory.
    &#34;&#34;&#34;
    from .executors import get_simulator
    simulator = get_simulator(self.config, act=act, mode=&#39;individual&#39;)
    trajectory = self._run_experiment(simulator)
    label = kwargs.pop(&#39;label&#39;, &#39;Trajectory&#39;)
    self.ax.plot(trajectory[0], trajectory[1], label=label, **kwargs)</code></pre>
</details>
</dd>
<dt id="popnet.graphics.PhasePlane.quiver"><code class="name flex">
<span>def <span class="ident">quiver</span></span>(<span>self, shape, xlim=(0, 1), ylim=(0, 1), **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Draw the vector field on the initialized figure.</p>
<p>Draw the vector field on the figure <code><a title="popnet.graphics.PhasePlane.fig" href="#popnet.graphics.Graphics.fig">PhasePlane.fig</a></code>. The field is
plotted as a 2D field of arrows with
<a href="https://31c8.short.gy/ax-quiver"><code>matplotlib.axes.Axes.quiver</code></a>
on the axes <code><a title="popnet.graphics.PhasePlane.ax" href="#popnet.graphics.Graphics.ax">PhasePlane.ax</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>shape</code></strong> :&ensp;<code>tuple</code> of <code>int</code></dt>
<dd>Shape of the grid on which to plot the vector field.</dd>
<dt><strong><code>xlim</code></strong>, <strong><code>ylim</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>Limits of the horizontal and vertical axis, respectively. Both
default to (0,1).</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to
<a href="https://31c8.short.gy/ax-quiver"><code>matplotlib.axes.Axes.quiver</code></a></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def quiver(self, shape, xlim=(0,1), ylim=(0,1), **kwargs):
    &#34;&#34;&#34;Draw the vector field on the initialized figure.

    Draw the vector field on the figure `PhasePlane.fig`. The field is
    plotted as a 2D field of arrows with
    [`matplotlib.axes.Axes.quiver`](https://31c8.short.gy/ax-quiver)
    on the axes `PhasePlane.ax`.

    Parameters
    ----------
    shape : tuple of int
        Shape of the grid on which to plot the vector field.
    xlim, ylim : tuple, optional
        Limits of the horizontal and vertical axis, respectively. Both
        default to (0,1).
    **kwargs
        Keyword arguments passed to
        [`matplotlib.axes.Axes.quiver`](https://31c8.short.gy/ax-quiver)
    &#34;&#34;&#34;
    self._check_if_activated()
    X, Y, dX, dY = self._get_arrows(xlim, ylim, shape)
    self.ax.quiver(X, Y, dX, dY, **kwargs)</code></pre>
</details>
</dd>
<dt id="popnet.graphics.PhasePlane.setup"><code class="name flex">
<span>def <span class="ident">setup</span></span>(<span>self, xlim=(0, 1), ylim=(0, 1), fontsize=10, aspect='auto')</span>
</code></dt>
<dd>
<div class="desc"><p>Setup the figure.</p>
<p>Setup the figure <code><a title="popnet.graphics.PhasePlane.fig" href="#popnet.graphics.Graphics.fig">PhasePlane.fig</a></code>. Allows to set limits to both axes,
to choose a font size for labels, and to set the aspect ratio of the
axes.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>xlim</code></strong>, <strong><code>ylim</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>Limits of the horizontal and vertical axis, respectively. Both
default to (0,1).</dd>
<dt><strong><code>fontsize</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Fontsize of the axes' labels. Defaults to 10.</dd>
<dt><strong><code>aspect</code></strong> :&ensp;<code>{'auto', 'equal'}</code> or <code>float</code>, optional</dt>
<dd>Aspect ratio of the axis scaling. If <code>'auto'</code>, the plot fills
the available area, if <code>'equal'</code>, the scaling is the same for
both axes, and if a float, a square would be stretched such that
its height is <code>aspect</code> times its width. Defaults to <code>'auto'</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup(self, xlim=(0,1), ylim=(0,1), fontsize=10, aspect=&#39;auto&#39;):
    &#34;&#34;&#34;Setup the figure.

    Setup the figure `PhasePlane.fig`. Allows to set limits to both axes,
    to choose a font size for labels, and to set the aspect ratio of the
    axes.

    Parameters
    ----------
    xlim, ylim : tuple, optional
        Limits of the horizontal and vertical axis, respectively. Both
        default to (0,1).
    fontsize : float, optional
        Fontsize of the axes&#39; labels. Defaults to 10.
    aspect : {&#39;auto&#39;, &#39;equal&#39;} or float, optional
        Aspect ratio of the axis scaling. If `&#39;auto&#39;`, the plot fills
        the available area, if `&#39;equal&#39;`, the scaling is the same for
        both axes, and if a float, a square would be stretched such that
        its height is `aspect` times its width. Defaults to `&#39;auto&#39;`.
    &#34;&#34;&#34;
    self.ax.set_xlim(xlim)
    self.ax.set_ylim(ylim)
    self.ax.set_xlabel(self._label(self.axes[0]), fontsize=fontsize)
    self.ax.set_ylabel(self._label(self.axes[1]), fontsize=fontsize, 
                       rotation=0)
    self.ax.axes.set_aspect(aspect)</code></pre>
</details>
</dd>
<dt id="popnet.graphics.PhasePlane.streamplot"><code class="name flex">
<span>def <span class="ident">streamplot</span></span>(<span>self, shape, xlim=(0, 1), ylim=(0, 1), colorbar=False, cmap='bone', color=None, density=1.5, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Draw the vector field on the initialized figure.</p>
<p>Draw the vector field on the figure <code><a title="popnet.graphics.PhasePlane.fig" href="#popnet.graphics.Graphics.fig">PhasePlane.fig</a></code>. The field is
plotted as streamlines with
<a href="https://31c8.short.gy/ax-streamplot"><code>matplotlib.axes.Axes.streamplot</code></a>
on the axes <code><a title="popnet.graphics.PhasePlane.ax" href="#popnet.graphics.Graphics.ax">PhasePlane.ax</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>shape</code></strong> :&ensp;<code>tuple</code> of <code>int</code></dt>
<dd>Shape of the grid on which to plot the vector field.</dd>
<dt><strong><code>xlim</code></strong>, <strong><code>ylim</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>Limits of the horizontal and vertical axis, respectively. Both
default to (0,1).</dd>
<dt><strong><code>colorbar</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If <code>True</code>, a colorbar is added on the phase plane, where the color
represents the euclidean norm of the derivative. Defaults to
<code>False</code>.</dd>
<dt><strong><code>cmap</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Colormap for the vector field when <code>colorbar</code> is <code>True</code>. See
<a href="https://31c8.short.gy/mpl-colormap">this page</a>
of Matplotlib's documentation for a list of accepted values.
Defaults to <code>'bone'</code>.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code> or <code>tuple</code>, optional</dt>
<dd>Color of the vector field when <code>colorbar</code> is <code>False</code>. It must be a
valid Matplotlib color. Defaults to <code>None</code>, in which case a default
color is used.</dd>
<dt><strong><code>density</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Density of the stream lines in the plot. Defaults to 1.5.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed to <a href="https://31c8.short.gy/ax-streamplot"><code>matplotlib.axes.Axes.streamplot</code></a></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def streamplot(self, shape, xlim=(0,1), ylim=(0,1), colorbar=False, 
               cmap=&#39;bone&#39;, color=None, density=1.5, **kwargs):
    &#34;&#34;&#34;Draw the vector field on the initialized figure.

    Draw the vector field on the figure `PhasePlane.fig`. The field is
    plotted as streamlines with
    [`matplotlib.axes.Axes.streamplot`](https://31c8.short.gy/ax-streamplot)
    on the axes `PhasePlane.ax`.

    Parameters
    ----------
    shape : tuple of int
        Shape of the grid on which to plot the vector field.
    xlim, ylim : tuple, optional
        Limits of the horizontal and vertical axis, respectively. Both
        default to (0,1).
    colorbar : bool, optional
        If `True`, a colorbar is added on the phase plane, where the color
        represents the euclidean norm of the derivative. Defaults to
        `False`.
    cmap : str, optional
        Colormap for the vector field when `colorbar` is `True`. See
        [this page](https://31c8.short.gy/mpl-colormap)
        of Matplotlib&#39;s documentation for a list of accepted values.
        Defaults to `&#39;bone&#39;`.
    color : str or tuple, optional
        Color of the vector field when `colorbar` is `False`. It must be a
        valid Matplotlib color. Defaults to `None`, in which case a default
        color is used.
    density : float, optional
        Density of the stream lines in the plot. Defaults to 1.5.
    **kwargs
        Keyword arguments passed to [`matplotlib.axes.Axes.streamplot`](
        https://31c8.short.gy/ax-streamplot)
    &#34;&#34;&#34;
    self._check_if_activated()
    X, Y, dX, dY = self._get_arrows(xlim, ylim, shape)
    if colorbar:
        color = np.sqrt(dX**2 + dY**2)
    strm = self.ax.streamplot(X, Y, dX, dY, color=color, cmap=cmap, 
                              density=density, **kwargs)
    if colorbar:
        self.fig.colorbar(strm.lines, ax=self.ax)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="popnet.graphics.Graphics" href="#popnet.graphics.Graphics">Graphics</a></b></code>:
<ul class="hlist">
<li><code><a title="popnet.graphics.Graphics.activate" href="#popnet.graphics.Graphics.activate">activate</a></code></li>
<li><code><a title="popnet.graphics.Graphics.ax" href="#popnet.graphics.Graphics.ax">ax</a></code></li>
<li><code><a title="popnet.graphics.Graphics.config" href="#popnet.graphics.Graphics.config">config</a></code></li>
<li><code><a title="popnet.graphics.Graphics.default_name" href="#popnet.graphics.Graphics.default_name">default_name</a></code></li>
<li><code><a title="popnet.graphics.Graphics.draw" href="#popnet.graphics.Graphics.draw">draw</a></code></li>
<li><code><a title="popnet.graphics.Graphics.fig" href="#popnet.graphics.Graphics.fig">fig</a></code></li>
<li><code><a title="popnet.graphics.Graphics.name" href="#popnet.graphics.Graphics.name">name</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="popnet.graphics.Result"><code class="flex name class">
<span>class <span class="ident">Result</span></span>
<span>(</span><span>config, states, times, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Results generated using PopNet executors.</p>
<p>The purpose of <code><a title="popnet.graphics.Result" href="#popnet.graphics.Result">Result</a></code> is to handle easily the outputs of numerical
experiments performed by PopNet. The class <code><a title="popnet.graphics.Result" href="#popnet.graphics.Result">Result</a></code> has several methods,
listed in the <a href="#result-methods">Methods</a> section below, to create and setup
a <a href="https://matplotlib.org/">Matplotlib</a> figure with predefined formatting,
allowing to easily produce many figures in a consistent format. </p>
<p>Although some features would be available with the <code><a title="popnet.graphics.Result" href="#popnet.graphics.Result">Result</a></code> class alone,
it is not inteded to be used by itself, but rather through its subclasses
<code><a title="popnet.graphics.Solution" href="#popnet.graphics.Solution">Solution</a></code>, <code><a title="popnet.graphics.ExtendedSolution" href="#popnet.graphics.ExtendedSolution">ExtendedSolution</a></code>, <code><a title="popnet.graphics.Trajectory" href="#popnet.graphics.Trajectory">Trajectory</a></code>, <code><a title="popnet.graphics.Statistics" href="#popnet.graphics.Statistics">Statistics</a></code> and <code><a title="popnet.graphics.Spectrum" href="#popnet.graphics.Spectrum">Spectrum</a></code>.
Each one of these subclasses implements other features specific to a given
result case.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>config</code></strong> :&ensp;<code><a title="popnet.structures.Configuration" href="structures.html#popnet.structures.Configuration">Configuration</a></code></dt>
<dd>Configuration used to obtain the result.</dd>
<dt><strong><code>states</code></strong> :&ensp;<code>array_like</code></dt>
<dd>State of the network with respect to time.</dd>
<dt><strong><code>times</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Time.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>A name associated with the result. Defaults to <code>None</code>, in which case it
is replaced with <code><a title="popnet.graphics.Result.default_name" href="#popnet.graphics.Graphics.default_name">Result.default_name</a></code>.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>config</code></strong> :&ensp;<code><a title="popnet.structures.Configuration" href="structures.html#popnet.structures.Configuration">Configuration</a></code></dt>
<dd>Configuration used to obtain the result. See <code><a title="popnet.graphics.Result.config" href="#popnet.graphics.Graphics.config">Result.config</a></code>.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name associated with the result. See <code><a title="popnet.graphics.Result.name" href="#popnet.graphics.Graphics.name">Result.name</a></code>.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>matplotlib.figure.Figure</code></dt>
<dd>A Matplotlib figure. See <code><a title="popnet.graphics.Result.fig" href="#popnet.graphics.Graphics.fig">Result.fig</a></code>.</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib.axes.Axes</code></dt>
<dd>Axes of <code>fig</code>. See <code><a title="popnet.graphics.Result.ax" href="#popnet.graphics.Graphics.ax">Result.ax</a></code>.</dd>
<dt><strong><code>times</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Time.</dd>
<dt><strong><code>colors</code></strong> :&ensp;<code>dict</code></dt>
<dd>Colors for each state variable associated with the result. See
<code><a title="popnet.graphics.Result.colors" href="#popnet.graphics.Result.colors">Result.colors</a></code>.</dd>
<dt><strong><code>plot</code></strong> :&ensp;<code>dict</code></dt>
<dd>Plotting methods for each state variable associated with the result.
See <code><a title="popnet.graphics.Result.plot" href="#popnet.graphics.Result.plot">Result.plot</a></code>.</dd>
<dt><strong><code>A</code></strong>, <strong><code>R</code></strong>, <strong><code>S</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Vectors of state variables with respect to time.</dd>
<dt><strong><code>CAA</code></strong>, <strong><code>CRR</code></strong>, <strong><code>CSS</code></strong>, <strong><code>CAR</code></strong>, <strong><code>CAS</code></strong>, <strong><code>CRS</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Covariance matrices between state variables with respect to time, or
<code>None</code> if no such covariances are defined for a <code><a title="popnet.graphics.Result" href="#popnet.graphics.Result">Result</a></code> subclass.</dd>
</dl>
<h2 id="result-methods">Methods</h2>
<ul>
<li><code><a title="popnet.graphics.Result.activate" href="#popnet.graphics.Graphics.activate">Graphics.activate()</a></code> :
Activate a Matplotlib figure.</li>
<li><code><a title="popnet.graphics.Result.legend" href="#popnet.graphics.Graphics.legend">Graphics.legend()</a></code> :
Make a legend for the figure.</li>
<li><code><a title="popnet.graphics.Result.setup" href="#popnet.graphics.Result.setup">Result.setup()</a></code> :
Setup the axes of the figure.</li>
<li><code><a title="popnet.graphics.Result.draw" href="#popnet.graphics.Graphics.draw">Graphics.draw()</a></code> :
Draw the figure and show it or save it.</li>
</ul>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>config</code> is not a <code><a title="popnet.structures.Configuration" href="structures.html#popnet.structures.Configuration">Configuration</a></code> instance.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Some additional remarks should be made regarding the implementation, in
case <code><a title="popnet.graphics.Result" href="#popnet.graphics.Result">Result</a></code> would have to be subclassed. Everything discussed here is
considered to be implementation details, and should not be useful from a
user perspective.</p>
<p>The class <code><a title="popnet.graphics.Result" href="#popnet.graphics.Result">Result</a></code> itself is in fact intended to handle directly only the
case where the network used in the configuration has more than one
population. The one population case is internally handled by a private
subclass <code>_ResultOne</code>, which is responsible to modify the state components
attributes and the methods of the <code>plot</code> dictionary, to change them from
one-element lists to the elements themselves. The same pattern is followed
in <code><a title="popnet.graphics.Result" href="#popnet.graphics.Result">Result</a></code> subclasses: each one has a private subclass with the same name
but with a suffix 'One'.</p>
<p>When creating a new <code><a title="popnet.graphics.Result" href="#popnet.graphics.Result">Result</a></code> instance, the constructor internally checks
the number of populations of the network, and if this number is one, then
the constructor looks in the <code>graphics</code> module for a private class of the
same name suffixed with 'One', and rather instantiates this class if it
exists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Result(Graphics):
    &#34;&#34;&#34;Results generated using PopNet executors.

    The purpose of `Result` is to handle easily the outputs of numerical
    experiments performed by PopNet. The class `Result` has several methods,
    listed in the [Methods](#result-methods) section below, to create and setup
    a [Matplotlib](https://matplotlib.org/) figure with predefined formatting,
    allowing to easily produce many figures in a consistent format. 

    Although some features would be available with the `Result` class alone,
    it is not inteded to be used by itself, but rather through its subclasses
    `Solution`, `ExtendedSolution`, `Trajectory`, `Statistics` and `Spectrum`.
    Each one of these subclasses implements other features specific to a given
    result case.

    Parameters
    ----------
    config : popnet.structures.Configuration
        Configuration used to obtain the result.
    states : array_like
        State of the network with respect to time.
    times : array_like
        Time.
    name : str, optional
        A name associated with the result. Defaults to `None`, in which case it
        is replaced with `Result.default_name`.

    Attributes
    ----------
    config : popnet.structures.Configuration
        Configuration used to obtain the result. See `Result.config`.
    name : str
        Name associated with the result. See `Result.name`.
    fig : matplotlib.figure.Figure
        A Matplotlib figure. See `Result.fig`.
    ax : matplotlib.axes.Axes
        Axes of `fig`. See `Result.ax`.
    times : array_like
        Time.
    colors : dict
        Colors for each state variable associated with the result. See
        `Result.colors`.
    plot : dict
        Plotting methods for each state variable associated with the result.
        See `Result.plot`.
    A, R, S : array_like
        Vectors of state variables with respect to time.
    CAA, CRR, CSS, CAR, CAS, CRS : array_like
        Covariance matrices between state variables with respect to time, or
        `None` if no such covariances are defined for a `Result` subclass.

    Methods {#result-methods}
    -------
     - `Result.activate` :
        Activate a Matplotlib figure.
     - `Result.legend` :
        Make a legend for the figure.
     - `Result.setup` :
        Setup the axes of the figure.
     - `Result.draw` :
        Draw the figure and show it or save it.

    Raises
    ------
    TypeError
        If `config` is not a `popnet.structures.Configuration` instance.

    Notes
    -----
    Some additional remarks should be made regarding the implementation, in
    case `Result` would have to be subclassed. Everything discussed here is
    considered to be implementation details, and should not be useful from a
    user perspective.

    The class `Result` itself is in fact intended to handle directly only the
    case where the network used in the configuration has more than one
    population. The one population case is internally handled by a private
    subclass `_ResultOne`, which is responsible to modify the state components
    attributes and the methods of the `plot` dictionary, to change them from
    one-element lists to the elements themselves. The same pattern is followed
    in `Result` subclasses: each one has a private subclass with the same name
    but with a suffix &#39;One&#39;.

    When creating a new `Result` instance, the constructor internally checks
    the number of populations of the network, and if this number is one, then
    the constructor looks in the `graphics` module for a private class of the
    same name suffixed with &#39;One&#39;, and rather instantiates this class if it
    exists.

    &#34;&#34;&#34;

    default_name = &#39;Result&#39;
    &#34;&#34;&#34;Default name given to instances.&#34;&#34;&#34;
    x_units = &#39;Time&#39;
    &#34;&#34;&#34;Units of the horizontal axis. The default is `&#39;Time&#39;`.&#34;&#34;&#34;
    _lim_valid_values = {&#39;x&#39;: (&#39;time&#39;, &#39;config&#39;, &#39;unbounded&#39;), 
                         &#39;y&#39;: (&#39;fractions&#39;, &#39;covariances&#39;, &#39;unbounded&#39;)}

    def __init__(self, config, states, times, name=None):
        super().__init__(config, name=name)
        self._init_abscissa(times)
        self._init_states_dict(states)
        self._init_colors()
        self._init_plot_methods()

    def __new__(cls, config, states, times, name=None):
        if not isinstance(config, structures.Configuration):
            raise TypeError(&#39;The configuration used with a \&#39;Result\&#39; &#39;
                            &#39;instance must be a \&#39;Configuration\&#39; instance.&#39;)
        if len(config.network.populations) == 1:
            prefix = &#39;&#39; if cls.__name__.startswith(&#39;_&#39;) else &#39;_&#39;
            suffix = &#39;&#39; if cls.__name__.endswith(&#39;One&#39;) else &#39;One&#39;
            try:
                one_pop_class = globals()[f&#39;{prefix}{cls.__name__}{suffix}&#39;]
            except KeyError:
                pass
            else:
                return super().__new__(one_pop_class)
        return super().__new__(cls)

    @classmethod
    def load(cls, ID, name=None, config=None, times=None, folder=None):
        &#34;&#34;&#34;Load the result associated with the ID.

        Load the result obtained when using the configuration of ID `ID`. The
        array representing the state of the network with respect to time is
        expected to be in a file named *ID - name.txt*, where *ID* and *name*
        are indeed `ID` and `name`. 

        Parameters
        ----------
        ID : str
            ID of the configuration used to obtain this result. 
        name : str, optional
            Name associated with the result. Defaults to `None`, in which case
            it is replaced with the name of the class.
        config : popnet.structures.Configuration, optional
            Configuration to associate with the result. If given, it must have
            the ID `ID`. Defaults to `None`, in which case it is loaded with
            `popnet.structures.load_config`, using the same ID.
        times : array_like, optional
            Times array to associate with the result. Defaults to `None`, in
            which case it is computed from the configuration.
        folder : str, optional
            Folder in which the file is located, which should be placed in the
            current directory. Defaults to `None`, in which case the file is
            assumed to be located in the current directory.

        Returns
        -------
        Result
            The loaded result. 

        Raises
        ------
        TypeError
            If `config` is neither `None` nor a
            `popnet.structures.Configuration` instance.
        popnet.exceptions.PopNetError
            If `config` has a different ID than `ID`. 
        FileNotFoundError
            If no file is found with the expected name.
        &#34;&#34;&#34;
        config = cls._check_config(config, ID)
        if times is None:
            times = np.linspace(config.initial_time, config.final_time,
                                1 + config.iterations)
        name = cls._get_name(name)
        filename = _internals._format_filename(folder, ID, name)
        try:
            states = np.loadtxt(filename, dtype=float, ndmin=2)
        except FileNotFoundError as error:
            raise FileNotFoundError(
                    f&#39;No result found for configuration {ID}.&#39;) from error
        return cls(config, states, times, name)

    @property
    def times(self):
        &#34;&#34;&#34;Time.

        An array representing time. It is the independant variable with respect
        to which state components are given. It cannot be set nor deleted.
        &#34;&#34;&#34;
        return self._times

    @property
    def colors(self):
        &#34;&#34;&#34;Colors associated with the result&#39;s components.

        Colors associated with the result&#39;s components, to be used in figures.
        It is a dictionary whose keys are strings representing possible
        components, and whose values are lists (or lists of lists) of valid
        Matplotlib colors associated with each population (or pair of
        populations). For example, `result.colors[&#39;A&#39;][J]` is the color
        associated with the activity of the *J*th population of the network for
        the result `result`. By default, in the case of a single population,
        a new color can be assigned as is, and it is automatically placed in a
        list (containing only the given color). It cannot be deleted.
        &#34;&#34;&#34;
        return self._colors

    @colors.setter
    def colors(self, new_colors):
        if not isinstance(new_colors, dict):
            raise TypeError(&#39;The colors passed to a \&#39;Result\&#39; instance must &#39;
                            &#39;be stored in a dictionary.&#39;)
        self._colors = new_colors

    @property
    def plot(self):
        &#34;&#34;&#34;Dictionary of methods to plot state variables.

        If *X* denotes a state variable (that is, either *A*, *R* or *S*), then
        `plot[&#39;X&#39;]` is a list whose *J*th element is a method that plots
        \\(X^J\\) (or its expectation, depending on the
        result) with respect to time. Similarly, if covariances are defined for
        this result, then `plot[&#39;CXY&#39;][J][K]` is a method which plots the
        covariances between \\(X^J\\) and \\(Y^K\\) with respect to time. A
        similar pattern works for third central moments as well if applicable,
        with keys of the form `&#39;XYZ&#39;`.

        In the case where the network has only one population, the lists are
        all replaced with the single element they would contain. For example,
        `plot[&#39;A&#39;]` is directly a method to plot the network&#39;s activity, that
        is, the activity of the single population of the network. In the same
        way, `plot[&#39;CRR&#39;]` is a method to plot the variance of the refractory
        fraction of the network.

        When called, these methods plot the corresponding state components with
        respect to time on the axes `Result.ax` of the figure `Result.fig`. They
        all accept keyword arguments that can be passed to the
        [`plot`](https://31c8.short.gy/ax-plot) method of `Result.ax`. This
        attribute cannot be set nor deleted.
        &#34;&#34;&#34;
        return self._plot

    @property
    def A(self):
        &#34;&#34;&#34;Active fractions of populations.

        List of active fractions of populations (or their expectations,
        depending on the result) as arrays indexed with respect to time. If
        the network has only one population, it is not a list, but directly the
        array giving the active fraction of the network with respect to time.

        It cannot be set nor deleted.
        &#34;&#34;&#34;
        return self._states_dict[&#39;A&#39;]

    @property
    def R(self):
        &#34;&#34;&#34;Refractory fractions of populations.

        List of refractory fractions of populations (or their expectations,
        depending on the result) as arrays indexed with respect to time. If
        the network has only one population, it is not a list, but directly the
        array giving the refractory fraction of the network with respect to
        time.

        It cannot be set nor deleted.
        &#34;&#34;&#34;
        return self._states_dict[&#39;R&#39;]

    @property
    def S(self):
        &#34;&#34;&#34;Sensitive fractions of population.

        List of sensitive fractions of populations (or their expectations,
        depending on the result) as arrays indexed with respect to time. If
        the network has only one population, it is not a list, but directly the
        array giving the sensitive fraction of the network with respect to time.

        It cannot be set nor deleted.
        &#34;&#34;&#34;
        return self._states_dict[&#39;S&#39;]

    @property
    def CAA(self):
        &#34;&#34;&#34;Covariances between active fractions of populations.

        Matrix (as a list of lists) of covariances between active fractions of
        populations with respect to time, or `None` if no such matrix is
        defined. If the network has only one population, it is not a list of
        lists, but directly the variance of the active fraction of the network.

        It cannot be set nor deleted. 
        &#34;&#34;&#34;
        try:
            return self._states_dict[&#39;CAA&#39;]
        except KeyError:
            pass

    @property
    def CRR(self):
        &#34;&#34;&#34;Covariances between refractory fractions of populations.

        Matrix (as a list of lists) of covariances between refractory fractions
        of populations with respect to time, or `None` if no such matrix is
        defined. If the network has only one population, it is not a list of
        lists, but directly the variance of the refractory fraction of the
        network.

        It cannot be set nor deleted. 
        &#34;&#34;&#34;
        try:
            return self._states_dict[&#39;CRR&#39;]
        except KeyError:
            pass

    @property
    def CSS(self):
        &#34;&#34;&#34;Covariances between sensitive fractions of populations.

        Matrix (as a list of lists) of covariances between sensitive fractions
        of populations with respect to time, or `None` if no such matrix is
        defined. If the network has only one population, it is not a list of
        lists, but directly the variance of the sensitive fraction of the
        network.

        It cannot be set nor deleted. 
        &#34;&#34;&#34;
        try:
            return self._states_dict[&#39;CSS&#39;]
        except KeyError:
            pass

    @property
    def CAR(self):
        &#34;&#34;&#34;Covariances between active and refractory fractions of populations.

        Matrix (as a list of lists) of covariances between active and refractory
        fractions of populations with respect to time, or `None` if no such
        matrix is defined. If the network has only one population, it is not a
        list of lists, but directly the covariance between the active and
        refractory fractions of the network.

        It cannot be set nor deleted.
        &#34;&#34;&#34;
        try:
            return self._states_dict[&#39;CAR&#39;]
        except KeyError:
            pass

    @property
    def CAS(self):
        &#34;&#34;&#34;Covariances between active and sensitive fractions of populations.

        Matrix (as a list of lists) of covariances between active and sensitive
        fractions of populations with respect to time, or `None` if no such
        matrix is defined. If the network has only one population, it is not a
        list of lists, but directly the covariance between the active and
        sensitive fractions of the network.

        It cannot be set nor deleted.
        &#34;&#34;&#34;
        try:
            return self._states_dict[&#39;CAS&#39;]
        except KeyError:
            pass

    @property
    def CRS(self):
        &#34;&#34;&#34;Covariances between refractory and sensitive fractions of populations.

        Matrix (as a list of lists) of covariances between refractory and
        sensitive fractions of populations with respect to time, or `None` if no
        such matrix is defined. If the network has only one population, it is
        not a list of lists, but directly the covariance between the refractory
        and sensitive fractions of the network.

        It cannot be set nor deleted.
        &#34;&#34;&#34;
        try:
            return self._states_dict[&#39;CRS&#39;]
        except KeyError:
            pass

    def default_figure(self, ncol=None, show=True, savefig=False, **kwargs):
        &#34;&#34;&#34;Draw a figure with default plots and parameters.

        Draw a figure with default plots and parameters. The curves plotted by
        default are all fractions of populations (or their expectations or
        averages) and their variances, if those are defined for the result. The
        keyword arguments listed in the [Other Parameters](#other-parameters)
        section below give a little more control over the curves which are
        plotted, for results with a lot of components. If the figure is saved,
        it is under *ID - name.png*, where *ID* and *name* are the
        corresponding attributes of the result, and it is placed in the
        current directory.

        Parameters
        ----------
        ncol : int, optional
            Number of columns of the legend, passed to `Graphics.legend`.
            Defaults to `None`, in which case a default value is replaced.
        show : bool
            Decides if the figure is shown or not. Defaults to `True`.
        savefig : bool, optional
            Decides if the figure is saved or not. Defaults to `False`.
        **kwargs
            Keyword arguments to be passed to an internal method that decides
            what is plotted on the figure. Valid keyword arguments are given in
            the [Other Parameters](#other-parameters) section below.
        
        Other Parameters
        ----------------
        expectations : bool, optional
            Decides whether expectations (or averages) are plotted on the
            figure. Valid in `ExtendedSolution`, `Statistics` and `Spectrum`.
            Defaults to `True` whenever it is valid.
        variances : bool, optional
            Decides whether variances are plotted on the figure. Valid in
            `ExtendedSolution`, `Statistics` and `Spectrum`. Defaults to `True`
            whenever it is valid.
        covariances : bool, optional
            Decides whether non-symmetric covariances are plotted on the figure.
            Valid in `ExtendedSolution`, `Statistics` and `Spectrum`. Defaults
            to `False`.
        third_moments : bool, optional
            Decides whether third central moments are plotted on the figure.
            Valid in `Statistics` and `Spectrum`. Defaults to `False`.
        &#34;&#34;&#34;
        self.activate()
        self._default_plots(**kwargs)
        self.setup()
        self.legend(ncol=ncol)
        self.draw(show=show, savefig=savefig)

    def get_spectrum(self, name=None):
        &#34;&#34;&#34;Get the spectrum of this result.

        Get a `Spectrum` instance corresponding to `self` where each state
        component is replaced by its real fast Fourier transform.

        Parameters
        ----------
        name : str, optional
            Name to associate with the spectrum. Defaults to `None`, in which
            case it is replaced with `&#39;Spectrum&#39;`.

        Returns
        -------
        Spectrum
            The spectrum of the result `self`.
        &#34;&#34;&#34;
        return Spectrum(self.config, self._states_dict, self.times, 
                        self.default_name, name)

    def setup(self, set_xlabel=True, units=&#39;ms&#39;, fontsize=10, xlim=&#39;time&#39;,
              ylim=&#39;fractions&#39;):
        &#34;&#34;&#34;Setup a figure.

        Setup the figure `Result.fig`. Allows to set an automatic label to the
        horizontal axis based on `Result.x_units`, to choose a font size for
        the labels, and to set limits to both axes.

        Parameters
        ----------
        set_xlabel : bool, optional
            Decides if the horizontal axis is labelled. Defaults to `True`.
        units : str, optional
            Time units for the horizontal axis, indicated in square brackets on
            the figure. If it is set to the empty string `&#39;&#39;`, no extra square
            brackets are added. Defaults to `&#39;ms&#39;`, which assumes that
            transition rates are given in kHz.
        fontsize : float, optional
            Font size in points for the horizontal axis&#39; label. Defaults to 10.
        xlim : {&#39;time&#39;, &#39;config&#39;, &#39;unbounded&#39;}, optional
            Decides how the horizontal axis is bounded. If `&#39;time`&#39;, it is
            bounded by the initial and final values of the times array. If
            `&#39;config&#39;`, it is bounded by the initial and final times of
            the configuration. If `&#39;unbounded&#39;`, it is not bounded.
            Defaults to `&#39;time&#39;`.
        ylim : {&#39;fractions&#39;, &#39;covariances&#39;, &#39;unbounded&#39;}, optional
            Decides how the vertical axis is bounded. If `&#39;fractions&#39;`, it is
            bounded between 0 and 1. If `&#39;covariances&#39;`, it is bounded between
            between -1/4 and 1. If `&#39;unbounded&#39;`, it is not bounded. Defaults
            to `&#39;fractions&#39;`.

        Raises
        ------
        popnet.exceptions.PopNetError
            If no figure and axes are bound to `Result.fig` and `Result.ax`.
        ValueError
            If `xlim` or `ylim` is given a non-valid value.
        &#34;&#34;&#34;
        self._check_if_activated()
        self._set_xlabel(set_xlabel, units, fontsize)
        self._check_lim_value(&#39;x&#39;, xlim)
        self._check_lim_value(&#39;y&#39;, ylim)
        self._set_xlim(xlim)
        self._set_ylim(ylim)

    def _add_colors_items_one(self):
        &#34;&#34;&#34;Add items to the `colors` dictionary. 

        Add to the `colors` dictionary items corresponding to state variables
        involving *one* population, and define some default colors.
        &#34;&#34;&#34;
        for X in [&#39;A&#39;, &#39;R&#39;, &#39;S&#39;]:
            self.colors[X] = [None for pop in self.config.network.populations]
        if (p := len(self.config.network.populations)) == 1:
            self.colors[&#39;A&#39;][0] = (150/255,10/255,47/255)
            self.colors[&#39;R&#39;][0] = &#39;midnightblue&#39;
            self.colors[&#39;S&#39;][0] = &#39;goldenrod&#39;
        elif p == 2:
            self.colors[&#39;A&#39;] = [&#39;midnightblue&#39;, (150/255,10/255,47/255)]
            self.colors[&#39;R&#39;] = [&#39;royalblue&#39;, &#39;crimson&#39;]
            self.colors[&#39;S&#39;] = [&#39;skyblue&#39;, (243/255,125/255,148/255)]

    def _add_colors_items_two(self):
        &#34;&#34;&#34;Add items to the `colors` dictionary. 

        Add to the `colors` dictionary items corresponding to variables
        involving *two* populations, and define some default colors.
        &#34;&#34;&#34;
        for XY in [&#39;AA&#39;, &#39;RR&#39;, &#39;SS&#39;, &#39;AR&#39;, &#39;AS&#39;, &#39;RS&#39;]:
            key = f&#39;C{XY}&#39;
            self.colors[key] = [[None for p1 in self.config.network.populations]
                                      for p2 in self.config.network.populations]
        if (p := len(self.config.network.populations)) == 1:
            self.colors[&#39;CAA&#39;][0][0] = &#39;salmon&#39;
            self.colors[&#39;CRR&#39;][0][0] = &#39;skyblue&#39;
            self.colors[&#39;CSS&#39;][0][0] = &#39;gold&#39;
            self.colors[&#39;CAR&#39;][0][0] = &#39;violet&#39;
            self.colors[&#39;CAS&#39;][0][0] = (255/255,180/255,0)
            self.colors[&#39;CRS&#39;][0][0] = &#39;springgreen&#39;
        elif p == 2:
            self.colors[&#39;CAA&#39;] = [[&#39;seagreen&#39;, None], [None, &#39;blueviolet&#39;]]
            self.colors[&#39;CRR&#39;] = [[&#39;mediumseagreen&#39;, None], 
                                  [None, &#39;mediumorchid&#39;]]
            self.colors[&#39;CSS&#39;] = [[&#39;springgreen&#39;, None], [None, &#39;violet&#39;]]

    def _add_colors_items_three(self):
        &#34;&#34;&#34;Add items to the `colors` dictionary. 

        Add to the `colors` dictionary items corresponding to variables
        involving *three* populations.
        &#34;&#34;&#34;
        keys = [&#39;AAA&#39;, &#39;AAR&#39;, &#39;AAS&#39;, &#39;ARR&#39;, &#39;ARS&#39;, 
                &#39;ASS&#39;, &#39;RRR&#39;, &#39;RRS&#39;, &#39;RSS&#39;, &#39;SSS&#39;]
        for k in keys:
            self.colors[k] = [[[None for p1 in self.config.network.populations]
                                     for p2 in self.config.network.populations]
                                     for p3 in self.config.network.populations]

    @staticmethod
    def _check_config(config, ID):
        &#34;&#34;&#34;Check if `config` is a valid configuration when loading a result.&#34;&#34;&#34;
        if config is None:
            return structures.load_config(ID)
        if not isinstance(config, structures.Configuration):
            raise TypeError(&#39;The configuration to associate with a loaded &#39;
                            &#39;result must be a \&#39;Configuration\&#39; instance.&#39;)
        if config.ID != ID:
            raise PopNetError(&#39;The configuration to associate with a result &#39;
                              f&#39;loaded from ID {ID} must have the same ID.&#39;)
        return config

    @classmethod
    def _check_lim_value(cls, axis, value):
        &#34;&#34;&#34;Check if `value` is valid to bound axis `axis`.&#34;&#34;&#34;
        if value not in cls._lim_valid_values[axis]:
            raise ValueError(f&#39;The value \&#39;{value}\&#39; is not valid for the &#39;
                             f&#39;parameter {axis}lim of setup(). Valid values &#39;
                             f&#39;are {cls._lim_valid_values[axis]}.&#39;)

    def _default_plots(self, one=True, symmetric=False, nonsymmetric=False,
                       three=False):
        &#34;&#34;&#34;Add plots on the default figure.&#34;&#34;&#34;
        if one: self._plot_all_one()
        self._plot_all_two(symmetric=symmetric, nonsymmetric=nonsymmetric)
        if three: self._plot_all_three()

    def _get_fractions_dict(self, states):
        &#34;&#34;&#34;Get the fractions variables dictionary.&#34;&#34;&#34;
        transposed_states = np.transpose(states)
        A = transposed_states[: (p := len(self.config.network.populations))]
        R = transposed_states[p : 2*p]
        S = 1 - A - R
        return {&#39;A&#39;: A, &#39;R&#39;: R, &#39;S&#39;: S}

    def _init_abscissa(self, times):
        &#34;&#34;&#34;Initialize array related to the independant variable.&#34;&#34;&#34;
        self._times = times

    def _init_colors(self):
        &#34;&#34;&#34;Initialize the colors associated with state variables.&#34;&#34;&#34;
        self.colors = _internals.PopNetDict()
        self._add_colors_items_one()

    def _init_plot_methods(self):
        &#34;&#34;&#34;Initialize plotting methods of state variables.&#34;&#34;&#34;
        self._plot = self._plot_dict_one()

    def _init_states_dict(self, states):
        &#34;&#34;&#34;Initialize the state variables dictionary.&#34;&#34;&#34;
        self._states_dict = self._get_fractions_dict(states)

    def _label_one(self, X, J):
        pass

    def _label_two(self, CXY, J, K):
        pass

    def _label_three(self, XYZ, J, K, L):
        pass

    def _make_plot_one(self, X, J, states=None, label_func=None, lw=None, ls=None):
        &#34;&#34;&#34;Define a plotting method for a given state variable.

        Define a method to plot the state variable `X` for the population `J`,
        labeling the curve with `label_func` and taking the data in `states`.
        &#34;&#34;&#34;
        if states is None:
            states = self._states_dict
        if label_func is None:
            label_func = self._label_one
        def f(add_label=True, lw=lw, ls=ls, color=None, label=None, **kwargs):
            self._check_if_activated()
            if color is None:
                color = self.colors[X][J]
            if add_label and label is None:
                label = label_func(X, J)
            line, = self.ax.plot(self.times, states[X][J], label=label, lw=lw,
                                 ls=ls, color=color, **kwargs)
            return line
        return f

    def _make_plot_two(self, CXY, J, K):
        &#34;&#34;&#34;Define a plotting method for a covariance.

        Define a method to plot the covariance `CXY` for the `J`th and `K`th
        population.
        &#34;&#34;&#34;
        def f(color=None, label=None, **kwargs):
            self._check_if_activated()
            if color is None:
                color = self.colors[CXY][J][K]
            if label is None:
                label = self._label_two(CXY[1:], J, K)
            covariance = self._states_dict[CXY][J][K]
            line, = self.ax.plot(self.times, covariance, label=label,
                                 color=color, **kwargs)
            return line
        return f

    def _make_plot_three(self, XYZ, J, K, L):
        &#34;&#34;&#34;Define a plotting method for a third central moment.
        
        Define a method to plot the third central moment for the state variables
        `X`, `Y` and `Z` for the `J`th, `K`th and `L`th population respectively.
        &#34;&#34;&#34;
        def f(verbose=True, color=None, label=None, **kwargs):
            self._check_if_activated()
            try:
                moment = self._states_dict[XYZ][J][K][L]
            except (KeyError, IndexError):
                moment = None
            if moment is None:
                if verbose:
                    warn(&#39;The third central moment requested to plot is not &#39;
                         &#39;available. If this result has third central moments, &#39;
                         &#39;there should be a transposition of indices that &#39;
                         &#39;allows to get the same moment in another way.&#39;,
                         category=PopNetWarning, stacklevel=2)
                return None
            if color is None:
                color = self.colors[XYZ][J][K][L]
            if label is None:
                label = self._label_three(XYZ, J, K, L)
            line, = self.ax.plot(self.times, moment, label=label, 
                                 color=color, **kwargs)
            return line
        return f

    def _plot_all_one(self, **kwargs):
        &#34;&#34;&#34;Plot all state variables associated with *one* population.&#34;&#34;&#34;
        for J in range(len(self.config.network.populations)):
            for X in [&#39;A&#39;, &#39;R&#39;, &#39;S&#39;]:
                self.plot[X][J](**kwargs)

    def _plot_all_two(self, symmetric=True, nonsymmetric=True, **kwargs):
        &#34;&#34;&#34;Plot all state variables associated with *two* populations.

        Parameters
        ----------
        symmetric : bool, optional
            Decides whether variances are plotted. Defaults to `True`.
        nonsymmetric : bool, optional
            Decides whether non-symmetric covariances are plotted. Defaults to
            `True`.
        &#34;&#34;&#34;
        p = len(self.config.network.populations)
        for J, K in np.ndindex((p,p)):
            for CXX in [&#39;CAA&#39;, &#39;CRR&#39;, &#39;CSS&#39;]:
                if J == K and symmetric:
                    self.plot[CXX][J][K](**kwargs)
                if J &lt; K and nonsymmetric:
                    self.plot[CXX][J][K](**kwargs)
            for CXY in [&#39;CAR&#39;, &#39;CAS&#39;, &#39;CRS&#39;]:
                if nonsymmetric:
                    self.plot[CXY][J][K](**kwargs)

    def _plot_all_three(self, **kwargs):
        &#34;&#34;&#34;Plot all state variables associated with *three* populations.&#34;&#34;&#34;
        p = len(self.config.network.populations)
        for XYZ in [&#39;AAA&#39;, &#39;AAR&#39;, &#39;AAS&#39;, &#39;ARR&#39;, &#39;ARR&#39;,
                    &#39;ASS&#39;, &#39;RRR&#39;, &#39;RRS&#39;, &#39;RSS&#39;, &#39;SSS&#39;]:
            for J, K, L in np.ndindex((p,p,p)):
                self.plot[XYZ][J][K][L](verbose=False, **kwargs)

    def _plot_dict_one(self, **kwargs):
        &#34;&#34;&#34;Return a dictionary of plotting methods for *one* population.&#34;&#34;&#34;
        p = len(self.config.network.populations)
        return {X: [self._make_plot_one(X, J, **kwargs) for J in range(p)]
                for X in [&#39;A&#39;, &#39;R&#39;, &#39;S&#39;]}

    def _plot_dict_two(self):
        &#34;&#34;&#34;Return a dictionary of plotting methods for *two* populations.&#34;&#34;&#34;
        p = len(self.config.network.populations)
        return {CXY: [[self._make_plot_two(CXY, J, K)
                       for K in range(p)] for J in range(p)]
                for CXY in [&#39;CAA&#39;, &#39;CRR&#39;, &#39;CSS&#39;, &#39;CAR&#39;, &#39;CAS&#39;, &#39;CRS&#39;]}

    def _plot_dict_three(self):
        &#34;&#34;&#34;Return a dictionary of plotting methods for *three* populations.&#34;&#34;&#34;
        p = len(self.config.network.populations)
        return {XYZ: [[[self._make_plot_three(XYZ, J, K, L) for L in range(p)]
                        for K in range(p)] for J in range(p)]
                for XYZ in [&#39;AAA&#39;, &#39;AAR&#39;, &#39;AAS&#39;, &#39;ARR&#39;, &#39;ARS&#39;,
                            &#39;ASS&#39;, &#39;RRR&#39;, &#39;RRS&#39;, &#39;RSS&#39;, &#39;SSS&#39;]}

    def _set_xlabel(self, set, units, fontsize):
        &#34;&#34;&#34;Set the label of the horizontal axis of a figure.&#34;&#34;&#34;
        if set:
            units = f&#39; [{units}]&#39; if units != &#39;&#39; else &#39;&#39;
            self.ax.set_xlabel(f&#39;{self.x_units}{units}&#39;, fontsize=fontsize)

    def _set_xlim(self, xlim):
        &#34;&#34;&#34;Set the limits of the horizontal axis of a figure.&#34;&#34;&#34;
        if xlim == &#39;time&#39;:
            self.ax.set_xlim(self.times[0], self.times[-1])
        elif xlim == &#39;config&#39;:
            self.ax.set_xlim(self.config.initial_time, self.config.final_time)
        elif xlim == &#39;unbounded&#39;:
            pass

    def _set_ylim(self, ylim):
        &#34;&#34;&#34;Set the limits of the vertical axis of a figure.&#34;&#34;&#34;
        if ylim == &#39;fractions&#39;:
            self.ax.set_ylim([0, 1])
        elif ylim == &#39;covariances&#39;:
            self.ax.set_ylim([-1/4, 1])
        elif ylim == &#39;unbounded&#39;:
            pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="popnet.graphics.Graphics" href="#popnet.graphics.Graphics">Graphics</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="popnet.graphics.Solution" href="#popnet.graphics.Solution">Solution</a></li>
<li><a title="popnet.graphics.Spectrum" href="#popnet.graphics.Spectrum">Spectrum</a></li>
<li><a title="popnet.graphics.Statistics" href="#popnet.graphics.Statistics">Statistics</a></li>
<li><a title="popnet.graphics.Trajectory" href="#popnet.graphics.Trajectory">Trajectory</a></li>
<li>popnet.graphics._ResultOne</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="popnet.graphics.Result.x_units"><code class="name">var <span class="ident">x_units</span></code></dt>
<dd>
<div class="desc"><p>Units of the horizontal axis. The default is <code>'Time'</code>.</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="popnet.graphics.Result.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>ID, name=None, config=None, times=None, folder=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Load the result associated with the ID.</p>
<p>Load the result obtained when using the configuration of ID <code>ID</code>. The
array representing the state of the network with respect to time is
expected to be in a file named <em>ID - name.txt</em>, where <em>ID</em> and <em>name</em>
are indeed <code>ID</code> and <code>name</code>. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ID</code></strong> :&ensp;<code>str</code></dt>
<dd>ID of the configuration used to obtain this result.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name associated with the result. Defaults to <code>None</code>, in which case
it is replaced with the name of the class.</dd>
<dt><strong><code>config</code></strong> :&ensp;<code><a title="popnet.structures.Configuration" href="structures.html#popnet.structures.Configuration">Configuration</a></code>, optional</dt>
<dd>Configuration to associate with the result. If given, it must have
the ID <code>ID</code>. Defaults to <code>None</code>, in which case it is loaded with
<code><a title="popnet.structures.load_config" href="structures.html#popnet.structures.load_config">load_config()</a></code>, using the same ID.</dd>
<dt><strong><code>times</code></strong> :&ensp;<code>array_like</code>, optional</dt>
<dd>Times array to associate with the result. Defaults to <code>None</code>, in
which case it is computed from the configuration.</dd>
<dt><strong><code>folder</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Folder in which the file is located, which should be placed in the
current directory. Defaults to <code>None</code>, in which case the file is
assumed to be located in the current directory.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="popnet.graphics.Result" href="#popnet.graphics.Result">Result</a></code></dt>
<dd>The loaded result.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>config</code> is neither <code>None</code> nor a
<code><a title="popnet.structures.Configuration" href="structures.html#popnet.structures.Configuration">Configuration</a></code> instance.</dd>
<dt><code><a title="popnet.exceptions.PopNetError" href="exceptions.html#popnet.exceptions.PopNetError">PopNetError</a></code></dt>
<dd>If <code>config</code> has a different ID than <code>ID</code>.</dd>
<dt><code>FileNotFoundError</code></dt>
<dd>If no file is found with the expected name.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def load(cls, ID, name=None, config=None, times=None, folder=None):
    &#34;&#34;&#34;Load the result associated with the ID.

    Load the result obtained when using the configuration of ID `ID`. The
    array representing the state of the network with respect to time is
    expected to be in a file named *ID - name.txt*, where *ID* and *name*
    are indeed `ID` and `name`. 

    Parameters
    ----------
    ID : str
        ID of the configuration used to obtain this result. 
    name : str, optional
        Name associated with the result. Defaults to `None`, in which case
        it is replaced with the name of the class.
    config : popnet.structures.Configuration, optional
        Configuration to associate with the result. If given, it must have
        the ID `ID`. Defaults to `None`, in which case it is loaded with
        `popnet.structures.load_config`, using the same ID.
    times : array_like, optional
        Times array to associate with the result. Defaults to `None`, in
        which case it is computed from the configuration.
    folder : str, optional
        Folder in which the file is located, which should be placed in the
        current directory. Defaults to `None`, in which case the file is
        assumed to be located in the current directory.

    Returns
    -------
    Result
        The loaded result. 

    Raises
    ------
    TypeError
        If `config` is neither `None` nor a
        `popnet.structures.Configuration` instance.
    popnet.exceptions.PopNetError
        If `config` has a different ID than `ID`. 
    FileNotFoundError
        If no file is found with the expected name.
    &#34;&#34;&#34;
    config = cls._check_config(config, ID)
    if times is None:
        times = np.linspace(config.initial_time, config.final_time,
                            1 + config.iterations)
    name = cls._get_name(name)
    filename = _internals._format_filename(folder, ID, name)
    try:
        states = np.loadtxt(filename, dtype=float, ndmin=2)
    except FileNotFoundError as error:
        raise FileNotFoundError(
                f&#39;No result found for configuration {ID}.&#39;) from error
    return cls(config, states, times, name)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="popnet.graphics.Result.A"><code class="name">var <span class="ident">A</span></code></dt>
<dd>
<div class="desc"><p>Active fractions of populations.</p>
<p>List of active fractions of populations (or their expectations,
depending on the result) as arrays indexed with respect to time. If
the network has only one population, it is not a list, but directly the
array giving the active fraction of the network with respect to time.</p>
<p>It cannot be set nor deleted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def A(self):
    &#34;&#34;&#34;Active fractions of populations.

    List of active fractions of populations (or their expectations,
    depending on the result) as arrays indexed with respect to time. If
    the network has only one population, it is not a list, but directly the
    array giving the active fraction of the network with respect to time.

    It cannot be set nor deleted.
    &#34;&#34;&#34;
    return self._states_dict[&#39;A&#39;]</code></pre>
</details>
</dd>
<dt id="popnet.graphics.Result.CAA"><code class="name">var <span class="ident">CAA</span></code></dt>
<dd>
<div class="desc"><p>Covariances between active fractions of populations.</p>
<p>Matrix (as a list of lists) of covariances between active fractions of
populations with respect to time, or <code>None</code> if no such matrix is
defined. If the network has only one population, it is not a list of
lists, but directly the variance of the active fraction of the network.</p>
<p>It cannot be set nor deleted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def CAA(self):
    &#34;&#34;&#34;Covariances between active fractions of populations.

    Matrix (as a list of lists) of covariances between active fractions of
    populations with respect to time, or `None` if no such matrix is
    defined. If the network has only one population, it is not a list of
    lists, but directly the variance of the active fraction of the network.

    It cannot be set nor deleted. 
    &#34;&#34;&#34;
    try:
        return self._states_dict[&#39;CAA&#39;]
    except KeyError:
        pass</code></pre>
</details>
</dd>
<dt id="popnet.graphics.Result.CAR"><code class="name">var <span class="ident">CAR</span></code></dt>
<dd>
<div class="desc"><p>Covariances between active and refractory fractions of populations.</p>
<p>Matrix (as a list of lists) of covariances between active and refractory
fractions of populations with respect to time, or <code>None</code> if no such
matrix is defined. If the network has only one population, it is not a
list of lists, but directly the covariance between the active and
refractory fractions of the network.</p>
<p>It cannot be set nor deleted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def CAR(self):
    &#34;&#34;&#34;Covariances between active and refractory fractions of populations.

    Matrix (as a list of lists) of covariances between active and refractory
    fractions of populations with respect to time, or `None` if no such
    matrix is defined. If the network has only one population, it is not a
    list of lists, but directly the covariance between the active and
    refractory fractions of the network.

    It cannot be set nor deleted.
    &#34;&#34;&#34;
    try:
        return self._states_dict[&#39;CAR&#39;]
    except KeyError:
        pass</code></pre>
</details>
</dd>
<dt id="popnet.graphics.Result.CAS"><code class="name">var <span class="ident">CAS</span></code></dt>
<dd>
<div class="desc"><p>Covariances between active and sensitive fractions of populations.</p>
<p>Matrix (as a list of lists) of covariances between active and sensitive
fractions of populations with respect to time, or <code>None</code> if no such
matrix is defined. If the network has only one population, it is not a
list of lists, but directly the covariance between the active and
sensitive fractions of the network.</p>
<p>It cannot be set nor deleted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def CAS(self):
    &#34;&#34;&#34;Covariances between active and sensitive fractions of populations.

    Matrix (as a list of lists) of covariances between active and sensitive
    fractions of populations with respect to time, or `None` if no such
    matrix is defined. If the network has only one population, it is not a
    list of lists, but directly the covariance between the active and
    sensitive fractions of the network.

    It cannot be set nor deleted.
    &#34;&#34;&#34;
    try:
        return self._states_dict[&#39;CAS&#39;]
    except KeyError:
        pass</code></pre>
</details>
</dd>
<dt id="popnet.graphics.Result.CRR"><code class="name">var <span class="ident">CRR</span></code></dt>
<dd>
<div class="desc"><p>Covariances between refractory fractions of populations.</p>
<p>Matrix (as a list of lists) of covariances between refractory fractions
of populations with respect to time, or <code>None</code> if no such matrix is
defined. If the network has only one population, it is not a list of
lists, but directly the variance of the refractory fraction of the
network.</p>
<p>It cannot be set nor deleted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def CRR(self):
    &#34;&#34;&#34;Covariances between refractory fractions of populations.

    Matrix (as a list of lists) of covariances between refractory fractions
    of populations with respect to time, or `None` if no such matrix is
    defined. If the network has only one population, it is not a list of
    lists, but directly the variance of the refractory fraction of the
    network.

    It cannot be set nor deleted. 
    &#34;&#34;&#34;
    try:
        return self._states_dict[&#39;CRR&#39;]
    except KeyError:
        pass</code></pre>
</details>
</dd>
<dt id="popnet.graphics.Result.CRS"><code class="name">var <span class="ident">CRS</span></code></dt>
<dd>
<div class="desc"><p>Covariances between refractory and sensitive fractions of populations.</p>
<p>Matrix (as a list of lists) of covariances between refractory and
sensitive fractions of populations with respect to time, or <code>None</code> if no
such matrix is defined. If the network has only one population, it is
not a list of lists, but directly the covariance between the refractory
and sensitive fractions of the network.</p>
<p>It cannot be set nor deleted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def CRS(self):
    &#34;&#34;&#34;Covariances between refractory and sensitive fractions of populations.

    Matrix (as a list of lists) of covariances between refractory and
    sensitive fractions of populations with respect to time, or `None` if no
    such matrix is defined. If the network has only one population, it is
    not a list of lists, but directly the covariance between the refractory
    and sensitive fractions of the network.

    It cannot be set nor deleted.
    &#34;&#34;&#34;
    try:
        return self._states_dict[&#39;CRS&#39;]
    except KeyError:
        pass</code></pre>
</details>
</dd>
<dt id="popnet.graphics.Result.CSS"><code class="name">var <span class="ident">CSS</span></code></dt>
<dd>
<div class="desc"><p>Covariances between sensitive fractions of populations.</p>
<p>Matrix (as a list of lists) of covariances between sensitive fractions
of populations with respect to time, or <code>None</code> if no such matrix is
defined. If the network has only one population, it is not a list of
lists, but directly the variance of the sensitive fraction of the
network.</p>
<p>It cannot be set nor deleted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def CSS(self):
    &#34;&#34;&#34;Covariances between sensitive fractions of populations.

    Matrix (as a list of lists) of covariances between sensitive fractions
    of populations with respect to time, or `None` if no such matrix is
    defined. If the network has only one population, it is not a list of
    lists, but directly the variance of the sensitive fraction of the
    network.

    It cannot be set nor deleted. 
    &#34;&#34;&#34;
    try:
        return self._states_dict[&#39;CSS&#39;]
    except KeyError:
        pass</code></pre>
</details>
</dd>
<dt id="popnet.graphics.Result.R"><code class="name">var <span class="ident">R</span></code></dt>
<dd>
<div class="desc"><p>Refractory fractions of populations.</p>
<p>List of refractory fractions of populations (or their expectations,
depending on the result) as arrays indexed with respect to time. If
the network has only one population, it is not a list, but directly the
array giving the refractory fraction of the network with respect to
time.</p>
<p>It cannot be set nor deleted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def R(self):
    &#34;&#34;&#34;Refractory fractions of populations.

    List of refractory fractions of populations (or their expectations,
    depending on the result) as arrays indexed with respect to time. If
    the network has only one population, it is not a list, but directly the
    array giving the refractory fraction of the network with respect to
    time.

    It cannot be set nor deleted.
    &#34;&#34;&#34;
    return self._states_dict[&#39;R&#39;]</code></pre>
</details>
</dd>
<dt id="popnet.graphics.Result.S"><code class="name">var <span class="ident">S</span></code></dt>
<dd>
<div class="desc"><p>Sensitive fractions of population.</p>
<p>List of sensitive fractions of populations (or their expectations,
depending on the result) as arrays indexed with respect to time. If
the network has only one population, it is not a list, but directly the
array giving the sensitive fraction of the network with respect to time.</p>
<p>It cannot be set nor deleted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def S(self):
    &#34;&#34;&#34;Sensitive fractions of population.

    List of sensitive fractions of populations (or their expectations,
    depending on the result) as arrays indexed with respect to time. If
    the network has only one population, it is not a list, but directly the
    array giving the sensitive fraction of the network with respect to time.

    It cannot be set nor deleted.
    &#34;&#34;&#34;
    return self._states_dict[&#39;S&#39;]</code></pre>
</details>
</dd>
<dt id="popnet.graphics.Result.colors"><code class="name">var <span class="ident">colors</span></code></dt>
<dd>
<div class="desc"><p>Colors associated with the result's components.</p>
<p>Colors associated with the result's components, to be used in figures.
It is a dictionary whose keys are strings representing possible
components, and whose values are lists (or lists of lists) of valid
Matplotlib colors associated with each population (or pair of
populations). For example, <code>result.colors['A'][J]</code> is the color
associated with the activity of the <em>J</em>th population of the network for
the result <code>result</code>. By default, in the case of a single population,
a new color can be assigned as is, and it is automatically placed in a
list (containing only the given color). It cannot be deleted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def colors(self):
    &#34;&#34;&#34;Colors associated with the result&#39;s components.

    Colors associated with the result&#39;s components, to be used in figures.
    It is a dictionary whose keys are strings representing possible
    components, and whose values are lists (or lists of lists) of valid
    Matplotlib colors associated with each population (or pair of
    populations). For example, `result.colors[&#39;A&#39;][J]` is the color
    associated with the activity of the *J*th population of the network for
    the result `result`. By default, in the case of a single population,
    a new color can be assigned as is, and it is automatically placed in a
    list (containing only the given color). It cannot be deleted.
    &#34;&#34;&#34;
    return self._colors</code></pre>
</details>
</dd>
<dt id="popnet.graphics.Result.plot"><code class="name">var <span class="ident">plot</span></code></dt>
<dd>
<div class="desc"><p>Dictionary of methods to plot state variables.</p>
<p>If <em>X</em> denotes a state variable (that is, either <em>A</em>, <em>R</em> or <em>S</em>), then
<code>plot['X']</code> is a list whose <em>J</em>th element is a method that plots
<span><span class="MathJax_Preview">X^J</span><script type="math/tex">X^J</script></span> (or its expectation, depending on the
result) with respect to time. Similarly, if covariances are defined for
this result, then <code>plot['CXY'][J][K]</code> is a method which plots the
covariances between <span><span class="MathJax_Preview">X^J</span><script type="math/tex">X^J</script></span> and <span><span class="MathJax_Preview">Y^K</span><script type="math/tex">Y^K</script></span> with respect to time. A
similar pattern works for third central moments as well if applicable,
with keys of the form <code>'XYZ'</code>.</p>
<p>In the case where the network has only one population, the lists are
all replaced with the single element they would contain. For example,
<code>plot['A']</code> is directly a method to plot the network's activity, that
is, the activity of the single population of the network. In the same
way, <code>plot['CRR']</code> is a method to plot the variance of the refractory
fraction of the network.</p>
<p>When called, these methods plot the corresponding state components with
respect to time on the axes <code><a title="popnet.graphics.Result.ax" href="#popnet.graphics.Graphics.ax">Result.ax</a></code> of the figure <code><a title="popnet.graphics.Result.fig" href="#popnet.graphics.Graphics.fig">Result.fig</a></code>. They
all accept keyword arguments that can be passed to the
<a href="https://31c8.short.gy/ax-plot"><code>plot</code></a> method of <code><a title="popnet.graphics.Result.ax" href="#popnet.graphics.Graphics.ax">Result.ax</a></code>. This
attribute cannot be set nor deleted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def plot(self):
    &#34;&#34;&#34;Dictionary of methods to plot state variables.

    If *X* denotes a state variable (that is, either *A*, *R* or *S*), then
    `plot[&#39;X&#39;]` is a list whose *J*th element is a method that plots
    \\(X^J\\) (or its expectation, depending on the
    result) with respect to time. Similarly, if covariances are defined for
    this result, then `plot[&#39;CXY&#39;][J][K]` is a method which plots the
    covariances between \\(X^J\\) and \\(Y^K\\) with respect to time. A
    similar pattern works for third central moments as well if applicable,
    with keys of the form `&#39;XYZ&#39;`.

    In the case where the network has only one population, the lists are
    all replaced with the single element they would contain. For example,
    `plot[&#39;A&#39;]` is directly a method to plot the network&#39;s activity, that
    is, the activity of the single population of the network. In the same
    way, `plot[&#39;CRR&#39;]` is a method to plot the variance of the refractory
    fraction of the network.

    When called, these methods plot the corresponding state components with
    respect to time on the axes `Result.ax` of the figure `Result.fig`. They
    all accept keyword arguments that can be passed to the
    [`plot`](https://31c8.short.gy/ax-plot) method of `Result.ax`. This
    attribute cannot be set nor deleted.
    &#34;&#34;&#34;
    return self._plot</code></pre>
</details>
</dd>
<dt id="popnet.graphics.Result.times"><code class="name">var <span class="ident">times</span></code></dt>
<dd>
<div class="desc"><p>Time.</p>
<p>An array representing time. It is the independant variable with respect
to which state components are given. It cannot be set nor deleted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def times(self):
    &#34;&#34;&#34;Time.

    An array representing time. It is the independant variable with respect
    to which state components are given. It cannot be set nor deleted.
    &#34;&#34;&#34;
    return self._times</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="popnet.graphics.Result.default_figure"><code class="name flex">
<span>def <span class="ident">default_figure</span></span>(<span>self, ncol=None, show=True, savefig=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Draw a figure with default plots and parameters.</p>
<p>Draw a figure with default plots and parameters. The curves plotted by
default are all fractions of populations (or their expectations or
averages) and their variances, if those are defined for the result. The
keyword arguments listed in the <a href="#other-parameters">Other Parameters</a>
section below give a little more control over the curves which are
plotted, for results with a lot of components. If the figure is saved,
it is under <em>ID - name.png</em>, where <em>ID</em> and <em>name</em> are the
corresponding attributes of the result, and it is placed in the
current directory.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ncol</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of columns of the legend, passed to <code><a title="popnet.graphics.Graphics.legend" href="#popnet.graphics.Graphics.legend">Graphics.legend()</a></code>.
Defaults to <code>None</code>, in which case a default value is replaced.</dd>
<dt><strong><code>show</code></strong> :&ensp;<code>bool</code></dt>
<dd>Decides if the figure is shown or not. Defaults to <code>True</code>.</dd>
<dt><strong><code>savefig</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Decides if the figure is saved or not. Defaults to <code>False</code>.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments to be passed to an internal method that decides
what is plotted on the figure. Valid keyword arguments are given in
the <a href="#other-parameters">Other Parameters</a> section below.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>expectations</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Decides whether expectations (or averages) are plotted on the
figure. Valid in <code><a title="popnet.graphics.ExtendedSolution" href="#popnet.graphics.ExtendedSolution">ExtendedSolution</a></code>, <code><a title="popnet.graphics.Statistics" href="#popnet.graphics.Statistics">Statistics</a></code> and <code><a title="popnet.graphics.Spectrum" href="#popnet.graphics.Spectrum">Spectrum</a></code>.
Defaults to <code>True</code> whenever it is valid.</dd>
<dt><strong><code>variances</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Decides whether variances are plotted on the figure. Valid in
<code><a title="popnet.graphics.ExtendedSolution" href="#popnet.graphics.ExtendedSolution">ExtendedSolution</a></code>, <code><a title="popnet.graphics.Statistics" href="#popnet.graphics.Statistics">Statistics</a></code> and <code><a title="popnet.graphics.Spectrum" href="#popnet.graphics.Spectrum">Spectrum</a></code>. Defaults to <code>True</code>
whenever it is valid.</dd>
<dt><strong><code>covariances</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Decides whether non-symmetric covariances are plotted on the figure.
Valid in <code><a title="popnet.graphics.ExtendedSolution" href="#popnet.graphics.ExtendedSolution">ExtendedSolution</a></code>, <code><a title="popnet.graphics.Statistics" href="#popnet.graphics.Statistics">Statistics</a></code> and <code><a title="popnet.graphics.Spectrum" href="#popnet.graphics.Spectrum">Spectrum</a></code>. Defaults
to <code>False</code>.</dd>
<dt><strong><code>third_moments</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Decides whether third central moments are plotted on the figure.
Valid in <code><a title="popnet.graphics.Statistics" href="#popnet.graphics.Statistics">Statistics</a></code> and <code><a title="popnet.graphics.Spectrum" href="#popnet.graphics.Spectrum">Spectrum</a></code>. Defaults to <code>False</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def default_figure(self, ncol=None, show=True, savefig=False, **kwargs):
    &#34;&#34;&#34;Draw a figure with default plots and parameters.

    Draw a figure with default plots and parameters. The curves plotted by
    default are all fractions of populations (or their expectations or
    averages) and their variances, if those are defined for the result. The
    keyword arguments listed in the [Other Parameters](#other-parameters)
    section below give a little more control over the curves which are
    plotted, for results with a lot of components. If the figure is saved,
    it is under *ID - name.png*, where *ID* and *name* are the
    corresponding attributes of the result, and it is placed in the
    current directory.

    Parameters
    ----------
    ncol : int, optional
        Number of columns of the legend, passed to `Graphics.legend`.
        Defaults to `None`, in which case a default value is replaced.
    show : bool
        Decides if the figure is shown or not. Defaults to `True`.
    savefig : bool, optional
        Decides if the figure is saved or not. Defaults to `False`.
    **kwargs
        Keyword arguments to be passed to an internal method that decides
        what is plotted on the figure. Valid keyword arguments are given in
        the [Other Parameters](#other-parameters) section below.
    
    Other Parameters
    ----------------
    expectations : bool, optional
        Decides whether expectations (or averages) are plotted on the
        figure. Valid in `ExtendedSolution`, `Statistics` and `Spectrum`.
        Defaults to `True` whenever it is valid.
    variances : bool, optional
        Decides whether variances are plotted on the figure. Valid in
        `ExtendedSolution`, `Statistics` and `Spectrum`. Defaults to `True`
        whenever it is valid.
    covariances : bool, optional
        Decides whether non-symmetric covariances are plotted on the figure.
        Valid in `ExtendedSolution`, `Statistics` and `Spectrum`. Defaults
        to `False`.
    third_moments : bool, optional
        Decides whether third central moments are plotted on the figure.
        Valid in `Statistics` and `Spectrum`. Defaults to `False`.
    &#34;&#34;&#34;
    self.activate()
    self._default_plots(**kwargs)
    self.setup()
    self.legend(ncol=ncol)
    self.draw(show=show, savefig=savefig)</code></pre>
</details>
</dd>
<dt id="popnet.graphics.Result.get_spectrum"><code class="name flex">
<span>def <span class="ident">get_spectrum</span></span>(<span>self, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the spectrum of this result.</p>
<p>Get a <code><a title="popnet.graphics.Spectrum" href="#popnet.graphics.Spectrum">Spectrum</a></code> instance corresponding to <code>self</code> where each state
component is replaced by its real fast Fourier transform.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name to associate with the spectrum. Defaults to <code>None</code>, in which
case it is replaced with <code>'Spectrum'</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="popnet.graphics.Spectrum" href="#popnet.graphics.Spectrum">Spectrum</a></code></dt>
<dd>The spectrum of the result <code>self</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_spectrum(self, name=None):
    &#34;&#34;&#34;Get the spectrum of this result.

    Get a `Spectrum` instance corresponding to `self` where each state
    component is replaced by its real fast Fourier transform.

    Parameters
    ----------
    name : str, optional
        Name to associate with the spectrum. Defaults to `None`, in which
        case it is replaced with `&#39;Spectrum&#39;`.

    Returns
    -------
    Spectrum
        The spectrum of the result `self`.
    &#34;&#34;&#34;
    return Spectrum(self.config, self._states_dict, self.times, 
                    self.default_name, name)</code></pre>
</details>
</dd>
<dt id="popnet.graphics.Result.setup"><code class="name flex">
<span>def <span class="ident">setup</span></span>(<span>self, set_xlabel=True, units='ms', fontsize=10, xlim='time', ylim='fractions')</span>
</code></dt>
<dd>
<div class="desc"><p>Setup a figure.</p>
<p>Setup the figure <code><a title="popnet.graphics.Result.fig" href="#popnet.graphics.Graphics.fig">Result.fig</a></code>. Allows to set an automatic label to the
horizontal axis based on <code><a title="popnet.graphics.Result.x_units" href="#popnet.graphics.Result.x_units">Result.x_units</a></code>, to choose a font size for
the labels, and to set limits to both axes.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>set_xlabel</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Decides if the horizontal axis is labelled. Defaults to <code>True</code>.</dd>
<dt><strong><code>units</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Time units for the horizontal axis, indicated in square brackets on
the figure. If it is set to the empty string <code>''</code>, no extra square
brackets are added. Defaults to <code>'ms'</code>, which assumes that
transition rates are given in kHz.</dd>
<dt><strong><code>fontsize</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Font size in points for the horizontal axis' label. Defaults to 10.</dd>
<dt><strong><code>xlim</code></strong> :&ensp;<code>{'time', 'config', 'unbounded'}</code>, optional</dt>
<dd>Decides how the horizontal axis is bounded. If <code>'time</code>', it is
bounded by the initial and final values of the times array. If
<code>'config'</code>, it is bounded by the initial and final times of
the configuration. If <code>'unbounded'</code>, it is not bounded.
Defaults to <code>'time'</code>.</dd>
<dt><strong><code>ylim</code></strong> :&ensp;<code>{'fractions', 'covariances', 'unbounded'}</code>, optional</dt>
<dd>Decides how the vertical axis is bounded. If <code>'fractions'</code>, it is
bounded between 0 and 1. If <code>'covariances'</code>, it is bounded between
between -1/4 and 1. If <code>'unbounded'</code>, it is not bounded. Defaults
to <code>'fractions'</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="popnet.exceptions.PopNetError" href="exceptions.html#popnet.exceptions.PopNetError">PopNetError</a></code></dt>
<dd>If no figure and axes are bound to <code><a title="popnet.graphics.Result.fig" href="#popnet.graphics.Graphics.fig">Result.fig</a></code> and <code><a title="popnet.graphics.Result.ax" href="#popnet.graphics.Graphics.ax">Result.ax</a></code>.</dd>
<dt><code>ValueError</code></dt>
<dd>If <code>xlim</code> or <code>ylim</code> is given a non-valid value.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup(self, set_xlabel=True, units=&#39;ms&#39;, fontsize=10, xlim=&#39;time&#39;,
          ylim=&#39;fractions&#39;):
    &#34;&#34;&#34;Setup a figure.

    Setup the figure `Result.fig`. Allows to set an automatic label to the
    horizontal axis based on `Result.x_units`, to choose a font size for
    the labels, and to set limits to both axes.

    Parameters
    ----------
    set_xlabel : bool, optional
        Decides if the horizontal axis is labelled. Defaults to `True`.
    units : str, optional
        Time units for the horizontal axis, indicated in square brackets on
        the figure. If it is set to the empty string `&#39;&#39;`, no extra square
        brackets are added. Defaults to `&#39;ms&#39;`, which assumes that
        transition rates are given in kHz.
    fontsize : float, optional
        Font size in points for the horizontal axis&#39; label. Defaults to 10.
    xlim : {&#39;time&#39;, &#39;config&#39;, &#39;unbounded&#39;}, optional
        Decides how the horizontal axis is bounded. If `&#39;time`&#39;, it is
        bounded by the initial and final values of the times array. If
        `&#39;config&#39;`, it is bounded by the initial and final times of
        the configuration. If `&#39;unbounded&#39;`, it is not bounded.
        Defaults to `&#39;time&#39;`.
    ylim : {&#39;fractions&#39;, &#39;covariances&#39;, &#39;unbounded&#39;}, optional
        Decides how the vertical axis is bounded. If `&#39;fractions&#39;`, it is
        bounded between 0 and 1. If `&#39;covariances&#39;`, it is bounded between
        between -1/4 and 1. If `&#39;unbounded&#39;`, it is not bounded. Defaults
        to `&#39;fractions&#39;`.

    Raises
    ------
    popnet.exceptions.PopNetError
        If no figure and axes are bound to `Result.fig` and `Result.ax`.
    ValueError
        If `xlim` or `ylim` is given a non-valid value.
    &#34;&#34;&#34;
    self._check_if_activated()
    self._set_xlabel(set_xlabel, units, fontsize)
    self._check_lim_value(&#39;x&#39;, xlim)
    self._check_lim_value(&#39;y&#39;, ylim)
    self._set_xlim(xlim)
    self._set_ylim(ylim)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="popnet.graphics.Graphics" href="#popnet.graphics.Graphics">Graphics</a></b></code>:
<ul class="hlist">
<li><code><a title="popnet.graphics.Graphics.activate" href="#popnet.graphics.Graphics.activate">activate</a></code></li>
<li><code><a title="popnet.graphics.Graphics.ax" href="#popnet.graphics.Graphics.ax">ax</a></code></li>
<li><code><a title="popnet.graphics.Graphics.config" href="#popnet.graphics.Graphics.config">config</a></code></li>
<li><code><a title="popnet.graphics.Graphics.default_name" href="#popnet.graphics.Graphics.default_name">default_name</a></code></li>
<li><code><a title="popnet.graphics.Graphics.draw" href="#popnet.graphics.Graphics.draw">draw</a></code></li>
<li><code><a title="popnet.graphics.Graphics.fig" href="#popnet.graphics.Graphics.fig">fig</a></code></li>
<li><code><a title="popnet.graphics.Graphics.legend" href="#popnet.graphics.Graphics.legend">legend</a></code></li>
<li><code><a title="popnet.graphics.Graphics.name" href="#popnet.graphics.Graphics.name">name</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="popnet.graphics.Solution"><code class="flex name class">
<span>class <span class="ident">Solution</span></span>
<span>(</span><span>config, states, times, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represent solutions of dynamical systems.</p>
<p><code><a title="popnet.graphics.Solution" href="#popnet.graphics.Solution">Solution</a></code> extends <code><a title="popnet.graphics.Result" href="#popnet.graphics.Result">Result</a></code> for the case where the result is a solution
obtained from a numerical integration of a dynamical system related to the
Wilson&ndash;Cowan model. It adds a method to the base class to plot the
expectations of fractions of populations all at once. Other changes are
implementation details.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Solution(Result):
    &#34;&#34;&#34;Represent solutions of dynamical systems.

    `Solution` extends `Result` for the case where the result is a solution
    obtained from a numerical integration of a dynamical system related to the
    Wilson--Cowan model. It adds a method to the base class to plot the
    expectations of fractions of populations all at once. Other changes are
    implementation details.

    &#34;&#34;&#34;

    default_name = &#39;Solution&#39;
    &#34;&#34;&#34;Default name given to instances.&#34;&#34;&#34;

    def plot_expectations(self, **kwargs):
        &#34;&#34;&#34;Plot all expectations of fractions of populations.

        Plot all expectations of active, refractory and sensitive fractions of
        populations on the figure `Solution.fig`.
        
        Parameters
        ----------
        **kwargs
            Keyword arguments to be passed to the method that plots components,
            which is the [`plot`](https://31c8.short.gy/ax-plot) method of
            `Solution.ax`.

        Raises
        ------
        popnet.exceptions.PopNetError
            If no figure and axes are bound to `Solution.fig` and `Solution.ax`.
        &#34;&#34;&#34;
        self._plot_all_one(**kwargs)

    def _label_one(self, X, J):
        &#34;&#34;&#34;Label for the expectation of `X` for the `J`th population.&#34;&#34;&#34;
        return f&#39;$\\mathcal{{{X}}}_{{{self.config.network.populations[J].ID}}}$&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="popnet.graphics.Result" href="#popnet.graphics.Result">Result</a></li>
<li><a title="popnet.graphics.Graphics" href="#popnet.graphics.Graphics">Graphics</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="popnet.graphics.ExtendedSolution" href="#popnet.graphics.ExtendedSolution">ExtendedSolution</a></li>
<li>popnet.graphics._SolutionOne</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="popnet.graphics.Solution.plot_expectations"><code class="name flex">
<span>def <span class="ident">plot_expectations</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot all expectations of fractions of populations.</p>
<p>Plot all expectations of active, refractory and sensitive fractions of
populations on the figure <code><a title="popnet.graphics.Solution.fig" href="#popnet.graphics.Graphics.fig">Solution.fig</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments to be passed to the method that plots components,
which is the <a href="https://31c8.short.gy/ax-plot"><code>plot</code></a> method of
<code><a title="popnet.graphics.Solution.ax" href="#popnet.graphics.Graphics.ax">Solution.ax</a></code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="popnet.exceptions.PopNetError" href="exceptions.html#popnet.exceptions.PopNetError">PopNetError</a></code></dt>
<dd>If no figure and axes are bound to <code><a title="popnet.graphics.Solution.fig" href="#popnet.graphics.Graphics.fig">Solution.fig</a></code> and <code><a title="popnet.graphics.Solution.ax" href="#popnet.graphics.Graphics.ax">Solution.ax</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_expectations(self, **kwargs):
    &#34;&#34;&#34;Plot all expectations of fractions of populations.

    Plot all expectations of active, refractory and sensitive fractions of
    populations on the figure `Solution.fig`.
    
    Parameters
    ----------
    **kwargs
        Keyword arguments to be passed to the method that plots components,
        which is the [`plot`](https://31c8.short.gy/ax-plot) method of
        `Solution.ax`.

    Raises
    ------
    popnet.exceptions.PopNetError
        If no figure and axes are bound to `Solution.fig` and `Solution.ax`.
    &#34;&#34;&#34;
    self._plot_all_one(**kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="popnet.graphics.Result" href="#popnet.graphics.Result">Result</a></b></code>:
<ul class="hlist">
<li><code><a title="popnet.graphics.Result.A" href="#popnet.graphics.Result.A">A</a></code></li>
<li><code><a title="popnet.graphics.Result.CAA" href="#popnet.graphics.Result.CAA">CAA</a></code></li>
<li><code><a title="popnet.graphics.Result.CAR" href="#popnet.graphics.Result.CAR">CAR</a></code></li>
<li><code><a title="popnet.graphics.Result.CAS" href="#popnet.graphics.Result.CAS">CAS</a></code></li>
<li><code><a title="popnet.graphics.Result.CRR" href="#popnet.graphics.Result.CRR">CRR</a></code></li>
<li><code><a title="popnet.graphics.Result.CRS" href="#popnet.graphics.Result.CRS">CRS</a></code></li>
<li><code><a title="popnet.graphics.Result.CSS" href="#popnet.graphics.Result.CSS">CSS</a></code></li>
<li><code><a title="popnet.graphics.Result.R" href="#popnet.graphics.Result.R">R</a></code></li>
<li><code><a title="popnet.graphics.Result.S" href="#popnet.graphics.Result.S">S</a></code></li>
<li><code><a title="popnet.graphics.Result.activate" href="#popnet.graphics.Graphics.activate">activate</a></code></li>
<li><code><a title="popnet.graphics.Result.ax" href="#popnet.graphics.Graphics.ax">ax</a></code></li>
<li><code><a title="popnet.graphics.Result.colors" href="#popnet.graphics.Result.colors">colors</a></code></li>
<li><code><a title="popnet.graphics.Result.config" href="#popnet.graphics.Graphics.config">config</a></code></li>
<li><code><a title="popnet.graphics.Result.default_figure" href="#popnet.graphics.Result.default_figure">default_figure</a></code></li>
<li><code><a title="popnet.graphics.Result.default_name" href="#popnet.graphics.Graphics.default_name">default_name</a></code></li>
<li><code><a title="popnet.graphics.Result.draw" href="#popnet.graphics.Graphics.draw">draw</a></code></li>
<li><code><a title="popnet.graphics.Result.fig" href="#popnet.graphics.Graphics.fig">fig</a></code></li>
<li><code><a title="popnet.graphics.Result.get_spectrum" href="#popnet.graphics.Result.get_spectrum">get_spectrum</a></code></li>
<li><code><a title="popnet.graphics.Result.legend" href="#popnet.graphics.Graphics.legend">legend</a></code></li>
<li><code><a title="popnet.graphics.Result.load" href="#popnet.graphics.Result.load">load</a></code></li>
<li><code><a title="popnet.graphics.Result.name" href="#popnet.graphics.Graphics.name">name</a></code></li>
<li><code><a title="popnet.graphics.Result.plot" href="#popnet.graphics.Result.plot">plot</a></code></li>
<li><code><a title="popnet.graphics.Result.setup" href="#popnet.graphics.Result.setup">setup</a></code></li>
<li><code><a title="popnet.graphics.Result.times" href="#popnet.graphics.Result.times">times</a></code></li>
<li><code><a title="popnet.graphics.Result.x_units" href="#popnet.graphics.Result.x_units">x_units</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="popnet.graphics.Spectrum"><code class="flex name class">
<span>class <span class="ident">Spectrum</span></span>
<span>(</span><span>config, states, times, source, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represent spectra of other results.</p>
<p><code><a title="popnet.graphics.Spectrum" href="#popnet.graphics.Spectrum">Spectrum</a></code> extends <code><a title="popnet.graphics.Result" href="#popnet.graphics.Result">Result</a></code> for the case where the result is the spectrum
of another result. Specifically, it defines methods to plot the spectra of
state components, and it extends the options to setup a figure. Its data
attributes are the same as in the base class, but here <code>times</code> is replaced
with <code>freqs</code>; see <code><a title="popnet.graphics.Spectrum.freqs" href="#popnet.graphics.Spectrum.freqs">Spectrum.freqs</a></code>. Finally, <code><a title="popnet.graphics.Spectrum" href="#popnet.graphics.Spectrum">Spectrum</a></code> forgets
<code><a title="popnet.graphics.Result" href="#popnet.graphics.Result">Result</a></code>'s <code>load</code> and <code>get_spectrum</code> methods.</p>
<p>The recommended way of instantiating a <code><a title="popnet.graphics.Spectrum" href="#popnet.graphics.Spectrum">Spectrum</a></code> instance is from another
<code><a title="popnet.graphics.Result" href="#popnet.graphics.Result">Result</a></code> instance, with <code><a title="popnet.graphics.Result.get_spectrum" href="#popnet.graphics.Result.get_spectrum">Result.get_spectrum()</a></code>. Parameters at initialization
are a bit different here than in the base class, so they are listed again.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>config</code></strong> :&ensp;<code><a title="popnet.structures.Configuration" href="structures.html#popnet.structures.Configuration">Configuration</a></code></dt>
<dd>Configuration used to obtain the result.</dd>
<dt><strong><code>states</code></strong> :&ensp;<code>dict</code> of <code>array_like</code></dt>
<dd>Dictionary in which to each state component is associated with an array.
Such an array should give the values, for each combination of
populations, of the state component with respect to time. This is the
format in which data is kept internally in <code><a title="popnet.graphics.Result" href="#popnet.graphics.Result">Result</a></code> classes.</dd>
<dt><strong><code>times</code></strong> :&ensp;<code>array_like</code></dt>
<dd>An array representing time.</dd>
<dt><strong><code>source</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the class from which comes the spectrum.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>A name associated with the result. Defaults to <code>None</code>, in which case it
is replaced with <code><a title="popnet.graphics.Spectrum.default_name" href="#popnet.graphics.Graphics.default_name">Spectrum.default_name</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Spectrum(Result):
    &#34;&#34;&#34;Represent spectra of other results.

    `Spectrum` extends `Result` for the case where the result is the spectrum
    of another result. Specifically, it defines methods to plot the spectra of
    state components, and it extends the options to setup a figure. Its data
    attributes are the same as in the base class, but here `times` is replaced
    with `freqs`; see `Spectrum.freqs`. Finally, `Spectrum` forgets
    `Result`&#39;s `load` and `get_spectrum` methods.

    The recommended way of instantiating a `Spectrum` instance is from another
    `Result` instance, with `Result.get_spectrum`. Parameters at initialization
    are a bit different here than in the base class, so they are listed again.

    Parameters
    ----------
    config : popnet.structures.Configuration
        Configuration used to obtain the result.
    states : dict of array_like
        Dictionary in which to each state component is associated with an array.
        Such an array should give the values, for each combination of
        populations, of the state component with respect to time. This is the
        format in which data is kept internally in `Result` classes.
    times : array_like
        An array representing time.
    source : str
        Name of the class from which comes the spectrum.
    name : str, optional
        A name associated with the result. Defaults to `None`, in which case it
        is replaced with `Spectrum.default_name`.

    &#34;&#34;&#34;

    default_name = &#39;Spectrum&#39;
    &#34;&#34;&#34;Default name given to instances.&#34;&#34;&#34;
    x_units = &#39;Frequency&#39;
    &#34;&#34;&#34;Units of the horizontal axis.&#34;&#34;&#34;
    _lim_valid_values = {&#39;x&#39;: (&#39;freqs&#39;, &#39;config&#39;, &#39;unbounded&#39;), 
                         &#39;y&#39;: (&#39;unbounded&#39;,)}
    _sources_inst = (&#39;Trajectory&#39;,)
    _sources_average = (&#39;Solution&#39;, &#39;Solution (extended)&#39;, &#39;Statistics&#39;)
    _sources_order_2 = (&#39;Solution (extended)&#39;, &#39;Statistics&#39;)
    _sources_order_3 = (&#39;Statistics&#39;,)

    def __init__(self, config, states, times, source, name=None):
        if source not in (&#39;Result&#39;, &#39;Solution&#39;, &#39;Solution (extended)&#39;,
                          &#39;Trajectory&#39;, &#39;Statistics&#39;):
            raise ValueError(f&#39;Unknown source \&#39;{source}\&#39;.&#39;)
        self._source = source
        super().__init__(config, states, times, name)

    def __new__(cls, config, states, times, source, name=None):
        return super().__new__(cls, config, states, times, name=name)

    @classmethod
    def load(cls):
        raise AttributeError(&#39;\&#39;Spectrum\&#39; object has no attribute \&#39;load\&#39;&#39;)

    @property
    def freqs(self):
        &#34;&#34;&#34;Frequencies.

        Frequencies for which the Fourier transforms gives the amplitudes.
        Replaces `Result.times`.
        &#34;&#34;&#34;
        return self.times

    @freqs.setter
    def freqs(self, new_value):
        self.times = new_value

    def get_spectrum(self):
        raise AttributeError(&#39;\&#39;Spectrum\&#39; object has no attribute &#39;
                             &#39;\&#39;get_spectrum\&#39;&#39;)

    def plot_fractions(self, **kwargs):
        &#34;&#34;&#34;Plot spectra for all fractions of populations.

        Plot spectra of all active, refractory and sensitive fractions of
        populations on the figure `Spectrum.fig`.

        Parameters
        ----------
        **kwargs
            Keyword arguments to be passed to the method that plots components,
            which is the [`plot`](https://31c8.short.gy/ax-plot) method of
            `Spectrum.ax`.

        Raises
        ------
        popnet.exceptions.PopNetError
            If no figure and axes are bound to `Spectrum.fig` and `Spectrum.ax`.
        &#34;&#34;&#34;
        self._plot_all_one(**kwargs)

    def plot_variances(self, **kwargs):
        &#34;&#34;&#34;Plot spectra of all variances.

        Plot spectra of all variances of active, refractory and sensitive
        fractions of populations on the figure `Spectrum.fig`, if such
        variances are defined.

        Parameters
        ----------
        **kwargs
            Keyword arguments to be passed to the method that plots components,
            which is the [`plot`](https://31c8.short.gy/ax-plot) method of
            `Spectrum.ax`.

        Raises
        ------
        popnet.exceptions.PopNetError
            If no figure and axes are bound to `Spectrum.fig` and `Spectrum.ax`,
            or if no variances are defined for this result.
        &#34;&#34;&#34;
        if self._source in self._sources_order_2:
            self._plot_all_two(symmetric=True, nonsymmetric=False, **kwargs)
            return
        raise PopNetError(&#39;No variances defined for this result.&#39;)

    def plot_covariances(self, **kwargs):
        &#34;&#34;&#34;Plot spectra of all non-symmetric covariances.

        Plot spectra of all non-symmetric covariances of active, refractory and
        sensitive fractions of populations on the figure `Spectrum.fig`, if
        such covariances are defined.

        Parameters
        ----------
        **kwargs
            Keyword arguments to be passed to the method that plots components,
            which is the [`plot`](https://31c8.short.gy/ax-plot) method of
            `Spectrum.ax`.

        Raises
        ------
        popnet.exceptions.PopNetError
            If no figure and axes are bound to `Spectrum.fig` and `Spectrum.ax`,
            or if no covariances are defined for this result.
        &#34;&#34;&#34;
        if self._source in self._sources_order_2:
            self._plot_all_two(symmetric=False, nonsymmetric=True, **kwargs)
            return
        raise PopNetError(&#39;No covariances defined for this result.&#39;)

    def plot_third_moments(self, **kwargs):
        &#34;&#34;&#34;Plot spectra of all third central moments.

        Plot spectra of all third central moments of active, refractory and
        sensitive fractions of populations on the figure `Spectrum.fig`, if
        such moments are defined.

        Parameters
        ----------
        **kwargs
            Keyword arguments to be passed to the method that plots components,
            which is the [`plot`](https://31c8.short.gy/ax-plot) method of
            `Spectrum.ax`.

        Raises
        ------
        popnet.exceptions.PopNetError
            If no figure and axes are bound to `Spectrum.fig` and `Spectrum.ax`,
            or if no third central moments are defined for this result.
        &#34;&#34;&#34;
        if self._source in self._sources_order_3:
            self._plot_all_three(**kwargs)
            return
        raise PopNetError(&#39;No third central moments defined for this result.&#39;)

    def setup(self, set_xlabel=True, units=&#39;kHz&#39;, fontsize=10, xlim=&#39;freqs&#39;,
              yscale=&#39;linear&#39;):
        &#34;&#34;&#34;Setup a figure.

        Setup the figure `Spectrum.fig`. Extends the base class method by
        allowing to set the scale of the vertical axis. Also overrides the
        accepted values for `xlim`, and removes the option to bound the
        vertical axis.

        Parameters
        ----------
        set_xlabel : bool, optional
            Decides if the horizontal axis is labelled. Defaults to `True`.
        units : str, optional
            Frequency units for the horizontal axis, which should be the units
            in which the transition rates are given in the configuration. These
            units are indicated in square brackets on the figure, except if it
            is set to the empty string `&#39;&#39;`, in which case no extra square
            brackets are added. Defaults to `&#39;kHz&#39;`.
        fontsize : float, optional
            Font size in points for the horizontal axis&#39; label. Defaults to 10.
        xlim : {&#39;freqs&#39;, &#39;config&#39;, &#39;unbounded&#39;}, optional
            Decides how the horizontal axis is bounded. If `&#39;freqs&#39;`, it is
            bounded between 0 and the highest frequency. If `&#39;config&#39;`, it is
            bounded between 0 and the highest frequency obtained from the times
            array given by the configuration. If `&#39;unbounded&#39;`, it is not
            bounded. Defaults to `&#39;freqs&#39;`.
        yscale : {&#39;linear&#39;, &#39;log&#39;}, optional
            Defines the scale of the vertical axis. Defaults to `&#39;linear&#39;`.

        Raises
        ------
        popnet.exceptions.PopNetError
            If no figure and axes are bound to `Result.fig` and `Result.ax`.
        ValueError
            If `xlim` is given a non-valid value.
        &#34;&#34;&#34;
        super().setup(set_xlabel=set_xlabel, units=units, fontsize=fontsize,
                      xlim=xlim, ylim=&#39;unbounded&#39;)
        try:
            self.ax.set_yscale(yscale)
        except AttributeError as error:
            raise TypeError(f&#39;\&#39;yscale\&#39; must be a string.&#39;) from error

    def _default_plots(self, expectations=True, variances=True, 
                       covariances=False, third_moments=False):
        &#34;&#34;&#34;Add plots on the default figure.&#34;&#34;&#34;
        sym = self._source in self._sources_order_2 and variances
        nonsym = self._source in self._sources_order_2 and covariances
        three = self._source in self._sources_order_3 and third_moments
        super()._default_plots(one=expectations, symmetric=sym, 
                               nonsymmetric=nonsym, three=three)

    def _init_abscissa(self, times):
        &#34;&#34;&#34;Initialize array related to the independant variable.&#34;&#34;&#34;
        size = round(len(times)/2+.8)
        # If n is the length of the times array, the size of freqs has to be
        # n/2 + 1 if n is even, and (n+1)/2 if n is odd.
        self._times = np.linspace(0, len(times) / times[-1], size)

    def _init_colors(self):
        &#34;&#34;&#34;Initialize the colors associated with state variables.&#34;&#34;&#34;
        super()._init_colors()
        if self._source in self._sources_order_2:
            self._add_colors_items_two()
        if self._source in self._sources_order_3:
            self._add_colors_items_three()

    def _init_plot_methods(self):
        &#34;&#34;&#34;Initialize plotting methods of state variables.&#34;&#34;&#34;
        super()._init_plot_methods()
        if self._source in self._sources_order_2:
            self._plot = {**self._plot, **self._plot_dict_two()}
        if self._source in self._sources_order_3:
            self._plot = {**self._plot, **self._plot_dict_three()}

    def _init_states_dict(self, states):
        &#34;&#34;&#34;Initialize the state variables dictionary.&#34;&#34;&#34;
        p = len(self.config.network.populations)
        self._states_dict = dict.fromkeys(states)
        axes = {&#39;A&#39;: 1, &#39;R&#39;: 1, &#39;S&#39;: 1, &#39;CAA&#39;: 2, &#39;CRR&#39;: 2, &#39;CSS&#39;: 2, &#39;CAR&#39;: 2,
                &#39;CAS&#39;: 2, &#39;CRS&#39;: 2, &#39;AAA&#39;: 3, &#39;AAR&#39;: 3, &#39;AAS&#39;: 3, &#39;ARR&#39;: 3,
                &#39;ARS&#39;: 3, &#39;ASS&#39;: 3, &#39;RRR&#39;: 3, &#39;RRS&#39;: 3, &#39;RSS&#39;: 3, &#39;SSS&#39;: 3}
        for key in states:
            if key in axes:
                transform = np.fft.rfft(states[key], axis=axes[key])
                self._states_dict[key] = np.abs(transform)
            else:
                raise ValueError(f&#39;{key} is not a valid state variable.&#39;)

    def _label_one(self, X, J):
        &#34;&#34;&#34;Label for the spectrum of `X` for the `J`th population.&#34;&#34;&#34;
        J_ID = self.config.network.populations[J].ID
        if self._source in self._sources_average:
            return f&#39;$\\hat{{\\mathcal{{{X}}}}}_{{{J_ID}}}$&#39;
        elif self._source in self._sources_inst:
            return f&#39;$\\hat{{{X}}}_{{{J_ID}}}$&#39;

    def _label_two(self, XY, J, K):
        &#34;&#34;&#34;Label for the spectrum of the covariance between `X` and `Y` for the
        `J`th and `K`th populations.&#34;&#34;&#34;
        IDs = &#39;&#39;.join([self.config.network.populations[P].ID for P in (J, K)])
        return f&#39;$\\hat{{\\mathrm{{C}}}}_{{{XY}}}^{{{IDs}}}$&#39;

    def _label_three(self, XYZ, J, K, L):
        &#34;&#34;&#34;Label for the spectrum of the third central between `X`, `Y` and `Z`
        for the `J`th, `K`th and `L`th populations.&#34;&#34;&#34;
        IDs = &#39;&#39;.join([self.config.network.populations[P].ID for P in (J, K, L)])
        return f&#39;$\\hat{{\\mathrm{{M}}}}_{{{XYZ}}}^{{{IDs}}}$&#39;

    def _set_xlim(self, xlim):
        &#34;&#34;&#34;Set the limits of the horizontal axis of a figure.&#34;&#34;&#34;
        super()._set_xlim(xlim)
        if xlim == &#39;freqs&#39;:
            self.ax.set_xlim([0, self.freqs[-1]])
        elif xlim == &#39;config&#39;:
            upper = (1+self.config.iterations) / self.config.final_time
            self.ax.set_xlim([0, upper])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="popnet.graphics.Result" href="#popnet.graphics.Result">Result</a></li>
<li><a title="popnet.graphics.Graphics" href="#popnet.graphics.Graphics">Graphics</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>popnet.graphics._SpectrumOne</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="popnet.graphics.Spectrum.freqs"><code class="name">var <span class="ident">freqs</span></code></dt>
<dd>
<div class="desc"><p>Frequencies.</p>
<p>Frequencies for which the Fourier transforms gives the amplitudes.
Replaces <code><a title="popnet.graphics.Result.times" href="#popnet.graphics.Result.times">Result.times</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def freqs(self):
    &#34;&#34;&#34;Frequencies.

    Frequencies for which the Fourier transforms gives the amplitudes.
    Replaces `Result.times`.
    &#34;&#34;&#34;
    return self.times</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="popnet.graphics.Spectrum.plot_covariances"><code class="name flex">
<span>def <span class="ident">plot_covariances</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot spectra of all non-symmetric covariances.</p>
<p>Plot spectra of all non-symmetric covariances of active, refractory and
sensitive fractions of populations on the figure <code><a title="popnet.graphics.Spectrum.fig" href="#popnet.graphics.Graphics.fig">Spectrum.fig</a></code>, if
such covariances are defined.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments to be passed to the method that plots components,
which is the <a href="https://31c8.short.gy/ax-plot"><code>plot</code></a> method of
<code><a title="popnet.graphics.Spectrum.ax" href="#popnet.graphics.Graphics.ax">Spectrum.ax</a></code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="popnet.exceptions.PopNetError" href="exceptions.html#popnet.exceptions.PopNetError">PopNetError</a></code></dt>
<dd>If no figure and axes are bound to <code><a title="popnet.graphics.Spectrum.fig" href="#popnet.graphics.Graphics.fig">Spectrum.fig</a></code> and <code><a title="popnet.graphics.Spectrum.ax" href="#popnet.graphics.Graphics.ax">Spectrum.ax</a></code>,
or if no covariances are defined for this result.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_covariances(self, **kwargs):
    &#34;&#34;&#34;Plot spectra of all non-symmetric covariances.

    Plot spectra of all non-symmetric covariances of active, refractory and
    sensitive fractions of populations on the figure `Spectrum.fig`, if
    such covariances are defined.

    Parameters
    ----------
    **kwargs
        Keyword arguments to be passed to the method that plots components,
        which is the [`plot`](https://31c8.short.gy/ax-plot) method of
        `Spectrum.ax`.

    Raises
    ------
    popnet.exceptions.PopNetError
        If no figure and axes are bound to `Spectrum.fig` and `Spectrum.ax`,
        or if no covariances are defined for this result.
    &#34;&#34;&#34;
    if self._source in self._sources_order_2:
        self._plot_all_two(symmetric=False, nonsymmetric=True, **kwargs)
        return
    raise PopNetError(&#39;No covariances defined for this result.&#39;)</code></pre>
</details>
</dd>
<dt id="popnet.graphics.Spectrum.plot_fractions"><code class="name flex">
<span>def <span class="ident">plot_fractions</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot spectra for all fractions of populations.</p>
<p>Plot spectra of all active, refractory and sensitive fractions of
populations on the figure <code><a title="popnet.graphics.Spectrum.fig" href="#popnet.graphics.Graphics.fig">Spectrum.fig</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments to be passed to the method that plots components,
which is the <a href="https://31c8.short.gy/ax-plot"><code>plot</code></a> method of
<code><a title="popnet.graphics.Spectrum.ax" href="#popnet.graphics.Graphics.ax">Spectrum.ax</a></code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="popnet.exceptions.PopNetError" href="exceptions.html#popnet.exceptions.PopNetError">PopNetError</a></code></dt>
<dd>If no figure and axes are bound to <code><a title="popnet.graphics.Spectrum.fig" href="#popnet.graphics.Graphics.fig">Spectrum.fig</a></code> and <code><a title="popnet.graphics.Spectrum.ax" href="#popnet.graphics.Graphics.ax">Spectrum.ax</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_fractions(self, **kwargs):
    &#34;&#34;&#34;Plot spectra for all fractions of populations.

    Plot spectra of all active, refractory and sensitive fractions of
    populations on the figure `Spectrum.fig`.

    Parameters
    ----------
    **kwargs
        Keyword arguments to be passed to the method that plots components,
        which is the [`plot`](https://31c8.short.gy/ax-plot) method of
        `Spectrum.ax`.

    Raises
    ------
    popnet.exceptions.PopNetError
        If no figure and axes are bound to `Spectrum.fig` and `Spectrum.ax`.
    &#34;&#34;&#34;
    self._plot_all_one(**kwargs)</code></pre>
</details>
</dd>
<dt id="popnet.graphics.Spectrum.plot_third_moments"><code class="name flex">
<span>def <span class="ident">plot_third_moments</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot spectra of all third central moments.</p>
<p>Plot spectra of all third central moments of active, refractory and
sensitive fractions of populations on the figure <code><a title="popnet.graphics.Spectrum.fig" href="#popnet.graphics.Graphics.fig">Spectrum.fig</a></code>, if
such moments are defined.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments to be passed to the method that plots components,
which is the <a href="https://31c8.short.gy/ax-plot"><code>plot</code></a> method of
<code><a title="popnet.graphics.Spectrum.ax" href="#popnet.graphics.Graphics.ax">Spectrum.ax</a></code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="popnet.exceptions.PopNetError" href="exceptions.html#popnet.exceptions.PopNetError">PopNetError</a></code></dt>
<dd>If no figure and axes are bound to <code><a title="popnet.graphics.Spectrum.fig" href="#popnet.graphics.Graphics.fig">Spectrum.fig</a></code> and <code><a title="popnet.graphics.Spectrum.ax" href="#popnet.graphics.Graphics.ax">Spectrum.ax</a></code>,
or if no third central moments are defined for this result.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_third_moments(self, **kwargs):
    &#34;&#34;&#34;Plot spectra of all third central moments.

    Plot spectra of all third central moments of active, refractory and
    sensitive fractions of populations on the figure `Spectrum.fig`, if
    such moments are defined.

    Parameters
    ----------
    **kwargs
        Keyword arguments to be passed to the method that plots components,
        which is the [`plot`](https://31c8.short.gy/ax-plot) method of
        `Spectrum.ax`.

    Raises
    ------
    popnet.exceptions.PopNetError
        If no figure and axes are bound to `Spectrum.fig` and `Spectrum.ax`,
        or if no third central moments are defined for this result.
    &#34;&#34;&#34;
    if self._source in self._sources_order_3:
        self._plot_all_three(**kwargs)
        return
    raise PopNetError(&#39;No third central moments defined for this result.&#39;)</code></pre>
</details>
</dd>
<dt id="popnet.graphics.Spectrum.plot_variances"><code class="name flex">
<span>def <span class="ident">plot_variances</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot spectra of all variances.</p>
<p>Plot spectra of all variances of active, refractory and sensitive
fractions of populations on the figure <code><a title="popnet.graphics.Spectrum.fig" href="#popnet.graphics.Graphics.fig">Spectrum.fig</a></code>, if such
variances are defined.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments to be passed to the method that plots components,
which is the <a href="https://31c8.short.gy/ax-plot"><code>plot</code></a> method of
<code><a title="popnet.graphics.Spectrum.ax" href="#popnet.graphics.Graphics.ax">Spectrum.ax</a></code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="popnet.exceptions.PopNetError" href="exceptions.html#popnet.exceptions.PopNetError">PopNetError</a></code></dt>
<dd>If no figure and axes are bound to <code><a title="popnet.graphics.Spectrum.fig" href="#popnet.graphics.Graphics.fig">Spectrum.fig</a></code> and <code><a title="popnet.graphics.Spectrum.ax" href="#popnet.graphics.Graphics.ax">Spectrum.ax</a></code>,
or if no variances are defined for this result.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_variances(self, **kwargs):
    &#34;&#34;&#34;Plot spectra of all variances.

    Plot spectra of all variances of active, refractory and sensitive
    fractions of populations on the figure `Spectrum.fig`, if such
    variances are defined.

    Parameters
    ----------
    **kwargs
        Keyword arguments to be passed to the method that plots components,
        which is the [`plot`](https://31c8.short.gy/ax-plot) method of
        `Spectrum.ax`.

    Raises
    ------
    popnet.exceptions.PopNetError
        If no figure and axes are bound to `Spectrum.fig` and `Spectrum.ax`,
        or if no variances are defined for this result.
    &#34;&#34;&#34;
    if self._source in self._sources_order_2:
        self._plot_all_two(symmetric=True, nonsymmetric=False, **kwargs)
        return
    raise PopNetError(&#39;No variances defined for this result.&#39;)</code></pre>
</details>
</dd>
<dt id="popnet.graphics.Spectrum.setup"><code class="name flex">
<span>def <span class="ident">setup</span></span>(<span>self, set_xlabel=True, units='kHz', fontsize=10, xlim='freqs', yscale='linear')</span>
</code></dt>
<dd>
<div class="desc"><p>Setup a figure.</p>
<p>Setup the figure <code><a title="popnet.graphics.Spectrum.fig" href="#popnet.graphics.Graphics.fig">Spectrum.fig</a></code>. Extends the base class method by
allowing to set the scale of the vertical axis. Also overrides the
accepted values for <code>xlim</code>, and removes the option to bound the
vertical axis.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>set_xlabel</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Decides if the horizontal axis is labelled. Defaults to <code>True</code>.</dd>
<dt><strong><code>units</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Frequency units for the horizontal axis, which should be the units
in which the transition rates are given in the configuration. These
units are indicated in square brackets on the figure, except if it
is set to the empty string <code>''</code>, in which case no extra square
brackets are added. Defaults to <code>'kHz'</code>.</dd>
<dt><strong><code>fontsize</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Font size in points for the horizontal axis' label. Defaults to 10.</dd>
<dt><strong><code>xlim</code></strong> :&ensp;<code>{'freqs', 'config', 'unbounded'}</code>, optional</dt>
<dd>Decides how the horizontal axis is bounded. If <code>'freqs'</code>, it is
bounded between 0 and the highest frequency. If <code>'config'</code>, it is
bounded between 0 and the highest frequency obtained from the times
array given by the configuration. If <code>'unbounded'</code>, it is not
bounded. Defaults to <code>'freqs'</code>.</dd>
<dt><strong><code>yscale</code></strong> :&ensp;<code>{'linear', 'log'}</code>, optional</dt>
<dd>Defines the scale of the vertical axis. Defaults to <code>'linear'</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="popnet.exceptions.PopNetError" href="exceptions.html#popnet.exceptions.PopNetError">PopNetError</a></code></dt>
<dd>If no figure and axes are bound to <code><a title="popnet.graphics.Result.fig" href="#popnet.graphics.Graphics.fig">Result.fig</a></code> and <code><a title="popnet.graphics.Result.ax" href="#popnet.graphics.Graphics.ax">Result.ax</a></code>.</dd>
<dt><code>ValueError</code></dt>
<dd>If <code>xlim</code> is given a non-valid value.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup(self, set_xlabel=True, units=&#39;kHz&#39;, fontsize=10, xlim=&#39;freqs&#39;,
          yscale=&#39;linear&#39;):
    &#34;&#34;&#34;Setup a figure.

    Setup the figure `Spectrum.fig`. Extends the base class method by
    allowing to set the scale of the vertical axis. Also overrides the
    accepted values for `xlim`, and removes the option to bound the
    vertical axis.

    Parameters
    ----------
    set_xlabel : bool, optional
        Decides if the horizontal axis is labelled. Defaults to `True`.
    units : str, optional
        Frequency units for the horizontal axis, which should be the units
        in which the transition rates are given in the configuration. These
        units are indicated in square brackets on the figure, except if it
        is set to the empty string `&#39;&#39;`, in which case no extra square
        brackets are added. Defaults to `&#39;kHz&#39;`.
    fontsize : float, optional
        Font size in points for the horizontal axis&#39; label. Defaults to 10.
    xlim : {&#39;freqs&#39;, &#39;config&#39;, &#39;unbounded&#39;}, optional
        Decides how the horizontal axis is bounded. If `&#39;freqs&#39;`, it is
        bounded between 0 and the highest frequency. If `&#39;config&#39;`, it is
        bounded between 0 and the highest frequency obtained from the times
        array given by the configuration. If `&#39;unbounded&#39;`, it is not
        bounded. Defaults to `&#39;freqs&#39;`.
    yscale : {&#39;linear&#39;, &#39;log&#39;}, optional
        Defines the scale of the vertical axis. Defaults to `&#39;linear&#39;`.

    Raises
    ------
    popnet.exceptions.PopNetError
        If no figure and axes are bound to `Result.fig` and `Result.ax`.
    ValueError
        If `xlim` is given a non-valid value.
    &#34;&#34;&#34;
    super().setup(set_xlabel=set_xlabel, units=units, fontsize=fontsize,
                  xlim=xlim, ylim=&#39;unbounded&#39;)
    try:
        self.ax.set_yscale(yscale)
    except AttributeError as error:
        raise TypeError(f&#39;\&#39;yscale\&#39; must be a string.&#39;) from error</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="popnet.graphics.Result" href="#popnet.graphics.Result">Result</a></b></code>:
<ul class="hlist">
<li><code><a title="popnet.graphics.Result.A" href="#popnet.graphics.Result.A">A</a></code></li>
<li><code><a title="popnet.graphics.Result.CAA" href="#popnet.graphics.Result.CAA">CAA</a></code></li>
<li><code><a title="popnet.graphics.Result.CAR" href="#popnet.graphics.Result.CAR">CAR</a></code></li>
<li><code><a title="popnet.graphics.Result.CAS" href="#popnet.graphics.Result.CAS">CAS</a></code></li>
<li><code><a title="popnet.graphics.Result.CRR" href="#popnet.graphics.Result.CRR">CRR</a></code></li>
<li><code><a title="popnet.graphics.Result.CRS" href="#popnet.graphics.Result.CRS">CRS</a></code></li>
<li><code><a title="popnet.graphics.Result.CSS" href="#popnet.graphics.Result.CSS">CSS</a></code></li>
<li><code><a title="popnet.graphics.Result.R" href="#popnet.graphics.Result.R">R</a></code></li>
<li><code><a title="popnet.graphics.Result.S" href="#popnet.graphics.Result.S">S</a></code></li>
<li><code><a title="popnet.graphics.Result.activate" href="#popnet.graphics.Graphics.activate">activate</a></code></li>
<li><code><a title="popnet.graphics.Result.ax" href="#popnet.graphics.Graphics.ax">ax</a></code></li>
<li><code><a title="popnet.graphics.Result.colors" href="#popnet.graphics.Result.colors">colors</a></code></li>
<li><code><a title="popnet.graphics.Result.config" href="#popnet.graphics.Graphics.config">config</a></code></li>
<li><code><a title="popnet.graphics.Result.default_figure" href="#popnet.graphics.Result.default_figure">default_figure</a></code></li>
<li><code><a title="popnet.graphics.Result.default_name" href="#popnet.graphics.Graphics.default_name">default_name</a></code></li>
<li><code><a title="popnet.graphics.Result.draw" href="#popnet.graphics.Graphics.draw">draw</a></code></li>
<li><code><a title="popnet.graphics.Result.fig" href="#popnet.graphics.Graphics.fig">fig</a></code></li>
<li><code><a title="popnet.graphics.Result.get_spectrum" href="#popnet.graphics.Result.get_spectrum">get_spectrum</a></code></li>
<li><code><a title="popnet.graphics.Result.legend" href="#popnet.graphics.Graphics.legend">legend</a></code></li>
<li><code><a title="popnet.graphics.Result.load" href="#popnet.graphics.Result.load">load</a></code></li>
<li><code><a title="popnet.graphics.Result.name" href="#popnet.graphics.Graphics.name">name</a></code></li>
<li><code><a title="popnet.graphics.Result.plot" href="#popnet.graphics.Result.plot">plot</a></code></li>
<li><code><a title="popnet.graphics.Result.times" href="#popnet.graphics.Result.times">times</a></code></li>
<li><code><a title="popnet.graphics.Result.x_units" href="#popnet.graphics.Result.x_units">x_units</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="popnet.graphics.Statistics"><code class="flex name class">
<span>class <span class="ident">Statistics</span></span>
<span>(</span><span>config, states, times, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represent statistics obtained from sample trajectories.</p>
<p><code><a title="popnet.graphics.Statistics" href="#popnet.graphics.Statistics">Statistics</a></code> extends <code><a title="popnet.graphics.Result" href="#popnet.graphics.Result">Result</a></code> for the case where the result is a set of
statistics obtained from multiple trajectories of a stochastic process
that rules the microscopic evolution of the network.</p>
<p>The most important extension from the <code><a title="popnet.graphics.Result" href="#popnet.graphics.Result">Result</a></code> class is a set of methods to
plot fills between given bounds around a mean value, and methods to plot the
minimum and maximum values of a variable at each time step. For details,
see <code><a title="popnet.graphics.Statistics.fill" href="#popnet.graphics.Statistics.fill">Statistics.fill</a></code>, <code><a title="popnet.graphics.Statistics.plot_max" href="#popnet.graphics.Statistics.plot_max">Statistics.plot_max</a></code> and <code><a title="popnet.graphics.Statistics.plot_min" href="#popnet.graphics.Statistics.plot_min">Statistics.plot_min</a></code>.
Besides these new methods, it also adds other methods to plot several state
components at once, and it adapts the loading method. Other changes are
implementation details.</p>
<p>The parameters at initialization are the same as in the base class, except
that <code>states</code> is now expected to be a three-dimensional array of <em>samples</em>
of trajectories of the stochastic process, with time along the first axis,
state variables along the second, and different simulations along the third.
Note that this is the format of samples handled by
<code><a title="popnet.executors.ChainSimulator" href="executors.html#popnet.executors.ChainSimulator">ChainSimulator</a></code>.</p>
<h2 id="warns">Warns</h2>
<dl>
<dt><code><a title="popnet.exceptions.PopNetWarning" href="exceptions.html#popnet.exceptions.PopNetWarning">PopNetWarning</a></code></dt>
<dd>If the given samples do not provide enough trajectories to compute
unbiased estimates of central moments.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Statistics(Result):
    &#34;&#34;&#34;Represent statistics obtained from sample trajectories.

    `Statistics` extends `Result` for the case where the result is a set of
    statistics obtained from multiple trajectories of a stochastic process
    that rules the microscopic evolution of the network.

    The most important extension from the `Result` class is a set of methods to
    plot fills between given bounds around a mean value, and methods to plot the
    minimum and maximum values of a variable at each time step. For details,
    see `Statistics.fill`, `Statistics.plot_max` and `Statistics.plot_min`.
    Besides these new methods, it also adds other methods to plot several state
    components at once, and it adapts the loading method. Other changes are
    implementation details.

    The parameters at initialization are the same as in the base class, except
    that `states` is now expected to be a three-dimensional array of *samples*
    of trajectories of the stochastic process, with time along the first axis,
    state variables along the second, and different simulations along the third.
    Note that this is the format of samples handled by
    `popnet.executors.ChainSimulator`.

    Warns
    -----
    popnet.exceptions.PopNetWarning
        If the given samples do not provide enough trajectories to compute
        unbiased estimates of central moments.

    &#34;&#34;&#34;

    default_name = &#39;Statistics&#39;
    &#34;&#34;&#34;Default name given to instances.&#34;&#34;&#34;
    default_sample_name = &#39;Sample&#39;
    &#34;&#34;&#34;Default name for samples used when loading them.&#34;&#34;&#34;

    @classmethod
    def load(cls, ID, sample_name=None, name=None, config=None, folder=None):
        &#34;&#34;&#34;Compute statistics from loaded sample trajectories.

        Compute statistics needed to define a `Statistics` instance from loaded
        samples. For each component *X*, the samples are assumed to be in a
        file named *ID - sample_name X.txt*, where *ID* and *sample_name* are
        indeed `ID` and `sample_name`. In the file for a component *X*, it is
        assumed that in each column are the values of *X* with respect to time
        for a given trajectory.

        Parameters
        ----------
        ID : str
            ID of the configuration used to obtain the samples. 
        sample_name : str, optional
            Name associated with the samples to be loaded. Defaults to `None`,
            in which case is it replaced with `&#39;Sample&#39;`.
        name : str, optional
            Name associated with the result. Defaults to `None`, in which case
            it is replaced with `&#39;Statistics&#39;`.
        config : popnet.structures.Configuration, optional
            Configuration to associate with the result. If given, it must have
            the ID `ID`. Defaults to `None`, in which case it is loaded from ID
            `ID`.
        folder : str, optional
            Folder in which the files are located, which should be placed in the
            current directory. Defaults to `None`, in which case the files are
            assumed to be located in the current directory.

        Returns
        -------
        Statistics
            Statistics computed from the loaded samples.

        Raises
        ------
        TypeError
            If `config` is neither `None` nor a
            `popnet.structures.Configuration` instance.
        popnet.exceptions.PopNetError
            If `config` has a different ID than `ID`. 
        FileNotFoundError
            If no file is found with the expected name for a component.
        &#34;&#34;&#34;
        config = cls._check_config(config, ID)
        sample_name = cls._get_sample_name(sample_name)
        samples = []
        p = len(config.network.populations)
        for J, X in enumerate(config._variables[:2*p]):
            filename = _internals._format_filename(
                            folder, ID, f&#39;{sample_name} {X}&#39;)
            try:
                samples.append(np.loadtxt(filename, dtype=float))
            except FileNotFoundError as e:
                raise FileNotFoundError(&#39;No samples found for the component &#39;
                                        f&#39;{X} with configuration {ID}.&#39;) from e
        samples = np.transpose(samples, axes=(1,0,2))
        times = np.linspace(config.initial_time, config.final_time, 
                            1 + config.iterations)
        name = cls._get_name(name)
        return cls(config, samples, times, name)

    @property
    def fill(self):
        &#34;&#34;&#34;Dictionary of methods to add fills for state variables.

        if *X* denotes a state variable (that is, either *A*, *R* or *S*), then
        `fill[&#39;X&#39;]` is a list whose *J*th element is a method which adds a fill
        around the mean value, between two bounds. By default, the bounds are
        given by one standard deviation on each side of the mean value. These
        methods all accept the same arguments as `Statistics.fill_all`.

        In the case where the network has only one population, the lists are all
        replaced with the single element they would contain. For example,
        `fill[&#39;A&#39;]` is directly a method to add a fill around the mean value of
        the network&#39;s activity.

        When called, these methods add fills for the corresponding state
        components on the axes `Statistics.ax` of the figure `Statistics.fig`.
        They all accept keyword arguments that can be passed to the
        [`fill_between`](https://31c8.short.gy/ax-fill-between) method of
        `Statistics.ax`. This attribute cannot be set nor deleted.
        &#34;&#34;&#34;
        return self._fill

    @property
    def plot_max(self):
        &#34;&#34;&#34;Dictionary of methods to plot maxima of state variables.

        Analogous dictionary as `Statistics.plot` with keys `&#39;A&#39;`, `&#39;R&#39;` and
        `&#39;S&#39;`, but were the methods plot *maxima* of state variables instead of
        their mean values.
        &#34;&#34;&#34;
        return self._plot_max

    @property
    def plot_min(self):
        &#34;&#34;&#34;Dictionary of methods to plot minima of state variables.

        Analogous dictionary as `Statistics.plot` with keys `&#39;A&#39;`, `&#39;R&#39;` and
        `&#39;S&#39;`, but were the methods plot *minima* of state variables instead of
        their mean values.
        &#34;&#34;&#34;
        return self._plot_min
        
    def fill_all(self, bound=&#39;std&#39;, alpha=.25, **kwargs):
        &#34;&#34;&#34;Add fills between given bounds.

        Add fills between given bounds around the mean values of all fractions
        of populations.

        Parameters
        ----------
        bound : {&#39;std&#39;, &#39;extrema&#39;}, optional
            Describes the bounds between which to fill. If `&#39;std&#39;`, the region
            bounded by one standard deviation around the mean value is filled.
            If `&#39;extrema&#39;`, the region bounded by the minimum and maximum
            values of the component is filled. Defaults to `&#39;std&#39;`.
        alpha : float
            Transparency parameter of the fill. Defaults to 0.25.
        **kwargs
            Keyword arguments to be passed to the method that adds the fills,
            which is the [`fill_between`](https://31c8.short.gy/ax-fill-between)
            method of `Statistics.ax`.
        &#34;&#34;&#34;
        self._fill_all(bound, alpha, **kwargs)

    def plot_averages(self, **kwargs):
        &#34;&#34;&#34;Plot all averages of fractions of populations.

        Plot all sample means of active, refractory and sensitive fractions of
        populations on the figure `Statistics.fig`.

        Parameters
        ----------
        **kwargs
            Keyword arguments to be passed to the method that plots components,
            which is the [`plot`](https://31c8.short.gy/ax-plot) method of
            `Statistics.ax`.

        Raises
        ------
        popnet.exceptions.PopNetError
            If no figure and axes are bound to `Statistics.fig` and
            `Statistics.ax`.
        &#34;&#34;&#34;
        self._plot_all_one(**kwargs)

    def plot_variances(self, **kwargs):
        &#34;&#34;&#34;Plot all variances of fractions of populations.

        Plot all sample variances of active, refractory and sensitive fractions
        of populations on the figure `Statistics.fig`.

        Parameters
        ----------
        **kwargs
            Keyword arguments to be passed to the method that plots components,
            which is the [`plot`](https://31c8.short.gy/ax-plot) method of
            `Statistics.ax`.

        Raises
        ------
        popnet.exceptions.PopNetError
            If no figure and axes are bound to `Statistics.fig` and
            `Statistics.ax`.
        &#34;&#34;&#34;
        self._plot_all_two(symmetric=True, nonsymmetric=False, **kwargs)

    def plot_covariances(self, **kwargs):
        &#34;&#34;&#34;Plot all non-symmetric covariances of fractions of populations.

        Plot all non-symmetric sample covariances between active, refractory and
        sensitive fractions of populations on the figure `Statistics.fig`.

        Parameters
        ----------
        **kwargs
            Keyword arguments to be passed to the method that plots components,
            which is the [`plot`](https://31c8.short.gy/ax-plot) method of
            `Statistics.ax`.

        Raises
        ------
        popnet.exceptions.PopNetError
            If no figure and axes are bound to `Statistics.fig` and
            `Statistics.ax`.
        &#34;&#34;&#34;
        self._plot_all_two(symmetric=False, nonsymmetric=True, **kwargs)

    def plot_third_moments(self, **kwargs):
        &#34;&#34;&#34;Plot all third central moments of fractions of population.

        Plot all sample third central moments of active, refractory and
        sensitive fractions of populations on the figure `Statistics.fig`.

        Parameters
        ----------
        **kwargs
            Keyword arguments to be passed to the method that plots components,
            which is the [`plot`](https://31c8.short.gy/ax-plot) method of
            `Statistics.ax`.

        Raises
        ------
        popnet.exceptions.PopNetError
            If no figure and axes are bound to `Statistics.fig` and
            `Statistics.ax`.
        &#34;&#34;&#34;
        self._plot_all_three(**kwargs)

    def _default_plots(self, expectations=True, variances=True,
                       covariances=False, third_moments=False):
        &#34;&#34;&#34;Add plots on the default figure.&#34;&#34;&#34;
        super()._default_plots(one=expectations, symmetric=variances, 
                               nonsymmetric=covariances, three=third_moments)

    def _fill_all(self, bound, alpha, **kwargs):
        &#34;&#34;&#34;Add fills for all *A*&#39;s, *R*&#39;s and *S*&#39;s.&#34;&#34;&#34;
        p = len(self.config.network.populations)
        for J in range(p):
            for X in [&#39;A&#39;, &#39;R&#39;, &#39;S&#39;]:
                self.fill[X][J](bound=bound, alpha=alpha, **kwargs)

    def _fill_dict(self):
        &#34;&#34;&#34;Return a dictionary of methods to add fills for each population.&#34;&#34;&#34;
        p = len(self.config.network.populations)
        return {X: [self._make_fill(X, J) for J in range(p)]
                for X in [&#39;A&#39;, &#39;R&#39;, &#39;S&#39;]}

    @staticmethod
    def _get_central_moment(samples, stacklevel=1):
        &#34;&#34;&#34;Compute a central moment from samples.

        Compute a central moment from samples. The axes of `samples` are assumed
        to be ordered in the same way as those handled by `ChainSimulator`, but
        the second axis is assumed to span only the relevant components. Hence,
        if the second axis has length *k*, the central moment computed is of
        order *k*.
        &#34;&#34;&#34;
        T = len(samples)
        order = len(samples[0])
        executions = len(samples[0,0])
        coeff = 1 / executions
        if order == 2:
            if executions &gt; 1:
                coeff = 1 / (executions - 1)
            else:
                warn(&#39;Not enough executions to compute an unbiased estimate of &#39;
                     &#39;a covariance. A biased one is computed instead.&#39;,
                     category=PopNetWarning, stacklevel=stacklevel)
        elif order == 3:
            if executions &gt; 2:
                coeff = executions / ((executions - 1) * (executions - 2))
            else:
                warn(&#39;Not enough executions to compute an unbiased estimate of &#39;
                     &#39;a third central moment. A biased one is computed &#39;
                     &#39;instead.&#39;, category=PopNetWarning, stacklevel=stacklevel)
        means = np.mean(samples, axis=2)
        means = np.resize(means, (executions, T, order)).transpose(1,2,0)
        prod = np.prod(samples - means, axis=1)
        return coeff * np.sum(prod, axis=1)

    @classmethod
    def _get_sample_name(cls, sample_name):
        &#34;&#34;&#34;Return `sample_name`, or the default sample name if it is `None`.&#34;&#34;&#34;
        if sample_name is None:
            return cls.default_sample_name
        else:
            return sample_name

    def _init_colors(self):
        &#34;&#34;&#34;Initialize the colors associated with state variables.&#34;&#34;&#34;
        super()._init_colors()
        self._add_colors_items_two()
        self._add_colors_items_three()

    def _init_plot_methods(self):
        &#34;&#34;&#34;Initialize plotting methods of state variables.&#34;&#34;&#34;
        super()._init_plot_methods()
        self._plot = {**self.plot, **self._plot_dict_two(), 
                      **self._plot_dict_three()}
        self._plot_min = self._plot_dict_one(states=self._min_dict, ls=&#39;--&#39;,
                                             lw=1, label_func=self._label_min)
        self._plot_max = self._plot_dict_one(states=self._max_dict, ls=&#39;--&#39;,
                                             lw=1, label_func=self._label_max)
        self._fill = self._fill_dict()

    def _init_states_dict(self, samples):
        &#34;&#34;&#34;Initialize the state variables dictionary.&#34;&#34;&#34;
        p = round(len(samples[0]) / 2)
        samples_S = 1 - samples[:,:p] - samples[:,p:]
        samples = np.concatenate((samples, samples_S), axis=1)
        zero = {&#39;A&#39;: 0, &#39;R&#39;: p, &#39;S&#39;: 2*p}

        self._min_dict = {X: [np.min(samples[:,zero[X]+J], axis=1) 
                              for J in range(p)]
                          for X in [&#39;A&#39;, &#39;R&#39;, &#39;S&#39;]}
        self._max_dict = {X: [np.max(samples[:,zero[X]+J], axis=1) 
                              for J in range(p)]
                          for X in [&#39;A&#39;, &#39;R&#39;, &#39;S&#39;]}
        expect = {X: [np.mean(samples[:,zero[X]+J], axis=1) for J in range(p)]
                  for X in [&#39;A&#39;, &#39;R&#39;, &#39;S&#39;]}

        def element(CXY, J, K):
            C, X, Y = CXY
            return self._get_central_moment(samples[:,[zero[X]+J, zero[Y]+K]], 
                                            stacklevel=9+int(p==1))

        cov = {CXY: [[element(CXY, J, K) for K in range(p)] for J in range(p)]
              for CXY in [&#39;CAA&#39;, &#39;CRR&#39;, &#39;CSS&#39;, &#39;CAR&#39;, &#39;CAS&#39;, &#39;CRS&#39;]}

        def has_to_be_set(X, Y, Z, J, K, L):
            if X == Y == Z:
                return J &lt;= K &lt;= L
            if X == Y:
                return J &lt;= K
            if Y == Z:
                return K &lt;= L
            return True

        def element(XYZ, J, K, L):
            X, Y, Z = XYZ
            if has_to_be_set(X, Y, Z, J, K, L):
                return self._get_central_moment(
                        samples[:,[zero[X]+J, zero[Y]+K, zero[Z]+L]], 
                        stacklevel=10+int(p==1))
            return None

        triplets = [&#39;AAA&#39;, &#39;AAR&#39;, &#39;AAS&#39;, &#39;ARR&#39;, &#39;ARS&#39;, 
                    &#39;ASS&#39;, &#39;RRR&#39;, &#39;RRS&#39;, &#39;RSS&#39;, &#39;SSS&#39;]
        thirds = {XYZ: [[[element(XYZ, J, K, L) for L in range(p)]
                         for K in range(p)] for J in range(p)]
                  for XYZ in triplets}

        self._states_dict = {**expect, **cov, **thirds}

    def _label_max(self, X, J):
        &#34;&#34;&#34;Label for the maximum of `X` for the `J`th population.&#34;&#34;&#34;
        pop = self.config.network.populations[J]
        return f&#39;$\\mathrm{{max}}\\, {{{X}}}_{{{pop.ID}}}$&#39;

    def _label_min(self, X, J):
        &#34;&#34;&#34;Label for the minimum of `X` for the `J`th population.&#34;&#34;&#34;
        pop = self.config.network.populations[J]
        return f&#39;$\\mathrm{{min}}\\, {{{X}}}_{{{pop.ID}}}$&#39;

    def _label_one(self, X, J):
        &#34;&#34;&#34;Label for the expectation of `X` for the `J`th population.&#34;&#34;&#34;
        return f&#39;$\\mathcal{{{X}}}_{{{self.config.network.populations[J].ID}}}$&#39;

    def _label_two(self, XY, J, K):
        &#34;&#34;&#34;Label for the covariance between `X` and `Y` for the `J`th and `K`th
        populations.&#34;&#34;&#34;
        IDs = &#39;&#39;.join([self.config.network.populations[P].ID for P in (J, K)])
        return f&#39;$\\mathrm{{C}}_{{{XY}}}^{{{IDs}}}$&#39;

    def _label_three(self, XYZ, J, K, L):
        &#34;&#34;&#34;Label for the third central moment for variables `X`, `Y` and `Z` for
        the `J`th, `K`th and `L`th populations.&#34;&#34;&#34;
        IDs = &#39;&#39;.join([self.config.network.populations[P].ID for P in (J, K, L)])
        return f&#39;$\\mathrm{{M}}_{{{XYZ}}}^{{{IDs}}}$&#39;

    def _make_fill(self, X, J):
        &#34;&#34;&#34;Define the method to add a fill around the fraction variable `X` for
        the `J`th population.&#34;&#34;&#34;
        def f(bound=&#39;std&#39;, alpha=.25, **kwargs):
            self._check_if_activated()
            if bound == &#39;std&#39;:
                CXX = f&#39;C{X}{X}&#39;
                low = (self._states_dict[X][J] 
                        - np.sqrt(self._states_dict[CXX][J][J]))
                high = (self._states_dict[X][J] 
                        + np.sqrt(self._states_dict[CXX][J][J]))
            elif bound == &#39;extrema&#39;:
                low = self._min_dict[X][J]
                high = self._max_dict[X][J]
            fill = self.ax.fill_between(self.times, low, high, alpha=alpha,
                                        color=self.colors[X][J], **kwargs)
            return fill
        return f</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="popnet.graphics.Result" href="#popnet.graphics.Result">Result</a></li>
<li><a title="popnet.graphics.Graphics" href="#popnet.graphics.Graphics">Graphics</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>popnet.graphics._StatisticsOne</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="popnet.graphics.Statistics.default_sample_name"><code class="name">var <span class="ident">default_sample_name</span></code></dt>
<dd>
<div class="desc"><p>Default name for samples used when loading them.</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="popnet.graphics.Statistics.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>ID, sample_name=None, name=None, config=None, folder=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute statistics from loaded sample trajectories.</p>
<p>Compute statistics needed to define a <code><a title="popnet.graphics.Statistics" href="#popnet.graphics.Statistics">Statistics</a></code> instance from loaded
samples. For each component <em>X</em>, the samples are assumed to be in a
file named <em>ID - sample_name X.txt</em>, where <em>ID</em> and <em>sample_name</em> are
indeed <code>ID</code> and <code>sample_name</code>. In the file for a component <em>X</em>, it is
assumed that in each column are the values of <em>X</em> with respect to time
for a given trajectory.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ID</code></strong> :&ensp;<code>str</code></dt>
<dd>ID of the configuration used to obtain the samples.</dd>
<dt><strong><code>sample_name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name associated with the samples to be loaded. Defaults to <code>None</code>,
in which case is it replaced with <code>'Sample'</code>.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name associated with the result. Defaults to <code>None</code>, in which case
it is replaced with <code>'Statistics'</code>.</dd>
<dt><strong><code>config</code></strong> :&ensp;<code><a title="popnet.structures.Configuration" href="structures.html#popnet.structures.Configuration">Configuration</a></code>, optional</dt>
<dd>Configuration to associate with the result. If given, it must have
the ID <code>ID</code>. Defaults to <code>None</code>, in which case it is loaded from ID
<code>ID</code>.</dd>
<dt><strong><code>folder</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Folder in which the files are located, which should be placed in the
current directory. Defaults to <code>None</code>, in which case the files are
assumed to be located in the current directory.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="popnet.graphics.Statistics" href="#popnet.graphics.Statistics">Statistics</a></code></dt>
<dd>Statistics computed from the loaded samples.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>config</code> is neither <code>None</code> nor a
<code><a title="popnet.structures.Configuration" href="structures.html#popnet.structures.Configuration">Configuration</a></code> instance.</dd>
<dt><code><a title="popnet.exceptions.PopNetError" href="exceptions.html#popnet.exceptions.PopNetError">PopNetError</a></code></dt>
<dd>If <code>config</code> has a different ID than <code>ID</code>.</dd>
<dt><code>FileNotFoundError</code></dt>
<dd>If no file is found with the expected name for a component.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def load(cls, ID, sample_name=None, name=None, config=None, folder=None):
    &#34;&#34;&#34;Compute statistics from loaded sample trajectories.

    Compute statistics needed to define a `Statistics` instance from loaded
    samples. For each component *X*, the samples are assumed to be in a
    file named *ID - sample_name X.txt*, where *ID* and *sample_name* are
    indeed `ID` and `sample_name`. In the file for a component *X*, it is
    assumed that in each column are the values of *X* with respect to time
    for a given trajectory.

    Parameters
    ----------
    ID : str
        ID of the configuration used to obtain the samples. 
    sample_name : str, optional
        Name associated with the samples to be loaded. Defaults to `None`,
        in which case is it replaced with `&#39;Sample&#39;`.
    name : str, optional
        Name associated with the result. Defaults to `None`, in which case
        it is replaced with `&#39;Statistics&#39;`.
    config : popnet.structures.Configuration, optional
        Configuration to associate with the result. If given, it must have
        the ID `ID`. Defaults to `None`, in which case it is loaded from ID
        `ID`.
    folder : str, optional
        Folder in which the files are located, which should be placed in the
        current directory. Defaults to `None`, in which case the files are
        assumed to be located in the current directory.

    Returns
    -------
    Statistics
        Statistics computed from the loaded samples.

    Raises
    ------
    TypeError
        If `config` is neither `None` nor a
        `popnet.structures.Configuration` instance.
    popnet.exceptions.PopNetError
        If `config` has a different ID than `ID`. 
    FileNotFoundError
        If no file is found with the expected name for a component.
    &#34;&#34;&#34;
    config = cls._check_config(config, ID)
    sample_name = cls._get_sample_name(sample_name)
    samples = []
    p = len(config.network.populations)
    for J, X in enumerate(config._variables[:2*p]):
        filename = _internals._format_filename(
                        folder, ID, f&#39;{sample_name} {X}&#39;)
        try:
            samples.append(np.loadtxt(filename, dtype=float))
        except FileNotFoundError as e:
            raise FileNotFoundError(&#39;No samples found for the component &#39;
                                    f&#39;{X} with configuration {ID}.&#39;) from e
    samples = np.transpose(samples, axes=(1,0,2))
    times = np.linspace(config.initial_time, config.final_time, 
                        1 + config.iterations)
    name = cls._get_name(name)
    return cls(config, samples, times, name)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="popnet.graphics.Statistics.fill"><code class="name">var <span class="ident">fill</span></code></dt>
<dd>
<div class="desc"><p>Dictionary of methods to add fills for state variables.</p>
<p>if <em>X</em> denotes a state variable (that is, either <em>A</em>, <em>R</em> or <em>S</em>), then
<code>fill['X']</code> is a list whose <em>J</em>th element is a method which adds a fill
around the mean value, between two bounds. By default, the bounds are
given by one standard deviation on each side of the mean value. These
methods all accept the same arguments as <code><a title="popnet.graphics.Statistics.fill_all" href="#popnet.graphics.Statistics.fill_all">Statistics.fill_all()</a></code>.</p>
<p>In the case where the network has only one population, the lists are all
replaced with the single element they would contain. For example,
<code>fill['A']</code> is directly a method to add a fill around the mean value of
the network's activity.</p>
<p>When called, these methods add fills for the corresponding state
components on the axes <code><a title="popnet.graphics.Statistics.ax" href="#popnet.graphics.Graphics.ax">Statistics.ax</a></code> of the figure <code><a title="popnet.graphics.Statistics.fig" href="#popnet.graphics.Graphics.fig">Statistics.fig</a></code>.
They all accept keyword arguments that can be passed to the
<a href="https://31c8.short.gy/ax-fill-between"><code>fill_between</code></a> method of
<code><a title="popnet.graphics.Statistics.ax" href="#popnet.graphics.Graphics.ax">Statistics.ax</a></code>. This attribute cannot be set nor deleted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def fill(self):
    &#34;&#34;&#34;Dictionary of methods to add fills for state variables.

    if *X* denotes a state variable (that is, either *A*, *R* or *S*), then
    `fill[&#39;X&#39;]` is a list whose *J*th element is a method which adds a fill
    around the mean value, between two bounds. By default, the bounds are
    given by one standard deviation on each side of the mean value. These
    methods all accept the same arguments as `Statistics.fill_all`.

    In the case where the network has only one population, the lists are all
    replaced with the single element they would contain. For example,
    `fill[&#39;A&#39;]` is directly a method to add a fill around the mean value of
    the network&#39;s activity.

    When called, these methods add fills for the corresponding state
    components on the axes `Statistics.ax` of the figure `Statistics.fig`.
    They all accept keyword arguments that can be passed to the
    [`fill_between`](https://31c8.short.gy/ax-fill-between) method of
    `Statistics.ax`. This attribute cannot be set nor deleted.
    &#34;&#34;&#34;
    return self._fill</code></pre>
</details>
</dd>
<dt id="popnet.graphics.Statistics.plot_max"><code class="name">var <span class="ident">plot_max</span></code></dt>
<dd>
<div class="desc"><p>Dictionary of methods to plot maxima of state variables.</p>
<p>Analogous dictionary as <code><a title="popnet.graphics.Statistics.plot" href="#popnet.graphics.Result.plot">Statistics.plot</a></code> with keys <code>'A'</code>, <code>'R'</code> and
<code>'S'</code>, but were the methods plot <em>maxima</em> of state variables instead of
their mean values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def plot_max(self):
    &#34;&#34;&#34;Dictionary of methods to plot maxima of state variables.

    Analogous dictionary as `Statistics.plot` with keys `&#39;A&#39;`, `&#39;R&#39;` and
    `&#39;S&#39;`, but were the methods plot *maxima* of state variables instead of
    their mean values.
    &#34;&#34;&#34;
    return self._plot_max</code></pre>
</details>
</dd>
<dt id="popnet.graphics.Statistics.plot_min"><code class="name">var <span class="ident">plot_min</span></code></dt>
<dd>
<div class="desc"><p>Dictionary of methods to plot minima of state variables.</p>
<p>Analogous dictionary as <code><a title="popnet.graphics.Statistics.plot" href="#popnet.graphics.Result.plot">Statistics.plot</a></code> with keys <code>'A'</code>, <code>'R'</code> and
<code>'S'</code>, but were the methods plot <em>minima</em> of state variables instead of
their mean values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def plot_min(self):
    &#34;&#34;&#34;Dictionary of methods to plot minima of state variables.

    Analogous dictionary as `Statistics.plot` with keys `&#39;A&#39;`, `&#39;R&#39;` and
    `&#39;S&#39;`, but were the methods plot *minima* of state variables instead of
    their mean values.
    &#34;&#34;&#34;
    return self._plot_min</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="popnet.graphics.Statistics.fill_all"><code class="name flex">
<span>def <span class="ident">fill_all</span></span>(<span>self, bound='std', alpha=0.25, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Add fills between given bounds.</p>
<p>Add fills between given bounds around the mean values of all fractions
of populations.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>bound</code></strong> :&ensp;<code>{'std', 'extrema'}</code>, optional</dt>
<dd>Describes the bounds between which to fill. If <code>'std'</code>, the region
bounded by one standard deviation around the mean value is filled.
If <code>'extrema'</code>, the region bounded by the minimum and maximum
values of the component is filled. Defaults to <code>'std'</code>.</dd>
<dt><strong><code>alpha</code></strong> :&ensp;<code>float</code></dt>
<dd>Transparency parameter of the fill. Defaults to 0.25.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments to be passed to the method that adds the fills,
which is the <a href="https://31c8.short.gy/ax-fill-between"><code>fill_between</code></a>
method of <code><a title="popnet.graphics.Statistics.ax" href="#popnet.graphics.Graphics.ax">Statistics.ax</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fill_all(self, bound=&#39;std&#39;, alpha=.25, **kwargs):
    &#34;&#34;&#34;Add fills between given bounds.

    Add fills between given bounds around the mean values of all fractions
    of populations.

    Parameters
    ----------
    bound : {&#39;std&#39;, &#39;extrema&#39;}, optional
        Describes the bounds between which to fill. If `&#39;std&#39;`, the region
        bounded by one standard deviation around the mean value is filled.
        If `&#39;extrema&#39;`, the region bounded by the minimum and maximum
        values of the component is filled. Defaults to `&#39;std&#39;`.
    alpha : float
        Transparency parameter of the fill. Defaults to 0.25.
    **kwargs
        Keyword arguments to be passed to the method that adds the fills,
        which is the [`fill_between`](https://31c8.short.gy/ax-fill-between)
        method of `Statistics.ax`.
    &#34;&#34;&#34;
    self._fill_all(bound, alpha, **kwargs)</code></pre>
</details>
</dd>
<dt id="popnet.graphics.Statistics.plot_averages"><code class="name flex">
<span>def <span class="ident">plot_averages</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot all averages of fractions of populations.</p>
<p>Plot all sample means of active, refractory and sensitive fractions of
populations on the figure <code><a title="popnet.graphics.Statistics.fig" href="#popnet.graphics.Graphics.fig">Statistics.fig</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments to be passed to the method that plots components,
which is the <a href="https://31c8.short.gy/ax-plot"><code>plot</code></a> method of
<code><a title="popnet.graphics.Statistics.ax" href="#popnet.graphics.Graphics.ax">Statistics.ax</a></code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="popnet.exceptions.PopNetError" href="exceptions.html#popnet.exceptions.PopNetError">PopNetError</a></code></dt>
<dd>If no figure and axes are bound to <code><a title="popnet.graphics.Statistics.fig" href="#popnet.graphics.Graphics.fig">Statistics.fig</a></code> and
<code><a title="popnet.graphics.Statistics.ax" href="#popnet.graphics.Graphics.ax">Statistics.ax</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_averages(self, **kwargs):
    &#34;&#34;&#34;Plot all averages of fractions of populations.

    Plot all sample means of active, refractory and sensitive fractions of
    populations on the figure `Statistics.fig`.

    Parameters
    ----------
    **kwargs
        Keyword arguments to be passed to the method that plots components,
        which is the [`plot`](https://31c8.short.gy/ax-plot) method of
        `Statistics.ax`.

    Raises
    ------
    popnet.exceptions.PopNetError
        If no figure and axes are bound to `Statistics.fig` and
        `Statistics.ax`.
    &#34;&#34;&#34;
    self._plot_all_one(**kwargs)</code></pre>
</details>
</dd>
<dt id="popnet.graphics.Statistics.plot_covariances"><code class="name flex">
<span>def <span class="ident">plot_covariances</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot all non-symmetric covariances of fractions of populations.</p>
<p>Plot all non-symmetric sample covariances between active, refractory and
sensitive fractions of populations on the figure <code><a title="popnet.graphics.Statistics.fig" href="#popnet.graphics.Graphics.fig">Statistics.fig</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments to be passed to the method that plots components,
which is the <a href="https://31c8.short.gy/ax-plot"><code>plot</code></a> method of
<code><a title="popnet.graphics.Statistics.ax" href="#popnet.graphics.Graphics.ax">Statistics.ax</a></code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="popnet.exceptions.PopNetError" href="exceptions.html#popnet.exceptions.PopNetError">PopNetError</a></code></dt>
<dd>If no figure and axes are bound to <code><a title="popnet.graphics.Statistics.fig" href="#popnet.graphics.Graphics.fig">Statistics.fig</a></code> and
<code><a title="popnet.graphics.Statistics.ax" href="#popnet.graphics.Graphics.ax">Statistics.ax</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_covariances(self, **kwargs):
    &#34;&#34;&#34;Plot all non-symmetric covariances of fractions of populations.

    Plot all non-symmetric sample covariances between active, refractory and
    sensitive fractions of populations on the figure `Statistics.fig`.

    Parameters
    ----------
    **kwargs
        Keyword arguments to be passed to the method that plots components,
        which is the [`plot`](https://31c8.short.gy/ax-plot) method of
        `Statistics.ax`.

    Raises
    ------
    popnet.exceptions.PopNetError
        If no figure and axes are bound to `Statistics.fig` and
        `Statistics.ax`.
    &#34;&#34;&#34;
    self._plot_all_two(symmetric=False, nonsymmetric=True, **kwargs)</code></pre>
</details>
</dd>
<dt id="popnet.graphics.Statistics.plot_third_moments"><code class="name flex">
<span>def <span class="ident">plot_third_moments</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot all third central moments of fractions of population.</p>
<p>Plot all sample third central moments of active, refractory and
sensitive fractions of populations on the figure <code><a title="popnet.graphics.Statistics.fig" href="#popnet.graphics.Graphics.fig">Statistics.fig</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments to be passed to the method that plots components,
which is the <a href="https://31c8.short.gy/ax-plot"><code>plot</code></a> method of
<code><a title="popnet.graphics.Statistics.ax" href="#popnet.graphics.Graphics.ax">Statistics.ax</a></code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="popnet.exceptions.PopNetError" href="exceptions.html#popnet.exceptions.PopNetError">PopNetError</a></code></dt>
<dd>If no figure and axes are bound to <code><a title="popnet.graphics.Statistics.fig" href="#popnet.graphics.Graphics.fig">Statistics.fig</a></code> and
<code><a title="popnet.graphics.Statistics.ax" href="#popnet.graphics.Graphics.ax">Statistics.ax</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_third_moments(self, **kwargs):
    &#34;&#34;&#34;Plot all third central moments of fractions of population.

    Plot all sample third central moments of active, refractory and
    sensitive fractions of populations on the figure `Statistics.fig`.

    Parameters
    ----------
    **kwargs
        Keyword arguments to be passed to the method that plots components,
        which is the [`plot`](https://31c8.short.gy/ax-plot) method of
        `Statistics.ax`.

    Raises
    ------
    popnet.exceptions.PopNetError
        If no figure and axes are bound to `Statistics.fig` and
        `Statistics.ax`.
    &#34;&#34;&#34;
    self._plot_all_three(**kwargs)</code></pre>
</details>
</dd>
<dt id="popnet.graphics.Statistics.plot_variances"><code class="name flex">
<span>def <span class="ident">plot_variances</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot all variances of fractions of populations.</p>
<p>Plot all sample variances of active, refractory and sensitive fractions
of populations on the figure <code><a title="popnet.graphics.Statistics.fig" href="#popnet.graphics.Graphics.fig">Statistics.fig</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments to be passed to the method that plots components,
which is the <a href="https://31c8.short.gy/ax-plot"><code>plot</code></a> method of
<code><a title="popnet.graphics.Statistics.ax" href="#popnet.graphics.Graphics.ax">Statistics.ax</a></code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="popnet.exceptions.PopNetError" href="exceptions.html#popnet.exceptions.PopNetError">PopNetError</a></code></dt>
<dd>If no figure and axes are bound to <code><a title="popnet.graphics.Statistics.fig" href="#popnet.graphics.Graphics.fig">Statistics.fig</a></code> and
<code><a title="popnet.graphics.Statistics.ax" href="#popnet.graphics.Graphics.ax">Statistics.ax</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_variances(self, **kwargs):
    &#34;&#34;&#34;Plot all variances of fractions of populations.

    Plot all sample variances of active, refractory and sensitive fractions
    of populations on the figure `Statistics.fig`.

    Parameters
    ----------
    **kwargs
        Keyword arguments to be passed to the method that plots components,
        which is the [`plot`](https://31c8.short.gy/ax-plot) method of
        `Statistics.ax`.

    Raises
    ------
    popnet.exceptions.PopNetError
        If no figure and axes are bound to `Statistics.fig` and
        `Statistics.ax`.
    &#34;&#34;&#34;
    self._plot_all_two(symmetric=True, nonsymmetric=False, **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="popnet.graphics.Result" href="#popnet.graphics.Result">Result</a></b></code>:
<ul class="hlist">
<li><code><a title="popnet.graphics.Result.A" href="#popnet.graphics.Result.A">A</a></code></li>
<li><code><a title="popnet.graphics.Result.CAA" href="#popnet.graphics.Result.CAA">CAA</a></code></li>
<li><code><a title="popnet.graphics.Result.CAR" href="#popnet.graphics.Result.CAR">CAR</a></code></li>
<li><code><a title="popnet.graphics.Result.CAS" href="#popnet.graphics.Result.CAS">CAS</a></code></li>
<li><code><a title="popnet.graphics.Result.CRR" href="#popnet.graphics.Result.CRR">CRR</a></code></li>
<li><code><a title="popnet.graphics.Result.CRS" href="#popnet.graphics.Result.CRS">CRS</a></code></li>
<li><code><a title="popnet.graphics.Result.CSS" href="#popnet.graphics.Result.CSS">CSS</a></code></li>
<li><code><a title="popnet.graphics.Result.R" href="#popnet.graphics.Result.R">R</a></code></li>
<li><code><a title="popnet.graphics.Result.S" href="#popnet.graphics.Result.S">S</a></code></li>
<li><code><a title="popnet.graphics.Result.activate" href="#popnet.graphics.Graphics.activate">activate</a></code></li>
<li><code><a title="popnet.graphics.Result.ax" href="#popnet.graphics.Graphics.ax">ax</a></code></li>
<li><code><a title="popnet.graphics.Result.colors" href="#popnet.graphics.Result.colors">colors</a></code></li>
<li><code><a title="popnet.graphics.Result.config" href="#popnet.graphics.Graphics.config">config</a></code></li>
<li><code><a title="popnet.graphics.Result.default_figure" href="#popnet.graphics.Result.default_figure">default_figure</a></code></li>
<li><code><a title="popnet.graphics.Result.default_name" href="#popnet.graphics.Graphics.default_name">default_name</a></code></li>
<li><code><a title="popnet.graphics.Result.draw" href="#popnet.graphics.Graphics.draw">draw</a></code></li>
<li><code><a title="popnet.graphics.Result.fig" href="#popnet.graphics.Graphics.fig">fig</a></code></li>
<li><code><a title="popnet.graphics.Result.get_spectrum" href="#popnet.graphics.Result.get_spectrum">get_spectrum</a></code></li>
<li><code><a title="popnet.graphics.Result.legend" href="#popnet.graphics.Graphics.legend">legend</a></code></li>
<li><code><a title="popnet.graphics.Result.name" href="#popnet.graphics.Graphics.name">name</a></code></li>
<li><code><a title="popnet.graphics.Result.plot" href="#popnet.graphics.Result.plot">plot</a></code></li>
<li><code><a title="popnet.graphics.Result.setup" href="#popnet.graphics.Result.setup">setup</a></code></li>
<li><code><a title="popnet.graphics.Result.times" href="#popnet.graphics.Result.times">times</a></code></li>
<li><code><a title="popnet.graphics.Result.x_units" href="#popnet.graphics.Result.x_units">x_units</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="popnet.graphics.Trajectory"><code class="flex name class">
<span>class <span class="ident">Trajectory</span></span>
<span>(</span><span>config, states, times, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represent trajectories of stochastic processes.</p>
<p><code><a title="popnet.graphics.Trajectory" href="#popnet.graphics.Trajectory">Trajectory</a></code> extends <code><a title="popnet.graphics.Result" href="#popnet.graphics.Result">Result</a></code> for the case where the result is a possible
trajectory of a stochastic process that rules the microscopic dynamics
of the network. It adds a method to the base class to plot the fractions of
populations all at once, and it adapts the loading method. Other changes
are implementation details.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Trajectory(Result):
    &#34;&#34;&#34;Represent trajectories of stochastic processes.

    `Trajectory` extends `Result` for the case where the result is a possible
    trajectory of a stochastic process that rules the microscopic dynamics
    of the network. It adds a method to the base class to plot the fractions of
    populations all at once, and it adapts the loading method. Other changes
    are implementation details.

    &#34;&#34;&#34;

    default_name = &#39;Trajectory&#39;
    &#34;&#34;&#34;Default name given to instances.&#34;&#34;&#34;

    @classmethod
    def load(cls, ID, name=None, config=None, folder=None):
        &#34;&#34;&#34;Load the trajectory associated with the ID.

        Load the trajectory obtained when using the configuration of ID `ID`. It
        extends the base class method by loading the `times` array, which is
        assumed to be in a file named *ID - name (times).txt*, where *ID* and
        *name* are indeed `ID` and `name`. Returns a `Trajectory` instance.

        See Also
        --------
        Result.load
        &#34;&#34;&#34;
        name = cls._get_name(name)
        filename = _internals._format_filename(folder, ID, f&#39;{name} (times)&#39;)
        try:
            times = np.loadtxt(filename, dtype=float)
        except FileNotFoundError as error:
            raise FileNotFoundError(
                f&#39;No times array found for configuration {ID}&#39;) from error
        return super().load(ID, name, config=config, times=times, folder=folder)
        
    def plot_fractions(self, **kwargs):
        &#34;&#34;&#34;Plot all fractions of populations.

        Plot all active, refractory and sensitive fractions of population on
        the figure `Trajectory.fig`.
        
        Parameters
        ----------
        **kwargs
            Keyword arguments to be passed to the method that plots components,
            which is the [`plot`](https://31c8.short.gy/ax-plot) method of
            `Trajectory.ax`.

        Raises
        ------
        popnet.exceptions.PopNetError
            If no figure and axes are bound to `Trajectory.fig` and
            `Trajectory.ax`.
        &#34;&#34;&#34;
        self._plot_all_one(**kwargs)

    def _label_one(self, X, J):
        &#34;&#34;&#34;Label for the fraction `X` of the `J`th population.&#34;&#34;&#34;
        return f&#39;${X}^{{{self.config.network.populations[J].ID}}}$&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="popnet.graphics.Result" href="#popnet.graphics.Result">Result</a></li>
<li><a title="popnet.graphics.Graphics" href="#popnet.graphics.Graphics">Graphics</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>popnet.graphics._TrajectoryOne</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="popnet.graphics.Trajectory.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>ID, name=None, config=None, folder=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Load the trajectory associated with the ID.</p>
<p>Load the trajectory obtained when using the configuration of ID <code>ID</code>. It
extends the base class method by loading the <code>times</code> array, which is
assumed to be in a file named <em>ID - name (times).txt</em>, where <em>ID</em> and
<em>name</em> are indeed <code>ID</code> and <code>name</code>. Returns a <code><a title="popnet.graphics.Trajectory" href="#popnet.graphics.Trajectory">Trajectory</a></code> instance.</p>
<h2 id="see-also">See Also</h2>
<p><code><a title="popnet.graphics.Result.load" href="#popnet.graphics.Result.load">Result.load()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def load(cls, ID, name=None, config=None, folder=None):
    &#34;&#34;&#34;Load the trajectory associated with the ID.

    Load the trajectory obtained when using the configuration of ID `ID`. It
    extends the base class method by loading the `times` array, which is
    assumed to be in a file named *ID - name (times).txt*, where *ID* and
    *name* are indeed `ID` and `name`. Returns a `Trajectory` instance.

    See Also
    --------
    Result.load
    &#34;&#34;&#34;
    name = cls._get_name(name)
    filename = _internals._format_filename(folder, ID, f&#39;{name} (times)&#39;)
    try:
        times = np.loadtxt(filename, dtype=float)
    except FileNotFoundError as error:
        raise FileNotFoundError(
            f&#39;No times array found for configuration {ID}&#39;) from error
    return super().load(ID, name, config=config, times=times, folder=folder)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="popnet.graphics.Trajectory.plot_fractions"><code class="name flex">
<span>def <span class="ident">plot_fractions</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot all fractions of populations.</p>
<p>Plot all active, refractory and sensitive fractions of population on
the figure <code><a title="popnet.graphics.Trajectory.fig" href="#popnet.graphics.Graphics.fig">Trajectory.fig</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments to be passed to the method that plots components,
which is the <a href="https://31c8.short.gy/ax-plot"><code>plot</code></a> method of
<code><a title="popnet.graphics.Trajectory.ax" href="#popnet.graphics.Graphics.ax">Trajectory.ax</a></code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="popnet.exceptions.PopNetError" href="exceptions.html#popnet.exceptions.PopNetError">PopNetError</a></code></dt>
<dd>If no figure and axes are bound to <code><a title="popnet.graphics.Trajectory.fig" href="#popnet.graphics.Graphics.fig">Trajectory.fig</a></code> and
<code><a title="popnet.graphics.Trajectory.ax" href="#popnet.graphics.Graphics.ax">Trajectory.ax</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_fractions(self, **kwargs):
    &#34;&#34;&#34;Plot all fractions of populations.

    Plot all active, refractory and sensitive fractions of population on
    the figure `Trajectory.fig`.
    
    Parameters
    ----------
    **kwargs
        Keyword arguments to be passed to the method that plots components,
        which is the [`plot`](https://31c8.short.gy/ax-plot) method of
        `Trajectory.ax`.

    Raises
    ------
    popnet.exceptions.PopNetError
        If no figure and axes are bound to `Trajectory.fig` and
        `Trajectory.ax`.
    &#34;&#34;&#34;
    self._plot_all_one(**kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="popnet.graphics.Result" href="#popnet.graphics.Result">Result</a></b></code>:
<ul class="hlist">
<li><code><a title="popnet.graphics.Result.A" href="#popnet.graphics.Result.A">A</a></code></li>
<li><code><a title="popnet.graphics.Result.CAA" href="#popnet.graphics.Result.CAA">CAA</a></code></li>
<li><code><a title="popnet.graphics.Result.CAR" href="#popnet.graphics.Result.CAR">CAR</a></code></li>
<li><code><a title="popnet.graphics.Result.CAS" href="#popnet.graphics.Result.CAS">CAS</a></code></li>
<li><code><a title="popnet.graphics.Result.CRR" href="#popnet.graphics.Result.CRR">CRR</a></code></li>
<li><code><a title="popnet.graphics.Result.CRS" href="#popnet.graphics.Result.CRS">CRS</a></code></li>
<li><code><a title="popnet.graphics.Result.CSS" href="#popnet.graphics.Result.CSS">CSS</a></code></li>
<li><code><a title="popnet.graphics.Result.R" href="#popnet.graphics.Result.R">R</a></code></li>
<li><code><a title="popnet.graphics.Result.S" href="#popnet.graphics.Result.S">S</a></code></li>
<li><code><a title="popnet.graphics.Result.activate" href="#popnet.graphics.Graphics.activate">activate</a></code></li>
<li><code><a title="popnet.graphics.Result.ax" href="#popnet.graphics.Graphics.ax">ax</a></code></li>
<li><code><a title="popnet.graphics.Result.colors" href="#popnet.graphics.Result.colors">colors</a></code></li>
<li><code><a title="popnet.graphics.Result.config" href="#popnet.graphics.Graphics.config">config</a></code></li>
<li><code><a title="popnet.graphics.Result.default_figure" href="#popnet.graphics.Result.default_figure">default_figure</a></code></li>
<li><code><a title="popnet.graphics.Result.default_name" href="#popnet.graphics.Graphics.default_name">default_name</a></code></li>
<li><code><a title="popnet.graphics.Result.draw" href="#popnet.graphics.Graphics.draw">draw</a></code></li>
<li><code><a title="popnet.graphics.Result.fig" href="#popnet.graphics.Graphics.fig">fig</a></code></li>
<li><code><a title="popnet.graphics.Result.get_spectrum" href="#popnet.graphics.Result.get_spectrum">get_spectrum</a></code></li>
<li><code><a title="popnet.graphics.Result.legend" href="#popnet.graphics.Graphics.legend">legend</a></code></li>
<li><code><a title="popnet.graphics.Result.name" href="#popnet.graphics.Graphics.name">name</a></code></li>
<li><code><a title="popnet.graphics.Result.plot" href="#popnet.graphics.Result.plot">plot</a></code></li>
<li><code><a title="popnet.graphics.Result.setup" href="#popnet.graphics.Result.setup">setup</a></code></li>
<li><code><a title="popnet.graphics.Result.times" href="#popnet.graphics.Result.times">times</a></code></li>
<li><code><a title="popnet.graphics.Result.x_units" href="#popnet.graphics.Result.x_units">x_units</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#classes-and-hierarchy">Classes and hierarchy</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="popnet" href="index.html">popnet</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="popnet.graphics.draw" href="#popnet.graphics.draw">draw</a></code></li>
<li><code><a title="popnet.graphics.figure" href="#popnet.graphics.figure">figure</a></code></li>
<li><code><a title="popnet.graphics.load_extended_solution" href="#popnet.graphics.load_extended_solution">load_extended_solution</a></code></li>
<li><code><a title="popnet.graphics.load_solution" href="#popnet.graphics.load_solution">load_solution</a></code></li>
<li><code><a title="popnet.graphics.load_statistics" href="#popnet.graphics.load_statistics">load_statistics</a></code></li>
<li><code><a title="popnet.graphics.load_trajectory" href="#popnet.graphics.load_trajectory">load_trajectory</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="popnet.graphics.ExtendedSolution" href="#popnet.graphics.ExtendedSolution">ExtendedSolution</a></code></h4>
<ul class="">
<li><code><a title="popnet.graphics.ExtendedSolution.plot_covariances" href="#popnet.graphics.ExtendedSolution.plot_covariances">plot_covariances</a></code></li>
<li><code><a title="popnet.graphics.ExtendedSolution.plot_variances" href="#popnet.graphics.ExtendedSolution.plot_variances">plot_variances</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="popnet.graphics.Graphics" href="#popnet.graphics.Graphics">Graphics</a></code></h4>
<ul class="two-column">
<li><code><a title="popnet.graphics.Graphics.activate" href="#popnet.graphics.Graphics.activate">activate</a></code></li>
<li><code><a title="popnet.graphics.Graphics.ax" href="#popnet.graphics.Graphics.ax">ax</a></code></li>
<li><code><a title="popnet.graphics.Graphics.config" href="#popnet.graphics.Graphics.config">config</a></code></li>
<li><code><a title="popnet.graphics.Graphics.default_name" href="#popnet.graphics.Graphics.default_name">default_name</a></code></li>
<li><code><a title="popnet.graphics.Graphics.draw" href="#popnet.graphics.Graphics.draw">draw</a></code></li>
<li><code><a title="popnet.graphics.Graphics.fig" href="#popnet.graphics.Graphics.fig">fig</a></code></li>
<li><code><a title="popnet.graphics.Graphics.legend" href="#popnet.graphics.Graphics.legend">legend</a></code></li>
<li><code><a title="popnet.graphics.Graphics.name" href="#popnet.graphics.Graphics.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="popnet.graphics.PhasePlane" href="#popnet.graphics.PhasePlane">PhasePlane</a></code></h4>
<ul class="two-column">
<li><code><a title="popnet.graphics.PhasePlane.axes" href="#popnet.graphics.PhasePlane.axes">axes</a></code></li>
<li><code><a title="popnet.graphics.PhasePlane.fixed_axes" href="#popnet.graphics.PhasePlane.fixed_axes">fixed_axes</a></code></li>
<li><code><a title="popnet.graphics.PhasePlane.legend" href="#popnet.graphics.PhasePlane.legend">legend</a></code></li>
<li><code><a title="popnet.graphics.PhasePlane.plot_nullclines" href="#popnet.graphics.PhasePlane.plot_nullclines">plot_nullclines</a></code></li>
<li><code><a title="popnet.graphics.PhasePlane.plot_solution" href="#popnet.graphics.PhasePlane.plot_solution">plot_solution</a></code></li>
<li><code><a title="popnet.graphics.PhasePlane.plot_trajectory" href="#popnet.graphics.PhasePlane.plot_trajectory">plot_trajectory</a></code></li>
<li><code><a title="popnet.graphics.PhasePlane.quiver" href="#popnet.graphics.PhasePlane.quiver">quiver</a></code></li>
<li><code><a title="popnet.graphics.PhasePlane.setup" href="#popnet.graphics.PhasePlane.setup">setup</a></code></li>
<li><code><a title="popnet.graphics.PhasePlane.streamplot" href="#popnet.graphics.PhasePlane.streamplot">streamplot</a></code></li>
<li><code><a title="popnet.graphics.PhasePlane.system" href="#popnet.graphics.PhasePlane.system">system</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="popnet.graphics.Result" href="#popnet.graphics.Result">Result</a></code></h4>
<ul class="two-column">
<li><code><a title="popnet.graphics.Result.A" href="#popnet.graphics.Result.A">A</a></code></li>
<li><code><a title="popnet.graphics.Result.CAA" href="#popnet.graphics.Result.CAA">CAA</a></code></li>
<li><code><a title="popnet.graphics.Result.CAR" href="#popnet.graphics.Result.CAR">CAR</a></code></li>
<li><code><a title="popnet.graphics.Result.CAS" href="#popnet.graphics.Result.CAS">CAS</a></code></li>
<li><code><a title="popnet.graphics.Result.CRR" href="#popnet.graphics.Result.CRR">CRR</a></code></li>
<li><code><a title="popnet.graphics.Result.CRS" href="#popnet.graphics.Result.CRS">CRS</a></code></li>
<li><code><a title="popnet.graphics.Result.CSS" href="#popnet.graphics.Result.CSS">CSS</a></code></li>
<li><code><a title="popnet.graphics.Result.R" href="#popnet.graphics.Result.R">R</a></code></li>
<li><code><a title="popnet.graphics.Result.S" href="#popnet.graphics.Result.S">S</a></code></li>
<li><code><a title="popnet.graphics.Result.colors" href="#popnet.graphics.Result.colors">colors</a></code></li>
<li><code><a title="popnet.graphics.Result.default_figure" href="#popnet.graphics.Result.default_figure">default_figure</a></code></li>
<li><code><a title="popnet.graphics.Result.get_spectrum" href="#popnet.graphics.Result.get_spectrum">get_spectrum</a></code></li>
<li><code><a title="popnet.graphics.Result.load" href="#popnet.graphics.Result.load">load</a></code></li>
<li><code><a title="popnet.graphics.Result.plot" href="#popnet.graphics.Result.plot">plot</a></code></li>
<li><code><a title="popnet.graphics.Result.setup" href="#popnet.graphics.Result.setup">setup</a></code></li>
<li><code><a title="popnet.graphics.Result.times" href="#popnet.graphics.Result.times">times</a></code></li>
<li><code><a title="popnet.graphics.Result.x_units" href="#popnet.graphics.Result.x_units">x_units</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="popnet.graphics.Solution" href="#popnet.graphics.Solution">Solution</a></code></h4>
<ul class="">
<li><code><a title="popnet.graphics.Solution.plot_expectations" href="#popnet.graphics.Solution.plot_expectations">plot_expectations</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="popnet.graphics.Spectrum" href="#popnet.graphics.Spectrum">Spectrum</a></code></h4>
<ul class="two-column">
<li><code><a title="popnet.graphics.Spectrum.freqs" href="#popnet.graphics.Spectrum.freqs">freqs</a></code></li>
<li><code><a title="popnet.graphics.Spectrum.plot_covariances" href="#popnet.graphics.Spectrum.plot_covariances">plot_covariances</a></code></li>
<li><code><a title="popnet.graphics.Spectrum.plot_fractions" href="#popnet.graphics.Spectrum.plot_fractions">plot_fractions</a></code></li>
<li><code><a title="popnet.graphics.Spectrum.plot_third_moments" href="#popnet.graphics.Spectrum.plot_third_moments">plot_third_moments</a></code></li>
<li><code><a title="popnet.graphics.Spectrum.plot_variances" href="#popnet.graphics.Spectrum.plot_variances">plot_variances</a></code></li>
<li><code><a title="popnet.graphics.Spectrum.setup" href="#popnet.graphics.Spectrum.setup">setup</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="popnet.graphics.Statistics" href="#popnet.graphics.Statistics">Statistics</a></code></h4>
<ul class="two-column">
<li><code><a title="popnet.graphics.Statistics.default_sample_name" href="#popnet.graphics.Statistics.default_sample_name">default_sample_name</a></code></li>
<li><code><a title="popnet.graphics.Statistics.fill" href="#popnet.graphics.Statistics.fill">fill</a></code></li>
<li><code><a title="popnet.graphics.Statistics.fill_all" href="#popnet.graphics.Statistics.fill_all">fill_all</a></code></li>
<li><code><a title="popnet.graphics.Statistics.load" href="#popnet.graphics.Statistics.load">load</a></code></li>
<li><code><a title="popnet.graphics.Statistics.plot_averages" href="#popnet.graphics.Statistics.plot_averages">plot_averages</a></code></li>
<li><code><a title="popnet.graphics.Statistics.plot_covariances" href="#popnet.graphics.Statistics.plot_covariances">plot_covariances</a></code></li>
<li><code><a title="popnet.graphics.Statistics.plot_max" href="#popnet.graphics.Statistics.plot_max">plot_max</a></code></li>
<li><code><a title="popnet.graphics.Statistics.plot_min" href="#popnet.graphics.Statistics.plot_min">plot_min</a></code></li>
<li><code><a title="popnet.graphics.Statistics.plot_third_moments" href="#popnet.graphics.Statistics.plot_third_moments">plot_third_moments</a></code></li>
<li><code><a title="popnet.graphics.Statistics.plot_variances" href="#popnet.graphics.Statistics.plot_variances">plot_variances</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="popnet.graphics.Trajectory" href="#popnet.graphics.Trajectory">Trajectory</a></code></h4>
<ul class="">
<li><code><a title="popnet.graphics.Trajectory.load" href="#popnet.graphics.Trajectory.load">load</a></code></li>
<li><code><a title="popnet.graphics.Trajectory.plot_fractions" href="#popnet.graphics.Trajectory.plot_fractions">plot_fractions</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>