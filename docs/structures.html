<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>popnet.structures documentation</title>
<meta name="description" content="Data structures to represent biological neural networks …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding-left:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        "SVG": {
            availableFonts: ["TeX"], 
            scale: 90,
            blacker: 0
        },
        MMLorHTML: {prefer: "HTML"},
    });
    MathJax.Hub.Register.StartupHook("SVG Jax Ready",function () {
      var VARIANT = MathJax.OutputJax["SVG"].FONTDATA.VARIANT;
      VARIANT["normal"].fonts.unshift("MathJax_SansSerif");
      VARIANT["bold"].fonts.unshift("MathJax_SansSerif-bold");
      VARIANT["italic"].fonts.unshift("MathJax_SansSerif-italic");
      VARIANT["-tex-mathit"].fonts.unshift("MathJax_SansSerif-italic");
    });
    MathJax.Hub.Register.StartupHook("SVG Jax Ready",function () {
      var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;
      VARIANT["normal"].fonts.unshift("MathJax_SansSerif");
      VARIANT["bold"].fonts.unshift("MathJax_SansSerif-bold");
      VARIANT["italic"].fonts.unshift("MathJax_SansSerif-italic");
      VARIANT["-tex-mathit"].fonts.unshift("MathJax_SansSerif-italic");
    });
</script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_SVG"></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<style type="text/css">
    ul { 
        list-style-type: square; 
    }
    ul.hierarchy {
        list-style-type: none;
        padding-left: 2.5em;
        text-indent: -.8em;
    }
    ul.hierarchy > li:before {
        content: "\21B3 ";
    }
    ul.sidebar {
        border-left: 1px solid silver;
        margin-left: -.7em;
    }
    ol.references { 
        list-style-type: none; 
        margin-left: 0px; 
        padding-left: 2em; 
        position: relative; 
    }
    ol.references > li:before {
        content: "[" counter(enum, decimal) "]"; 
        left: 0.4em; 
        position: absolute; 
    }
    ol.references > li { 
        counter-increment: enum; 
    }
</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>popnet.structures</code></h1>
</header>
<section id="section-intro">
<p>Data structures to represent biological neural networks.</p>
<p>This modules defines several classes which are used as data structures to
represent biological neural networks and configurations used in numerical
experiments. The hierarchy of the module's classes is given in the
<a href="#classes-and-hierarchy">Classes And Hierarchy</a> section below.</p>
<h2 id="classes-and-hierarchy">Classes And Hierarchy</h2>
<p>The important classes of the module are summarized below. The indentation
follows the hierarchy. </p>
<ul class="hierarchy">
<li><code><a title="popnet.structures.Population" href="#popnet.structures.Population">Population</a></code> : Represent a population of biological neurons.</li>
<li><code><a title="popnet.structures.Network" href="#popnet.structures.Network">Network</a></code> : Represent a network split into populations.<ul class="hierarchy sidebar">
<li><code><a title="popnet.structures.MicroNetwork" href="#popnet.structures.MicroNetwork">MicroNetwork</a></code> : Represent a network including its microscopic structure.</li>
</ul>
</li>
<li><code><a title="popnet.structures.Configuration" href="#popnet.structures.Configuration">Configuration</a></code> : A complete configuration to perform a numerical experiment.<ul class="hierarchy sidebar">
<li><code><a title="popnet.structures.ConfigurationOne" href="#popnet.structures.ConfigurationOne">ConfigurationOne</a></code> : A configuration with a network of one population.</li>
<li><code><a title="popnet.structures.MicroConfiguration" href="#popnet.structures.MicroConfiguration">MicroConfiguration</a></code> : A configuration with a <code><a title="popnet.structures.MicroNetwork" href="#popnet.structures.MicroNetwork">MicroNetwork</a></code>.</li>
<li><code><a title="popnet.structures.MicroConfigurationOne" href="#popnet.structures.MicroConfigurationOne">MicroConfigurationOne</a></code> : A merge of the two above classes.</li>
</ul>
</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Data structures to represent biological neural networks.

This modules defines several classes which are used as data structures to
represent biological neural networks and configurations used in numerical
experiments. The hierarchy of the module&#39;s classes is given in the
[Classes And Hierarchy](#classes-and-hierarchy) section below.

Classes and hierarchy
---------------------

The important classes of the module are summarized below. The indentation
follows the hierarchy. 

 - `Population` : Represent a population of biological neurons.
 - `Network` : Represent a network split into populations.
    - `MicroNetwork` : Represent a network including its microscopic structure.
 - `Configuration` : A complete configuration to perform a numerical experiment.
     - `ConfigurationOne` : A configuration with a network of one population.
     - `MicroConfiguration` : A configuration with a `MicroNetwork`.
     - `MicroConfigurationOne` : A merge of the two above classes.

&#34;&#34;&#34;

import re
import ast
import numpy as np
from copy import deepcopy
from warnings import warn
from scipy.special import expit, logit

from .exceptions import *
from . import _internals


class Population:
    &#34;&#34;&#34;Represent a population of biological neurons.

    This class is used to describe a population of biological neurons. It allows
    to easily attribute parameters, such as the threshold and the transition
    rates, to the same population. Its methods allow to change easily the values
    of these parameters. 

    Parameters
    ----------
    name : str
        Name of the population.
    ID : str, optional
        ID of the population. It must be a single character. If it is not
        given, the last character of `name` is used if it is a number, and
        else the first one is used.
    size : int, optional
        Number of neurons of the population. It must be positive. Defaults to
        `None`, in which case no size is defined for the population.

    Attributes
    ----------
    name : str
        Name given to the population. See `Population.name`.
    ID : str
        ID of the population. See `Population.ID`.
    size : int
        Size of the population. See `Population.size`.
    alpha : float
        Mean transition rate from sensitive to active. See `Population.alpha`.
    beta : float
        Mean transition rate from active to refractory. See `Population.beta`.
    gamma : float
        Mean transition rate from refractory to sensitive. See
        `Population.gamma`.
    theta : float
        Mean threshold. See `Population.theta`.
    scale_alpha : float
        Scale of transition rates from sensitive to active. See
        `Population.scale_alpha`.
    scale_beta : float
        Scale of transition rates from active to refractory. See
        `Population.scale_beta`.
    scale_gamma : float
        Scale of transition rates from refractory to sensitive. See
        `Population.scale_gamma`.
    scale_theta : float
        Scale of thresholds. See `Population.scale_theta`.

    &#34;&#34;&#34;

    def __init__(self, name, ID=None, size=None):
        self.name = name
        if ID is None:
            ID = self._default_ID()
        self.ID = ID
        self.size = size

        self._means = {&#39;alpha&#39;: 1., &#39;beta&#39;: 1., &#39;gamma&#39;: 1., &#39;theta&#39;: 0.}
        self._scales = {&#39;alpha&#39;: 0., &#39;beta&#39;: 0., &#39;gamma&#39;: 0., &#39;theta&#39;: 1.}
        self._update_means()
        self._update_scales()

    def __str__(self):
        string = f&#39;{self.name}&#39;
        if self.size is not None:
            string += f&#39; - {self.size} neurons&#39;
        for mean in self._means:
            string += f&#39;\n{mean:&gt;11} = {self._means[mean]}&#39;
        for scale in self._scales:
            scale_name = &#39;scale &#39; + str(scale)
            string += f&#39;\n{scale_name:&gt;11} = {self._scales[scale]}&#39;
        return string

    @property
    def name(self):
        &#34;&#34;&#34;Name of the population. 

        Name given to the population to identify it in a network. It has to be
        a string. When setting a new name, if the population&#39;s ID was the
        default one, then the ID is updated according to the new name. 

        A population&#39;s name should never contain the string &#34; - &#34;, because this
        could lead to unexpected behavior when saving and loading data. An error
        will be raised if a name containing this string is set.
        &#34;&#34;&#34;
        return self._name

    @name.setter
    def name(self, new_name):
        if not isinstance(new_name, str):
            raise TypeError(&#39;A population\&#39;s name must be a string.&#39;)
        try:
            assert self.ID == self._default_ID()
        except (AttributeError, AssertionError):
            pass
        else:
            self.ID = self._default_ID(new_name)
        if &#39; - &#39; in new_name:
            raise PopNetError(&#39;A population\&#39;s name cannot contain the string &#39;
                              &#39;\&#39; - \&#39;.&#39;)
        self._name = new_name

    @property
    def ID(self):
        &#34;&#34;&#34;ID of the population. 

        ID given to the population. It must be a single character, else an
        error is raised when setting it. The ID is used as a subscript to
        identify state variables. 
        &#34;&#34;&#34;
        return self._ID

    @ID.setter
    def ID(self, new_ID):
        if len(str(new_ID)) != 1:
            raise PopNetError(&#39;A population\&#39;s ID must be a single character.&#39;)
        self._ID = str(new_ID)

    @property
    def size(self):
        &#34;&#34;&#34;Number of neurons in the population. 

        Number of neurons in the population. When it is defined, it must be a
        positive integer.
        &#34;&#34;&#34;
        return self._size

    @size.setter
    def size(self, new_value):
        if new_value is None:
            self._size = None
            return
        try:
            new_value = int(new_value)
        except TypeError as error:
            raise TypeError(&#39;A population\&#39;s size must be a number.&#39;) from error
        else:
            if not new_value &gt; 0:
                raise ValueError(&#39;A population\&#39;s size must be positive.&#39;)
        self._size = new_value

    @property
    def alpha(self):
        &#34;&#34;&#34;Mean `alpha` transition rate in the population.

        Mean value of the transition rates from sensitive to active (with
        sufficient input) in the population. 
        &#34;&#34;&#34;
        return self._alpha

    @alpha.setter
    def alpha(self, new_value):
        self._means[&#39;alpha&#39;] = float(new_value)
        self._alpha = float(new_value)

    @property
    def beta(self):
        &#34;&#34;&#34;Mean `beta` transition rate in the population.

        Mean value of the transition rates from active to refractory in the
        population.
        &#34;&#34;&#34;
        return self._beta

    @beta.setter
    def beta(self, new_value):
        self._means[&#39;beta&#39;] = float(new_value)
        self._beta = float(new_value)

    @property
    def gamma(self):
        &#34;&#34;&#34;Mean `gamma` transition rate in the population.

        Mean value of the transition rates from refractory to sensitive in the
        population. 
        &#34;&#34;&#34;
        return self._gamma

    @gamma.setter
    def gamma(self, new_value):
        self._means[&#39;gamma&#39;] = float(new_value)
        self._gamma = float(new_value)

    @property
    def theta(self):
        &#34;&#34;&#34;Mean threshold in the population. 

        Mean value of the thresholds of activation in the population. 
        &#34;&#34;&#34;
        return self._theta

    @theta.setter
    def theta(self, new_value):
        self._means[&#39;theta&#39;] = float(new_value)
        self._theta = float(new_value)

    @property
    def scale_alpha(self):
        &#34;&#34;&#34;Scaling factor of the `alpha` transition rate in the population.

        Scaling factor of the distribution of the transition rates from
        sensitive to active (with sufficient input) in the population, which is
        assumed to be a logistic distribution.
        &#34;&#34;&#34;
        return self._scale_alpha

    @scale_alpha.setter
    def scale_alpha(self, new_value):
        self._scales[&#39;alpha&#39;] = float(new_value)
        self._scale_alpha = float(new_value)

    @property
    def scale_beta(self):
        &#34;&#34;&#34;Scaling factor of the `beta` transition rate in the population.

        Scaling factor of the distribution of the transition rates from
        active to refractory in the population, which is assumed to be a
        logistic distribution.
        &#34;&#34;&#34;
        return self._scale_beta

    @scale_beta.setter
    def scale_beta(self, new_value):
        self._scales[&#39;beta&#39;] = float(new_value)
        self._scale_beta = float(new_value)

    @property
    def scale_gamma(self):
        &#34;&#34;&#34;Scaling factor of the `gamma` transition rate in the population.

        Scaling factor of the distribution of the transition rates from
        refractory to sensitive in the population, which is assumed to be a
        logistic distribution. 
        &#34;&#34;&#34;
        return self._scale_gamma

    @scale_gamma.setter
    def scale_gamma(self, new_value):
        self._scales[&#39;gamma&#39;] = float(new_value)
        self._scale_gamma = float(new_value)

    @property
    def scale_theta(self):
        &#34;&#34;&#34;Scaling factor of the thresholds in the population.

        Scaling factor of the distribution of the thresholds in the population,
        which is assumed to be a logistic distribution.
        &#34;&#34;&#34;
        return self._scale_theta

    @scale_theta.setter
    def scale_theta(self, new_value):
        self._scales[&#39;theta&#39;] = float(new_value)
        self._scale_theta = float(new_value)

    def copy(self, name, ID=None):
        &#34;&#34;&#34;Copy the population.

        Return a copy of the population with a new name and ID.

        Parameters
        ----------
        name : str
            Name to give to the new population.
        ID : str, optional
            ID to give to the new population. Defaults to `None`, in which case
            a default one is taken from the name.

        Returns
        -------
        Population
            The copied population.
        &#34;&#34;&#34;
        other = deepcopy(self)
        other.name = name
        if ID is None:
            ID = other._default_ID()
        other.ID = ID
        return other

    def F(self, y):
        &#34;&#34;&#34;Cumulative distribution function of the thresholds.

        Cumulative distribution function (CDF) of the thresholds in the
        population, assuming they follow a logistic distribution of mean `theta`
        and of scale factor `scale_theta`. 
        &#34;&#34;&#34;
        return expit((y - self.theta) / self.scale_theta)

    def dF(self, y):
        &#34;&#34;&#34;First derivative of the thresholds&#39; CDF. See `Population.F`.&#34;&#34;&#34;
        return 1 / self.scale_theta * self.F(y) * (1 - self.F(y))

    def ddF(self, y):
        &#34;&#34;&#34;Second derivative of the thresholds&#39; CDF. See `Population.F`.&#34;&#34;&#34;
        return 1 / self.scale_theta**2 * ( 
                                self.F(y) * (1 - self.F(y)) * (1 - 2*self.F(y)))

    def dddF(self, y):
        &#34;&#34;&#34;Third derivative of the thresholds&#39; CDF. See `Population.F`.&#34;&#34;&#34;
        return 1 / self.scale_theta**3 * (
               self.F(y) * (1 - self.F(y)) * (1 - 6*self.F(y) + 6*self.F(y)**2))

    def Finv(self, y):
        &#34;&#34;&#34;Inverse of the thresholds&#39; CDF. See `Population.F`.&#34;&#34;&#34;
        return self.theta + self.scale_theta * logit(y)

    def g(self, x, y):
        &#34;&#34;&#34;Scale factor added to `F` to define `G`.&#34;&#34;&#34;
        return np.where(x == self.theta, y / (4 * self.scale_theta**2),
                        (y / (2 * (self.theta - x) * self.scale_theta)
                                * (1 - 2*self.F(x))))

    def G(self, x, y):
        &#34;&#34;&#34;Rescaled cumulative distribution function of the thresholds.&#34;&#34;&#34;
        return self.F((x + self.theta * self.g(x,y)) / (1 + self.g(x,y)))

    def H(self, X, S, B, CXS, CXB, CSB, VarB):
        &#34;&#34;&#34;Approximation of the covariance between *X* and *SF(B)*.

        Function used to approximate the covariance between *X* and *SF(B)* in
        terms of the expectations and covariances of *X*, *S* and *B* and of the
        variance of *B*. Here *F* is `Population.F`. This method is mainly
        intended to be used in the dynamical system for the extended
        Wilson--Cowan model.
        &#34;&#34;&#34;
        return np.where(S == 0, 0, 
                        np.where(X == 0, 0,
                                 ((X*S + CXS) * self.G(B + CSB/S + CXB/X, VarB)
                                    - X*S * self.G(B + CSB/S, VarB))))

    def set_means(self, **new_values):
        &#34;&#34;&#34;Set the means of population parameters.

        Assign new values to some of the means of the population&#39;s parameters:
        `alpha`, `beta`, `gamma` and `theta`.

        Parameters
        ----------
        **new_values
            New values to assign to means of valid population parameters. 

        Raises
        ------
        KeyError
            If non-valid parameters are requested.
        &#34;&#34;&#34;
        for key in new_values:
            if key not in self._means:
                raise KeyError(f&#39;{key} is not a valid population parameter.&#39;)
            self._means[key] = float(new_values[key])
        self._update_means()

    def set_random_rates(self, rates=None, distribution=&#39;exponential&#39;, **kwargs):
        &#34;&#34;&#34;Randomly set the transition rates from a given distribution.

        Choose a random value for the transition rates from a given distribution
        family with given parameters. The random value is generated using a
        [`Generator`](https://tinyurl.com/numpy-random-generator) instance from
        NumPy&#39;s `random` module, and keyword arguments can be passed to the
        `Generator`&#39;s method used to generate the random values.

        Parameters
        ----------
        rates : list or tuple of str, or str, optional
            The transition rates that should be chosen randomly. It should
            contain valid rates in `alpha`, `beta` or `gamma`, or be one of
            these strings. 
        distribution : {&#39;uniform&#39;, &#39;exponential&#39;}, optional
            The distribution family used to choose a value for the rates.
            Defaults to `&#39;uniform&#39;`. 
        **kwargs
            Keyword arguments to be passed to the method of `Generator`
            corresponding to the correct distribution family. 

        Raises
        ------
        TypeError
            If `rates` is not a list, tuple, or str.
        KeyError
            If the strings given in `rates` are not valid transition rates.
        NotImplementedError
            If the requested distribution family is not implemented.
        &#34;&#34;&#34;
        if rates is None:
            rates = [&#39;alpha&#39;, &#39;beta&#39;, &#39;gamma&#39;]
        if isinstance(rates, str):
            rates = [rates]
        if not isinstance(rates, (list, tuple)):
            raise TypeError(&#39;Population.set_random_rates expects its first &#39;
                            &#39;argument to be either a list of rates given as &#39;
                            &#39;strings, or a single rate given as a string.&#39;)
        for rate in rates:
            if rate not in [&#39;alpha&#39;, &#39;beta&#39;, &#39;gamma&#39;]:
                raise KeyError(f&#39;{rate} is not a valid transition rate.&#39;)
            rng = np.random.default_rng()
            if distribution == &#39;uniform&#39;:
                self._means[rate] = rng.uniform(**kwargs)
                continue
            elif distribution == &#39;exponential&#39;:
                self._means[rate] = rng.exponential(**kwargs)
                continue
            raise NotImplementedError(f&#39;No {distribution} distribution available&#39;
                                      &#39; to randomly set a transition rate.&#39;)
        self._update_means()

    def set_random_threshold(self, distribution=&#39;uniform&#39;, **kwargs):
        &#34;&#34;&#34;Randomly set the threshold from a given distribution.

        Choose a random value for the threshold from a given distribution family
        with given parameters. The random value is generated using a
        [`Generator`](https://tinyurl.com/numpy-random-generator) instance from
        NumPy&#39;s `random` module, and keyword arguments can be passed to the
        `Generator`&#39;s method used to generate the random values.

        Parameters
        ----------
        distribution : {&#39;uniform&#39;}, optional
            The distribution family used to choose a value for the threshold.
            Defaults to `&#39;uniform&#39;`, which is for now the only implemented
            distribution. 
        **kwargs
            Keyword arguments to be passed to the method of `Generator`
            corresponding to the correct distribution family. 

        Raises
        ------
        NotImplementedError
            If the requested distribution family is not implemented. 
        &#34;&#34;&#34;
        if distribution == &#39;uniform&#39;:
            self.theta = np.random.default_rng().uniform(**kwargs)
            return
        raise NotImplementedError(f&#39;No {distribution} distribution available &#39;
                                  &#39;to randomly set a threshold.&#39;)

    def set_scales(self, **new_values):
        &#34;&#34;&#34;Set the scales of population parameters.

        Assign new values to some of the scales of the population&#39;s parameters:
        `alpha`, `beta`, `gamma` and `theta`.

        Parameters
        ----------
        **new_values
            New values to assign to scales of valid population parameters. 

        Raises
        ------
        KeyError
            If non-valid parameters are requested.
        &#34;&#34;&#34;
        for key in new_values:
            if key not in self._scales:
                raise KeyError(f&#39;{key} is not a valid population parameter.&#39;)
            self._scales[key] = float(new_values[key])
        self._update_scales()

    def _default_ID(self, name=None):
        &#34;&#34;&#34;Get a default ID based on `name`.

        Get a default ID based on the name `name`. If `name` ends with a number,
        this number is returned. Else, the first letter of `name` is returned.

        Parameters
        ----------
        name : str, optional
            Name from which to get an ID. Defaults to `None`, in which case the
            `name` attribute is used instead.

        Returns
        -------
        str
            The said default ID.
        &#34;&#34;&#34;
        if name is None:
            name = self.name
        assert isinstance(name, str), &#39;\&#39;name\&#39; argument should be a string.&#39;
        try:
            no = int(name[-1])
        except:
            return name[0]
        else:
            return str(no)

    @classmethod
    def _load(cls, lines):
        &#34;&#34;&#34;Load a population.

        Load a population&#39;s parameters from a list of strings, which should be
        the lines of a string representation of a `Population` instance.

        Parameters
        ----------
        lines : list of str
            Strings from which the parameters are to be set. It should be the
            lines of a string representation of a `Population` instance.

        Returns
        -------
        Population
            The loaded population.

        Raises
        ------
        KeyError
            If `string` contains assignments to non-valid parameters.
        popnet.exceptions.FormatError
            If `string` does not have the expected format. 
        &#34;&#34;&#34;
        lines = [line.replace(&#39;\n&#39;, &#39;&#39;) for line in lines]
        name_line = lines[0].split(&#39; - &#39;)
        pop = Population(name_line[0].strip())
        if len(name_line) == 2:
            try:
                pop.size = name_line[-1].strip().split()[0]
            except ValueError as error:
                raise PopNetError(&#39;An unexpected error occurred when loading &#39;
                                  &#39;data for a population. It might be due to a &#39;
                                  &#39;name containing the string &#34; - &#34;.&#39;) from error
        for line in lines[1:]:
            # Take the part of the line specifying the parameter to set.
            param_spec = line[:11].strip().split()
            if (n := len(param_spec)) == 0:
                # If there is nothing on the line, continue to the next one.
                continue
            if n == 1:
                # If there is a single word, it should give a parameter&#39;s mean.
                param = param_spec[0]
                if param not in pop._means:
                    raise KeyError(f&#39;{param} is not a valid parameter.&#39;)
                pop._means[param] = float(line[14:])
            elif n == 2:
                # If there is two words, it should give a parameter&#39;s scale.
                scale = param_spec[0]
                param = param_spec[1]
                if scale != &#39;scale&#39; or param not in pop._scales:
                    raise KeyError(f&#39;{scale} {param} is not a valid parameter.&#39;)
                pop._scales[param] = float(line[14:])
            else:
                # If there more than two words, something is wrong...
                raise FormatError(&#39;It seems that the string cannot be used to &#39;
                                  &#39;define the parameters of a Population &#39;
                                  &#39;instance.&#39;)
        pop._update_means()
        pop._update_scales()
        return pop

    def _update_means(self):
        &#34;&#34;&#34;Update the parameters&#39; means according to `_means` values.

        Update the attributes `alpha`, `beta`, `gamma` and `theta` according to
        the values of the corresponding entries of `._means`. It is intended to
        be used internally in other methods when setting new values to
        parameters, to ensure that the values in `_means` are consistent
        with the values of the corresponding attributes.
        &#34;&#34;&#34;
        self.alpha = self._means[&#39;alpha&#39;]
        self.beta  = self._means[&#39;beta&#39;]
        self.gamma = self._means[&#39;gamma&#39;]
        self.theta = self._means[&#39;theta&#39;]

    def _update_scales(self):
        &#34;&#34;&#34;Update the parameters&#39; scales according to `_scales` values.

        Update the attributes `scale_alpha`, `scale_beta`, `scale_gamma` and
        `scale_theta` according to the values of the corresponding entries of
        `_scales`. It is intended to be used internally in other methods when
        setting new values to parameters, to ensure that the values in `_scales`
        are consistent with the values of the corresponding attributes.
        &#34;&#34;&#34;
        self.scale_alpha = self._scales[&#39;alpha&#39;]
        self.scale_beta  = self._scales[&#39;beta&#39;]
        self.scale_gamma = self._scales[&#39;gamma&#39;]
        self.scale_theta = self._scales[&#39;theta&#39;]


class Network:
    &#34;&#34;&#34;Represent a biological neural network from a macroscopic point of view.

    Represents a biological neural network split into different populations.
    Each population of such a network is expected to be a `Population` instance.
    The purpose of this class is to have a consistent interface to define,
    modify, save, or load the parameters of a network.

    Parameters
    ----------
    ID : str
        ID of the network.
    populations : tuple of Population, or Population
        Defines the populations that constitute the network. Can be given as a
        `Population` instance to make a network with a single population. 

    Attributes
    ----------
    ID : str
        ID of the network. See `Network.ID`.
    populations : tuple of Population
        Populations of the network. See `Network.populations`.
    c : array_like
        Connection matrix. See `Network.c`.
    scale_c : array_like
        Scale of connection weights. See `Network.scale_c`.

    Raises
    ------
    TypeError
        If `populations` cannot be converted to a tuple of `Population`
        instances.

    &#34;&#34;&#34;

    def __init__(self, ID, populations):
        try:
            self._populations = tuple(populations)
        except TypeError:
            self._populations = (populations,)
        if not all(isinstance(pop, Population) for pop in self._populations):
            raise TypeError(&#39;The &#34;populations&#34; attribute of a Network instance &#39;
                            &#39;should be a tuple of Population instances.&#39;)
        self.ID = ID
        self.c = np.ones((p := len(self.populations), p))
        self.scale_c = np.zeros((p, p))

    def __str__(self):
        string = f&#39;Network {self.ID}\n\n&#39;
        for pop in self.populations:
            string += str(pop)
            string += &#39;\n\n&#39;
        string += f&#39;Connection matrix:\n{self.c}&#39;
        return string

    @staticmethod
    def load(load_ID, new_ID=None, folder=None):
        &#34;&#34;&#34;Alias for `load_network`.&#34;&#34;&#34;
        return load_network(load_ID, new_ID=new_ID, folder=folder)

    @property
    def ID(self):
        &#34;&#34;&#34;ID of the network.

        ID given to the network. Its first character has to be the number of
        populations of the network, else an error is raised when setting it.
        The ID is used to name files when saving the network parameters.
        &#34;&#34;&#34;
        return self._ID

    @ID.setter
    def ID(self, new_ID):
        if not isinstance(new_ID, str):
            raise TypeError(&#39;The network\&#39;s ID should be a string.&#39;)
        if int(new_ID[0]) != len(self.populations):
            raise PopNetError(&#39;The first character of the network\&#39;s ID should &#39;
                              &#39;be its number of populations.&#39;)
        self._ID = new_ID

    @property
    def populations(self):
        &#34;&#34;&#34;Populations of the network.

        Tuple containing the populations of the network, given as `Population`
        instances. It is set at initialization, but it cannot be reset nor
        deleted afterwards.
        &#34;&#34;&#34;
        return self._populations

    @property
    def c(self):
        &#34;&#34;&#34;Connection matrix of the network.

        Describes the weights of connections between populations of the network.
        The exact relation to the weights of links between individual neurons of
        the network is described in the [Notes](#network-c-notes) section below.
        It has to be a square matrix, but it can be given as a float if the
        network has only one population.

        Notes {#network-c-notes}
        -----
        For clarity, let *J* and *K* be the *j*th and *k*th populations of the
        network respectively, following the order given in the `populations`
        attribute. Then, the element `c[j,k]` of `c` describes the link *from K
        to J*. From the microscopic point of view, it is the product of the size
        of *K* with the mean value of the weights of links from neurons of *K*
        to neurons of *J*. 
        &#34;&#34;&#34;
        return self._c

    @c.setter
    def c(self, new_c):
        try:
            float_new_c = float(new_c)
        except:
            pass
        else:
            new_c = np.array([[float_new_c]])
        if np.shape(new_c) != (p := len(self.populations), p):
            raise PopNetError(&#39;The connection matrix c should be a square &#39;
                              &#39;array whose size corresponds to the number of &#39;
                              &#39;populations of the network.&#39;)
        self._c = np.array(new_c, float)

    @property
    def scale_c(self):
        &#34;&#34;&#34;Scaling factor of the weights&#39; distributions.

        Scaling factors used to define the weights&#39; distributions, which are all
        assumed to be logistic. The exact relation to the weights of links
        between individual neurons of the network is described in the
        [Notes](#network-scale-c-notes) section below. It has to be a square
        matrix, but it can be given as a float if the network has only one
        population.

        Notes {#network-scale-c-notes}
        -----
        If *J* and *K* are respectively the *j*th and the *k*th populations of
        the network, following the order given in the `populations` attribute,
        the actual scaling factor of the *non-zero* weights of links from
        neurons of *K* to neurons of *J* is

        \\[ \\frac{ s_{JK} P_{JK} }{ |K| } \\]

        where \\(s_{JK}\\) is `scale_c[j,k]`, \\(P_{JK}\\) is the probability of
        connection from neurons of *J* to neurons of *K*, and \\(|K|\\) is the
        size of *K*. 
        &#34;&#34;&#34;
        return self._scale_c

    @scale_c.setter
    def scale_c(self, new_scale):
        try:
            float_new_scale = float(new_scale)
        except:
            pass
        else:
            new_scale = np.array([[float_new_scale]])
        if np.shape(new_scale) != (p := len(self.populations), p):
            raise PopNetError(&#39;The scales of the weights should be a square &#39;
                              &#39;array whose size corresponds to the number of &#39;
                              &#39;populations of the network.&#39;)
        self._scale_c = np.array(new_scale, float)

    def copy(self, new_ID):
        &#34;&#34;&#34;Copy the network.

        Return a copy of the network with a new ID. 

        Parameters
        ----------
        new_ID : str
            ID to give to the new network.

        Returns
        -------
        Network
            The copied network.
        &#34;&#34;&#34;
        other = deepcopy(self)
        other.ID = new_ID
        return other

    def extend(self, ID):
        &#34;&#34;&#34;Extend the network.

        Return an extension of the present network, that is, return a new
        network with the same populations and the same connexions, but with
        more populations as well.

        The new network will have the number of populations given by the first
        character of `ID`. This number should be higher than the number of
        populations of the present network. If it is equal, a copy of the
        network is simply returned.

        Note that the resulting network never has a microscopic structure,
        since the new populations will be defined with no sizes.
        
        Parameters
        ----------
        ID : str
            ID of the new network. Its first character will give the number of
            populations of the new network.

        Raises
        ------
        popnet.exceptions.PopNetError
            If the network is asked to be extended into a smaller network.
        &#34;&#34;&#34;
        new_p = int(ID[0])
        p = len(self.populations)
        if new_p &lt; p:
            raise PopNetError(&#39;Can\&#39;t extend a network into a smaller one.&#39;)
        if new_p == p:
            return self.copy()
        pops = [pop.copy(pop.name) for pop in self.populations]
        for j in range(p, new_p):
            pops.append(Population(f&#39;Population {j+1}&#39;))
        net = Network(ID, pops)
        net.c[:p,:p] = self.c
        net.scale_c[:p,:p] = self.scale_c
        return net

    def save(self, folder=None, note=None):
        &#34;&#34;&#34;Save the network&#39;s parameters in a text file.

        Save the string representation of the network in a text file, under the
        name *ID - Network parameters.txt*, where *ID* is the `ID` attribute.

        Parameters
        ----------
        folder : str, optional
            A folder in which the file is saved. If it does not exist in the
            current directory, it is created. Defaults to `None`, in which case
            the file is saved in the current directory.
        note : str, optional
            If given, an additional section &#34;Additional notes:&#34; is written in
            the file, and `note` is written there. 
        &#34;&#34;&#34;
        filename = _internals._format_filename(folder, self.ID, 
                                               &#39;Network parameters&#39;)
        _internals._make_sure_folder_exists(folder)
        with open(filename, &#39;w&#39;, encoding=&#39;utf-8&#39;) as file:
            file.write(str(self))
            if note is not None:
                file.write(&#39;\n\nAdditional notes:\n&#39;)
                file.write(note)

    def set_random_c(self, distribution=&#39;uniform&#39;, signs=None, **kwargs):
        &#34;&#34;&#34;Randomly set the connection matrix. 

        Choose random values for entries of the connection matrix from a given
        distribution family with given parameters. The random value is generated
        using a [`Generator`](https://tinyurl.com/numpy-random-generator)
        instance from NumPy&#39;s `random` module, and keyword arguments can be
        passed to the `Generator`&#39;s method used to generate the random values.

        Parameters
        ----------
        distribution : {&#39;uniform&#39;, &#39;exponential&#39;}, optional
            The distribution family used to choose a value for the threshold. If
            a positive distribution is chosen, the signs of the components of
            `c` are supposed to be fixed by `signs`. Defaults to `&#39;uniform&#39;`. 
        signs : array_like, optional
            A matrix that multiplies the random results. It is intended to be
            used to assign specific signs to the components of `c`. It should be
            a square matrix of -1&#39;s and 1&#39;s of the same shape as `c`. Defaults
            to `None`, in which case it is replaced by an array of ones.
        **kwargs
            Keyword arguments to be passed to the method of `Generator` 
            corresponding to the correct distribution family. 

        Raises
        ------
        NotImplementedError
            If the requested distribution family is not implemented. 
        &#34;&#34;&#34;
        shape = (p := len(self.populations), p)
        if signs is None:
            signs = np.ones(shape)
        else:
            signs = np.array(signs, float)
        rng = np.random.default_rng()
        if distribution == &#39;uniform&#39;:
            self.c = signs * rng.uniform(size=shape, **kwargs)
            return
        elif distribution == &#39;exponential&#39;:
            self.c = signs * rng.exponential(size=shape, **kwargs)
            return
        raise NotImplementedError(f&#39;No {distribution} distribution available &#39;
                                  &#39;to randomly set a connection matrix.&#39;)

    def underlying(self):
        &#34;&#34;&#34;Get the microscopic network underlying the present macroscopic one.

        Return the microscopic network underlying the present macroscopic
        network of populations. The returned network has the same ID, the same
        populations and the same parameters as the present one.

        Returns
        -------
        MicroNetwork
            The underlying microscopic network.
        &#34;&#34;&#34;
        microself = MicroNetwork(self.ID, self.populations)
        microself.c = self.c
        microself.scale_c = self.scale_c
        microself.reset_parameters()
        return microself

    def _set_c_from_string(self, string):
        &#34;&#34;&#34;Set the connection matrix from a string.

        Set the connection matrix `c` from a string.

        Parameters
        ----------
        string : str
            String from which the connection matrix is set. It should have the
            format of a string representation of a NumPy array. 

        Raises
        ------
        FormatError
            If the string does not have the correct format. 
        &#34;&#34;&#34;
        if string[-1] == &#39;\n&#39;:
            string = string[:-1]
        string = re.sub(r&#39;\[\s+&#39;, &#39;[&#39;, string)
        string = re.sub(r&#39;\s+\]&#39;, &#39;]&#39;, string)
        string = re.sub(r&#39;\s+&#39;, &#39;,&#39;, string)
        try:
            new_c = ast.literal_eval(string)
        except:
            raise FormatError(&#39;It seems that the string cannot be converted &#39;
                              &#39;to a connection matrix.&#39;)
        self.c = new_c


class MicroNetwork(Network):
    &#34;&#34;&#34;Represent a biological neural network from a microscopic point of view.

    The `MicroNetwork` class extends the `Network` class to characterize
    individual neurons rather than characterizing only their mean values and
    scales by populations. It introduces new attributes to get the values of
    transition rates, thresholds and weights of connection for all neurons.

    The initialization of a `MicroNetwork` is the same as in the base class,
    except that the parameters of individual neurons of the network are also
    initialized. Hence, the size of every population of the network must be
    defined.

    !!! note
        It is important to understand that, even if parameters `alpha`, `beta`,
        `gamma`, `theta` and `W` are generated automatically from the
        corresponding mean values and scaling factors at initialization, it does
        *not* mean that they will be updated upon update of the mean values or
        scaling factors, or upon change in the size of the network. In order to
        remain consistent when new values are set, parameters should be reset
        with `MicroNetwork.reset_parameters`.

    Raises
    ------
    popnet.exceptions.PopNetError
        If the size of a population is not defined.

    &#34;&#34;&#34;

    def __init__(self, ID, populations):
        super().__init__(ID, populations)
        if any(pop.size is None for pop in populations):
            raise PopNetError(&#39;Cannot define a MicroNetwork if the sizes of &#39;
                              &#39;its populations are not defined.&#39;)
        self.reset_parameters()

    @property
    def alpha(self):
        &#34;&#34;&#34;Transition rates from sensitive to active.
        
        Array of transition rates from sensitive to active (with sufficient
        input) of all neurons of the network. It cannot be set nor deleted, but
        it can be reset with `MicroNetwork.reset_parameters`.
        &#34;&#34;&#34;
        return self._alpha

    @property
    def beta(self):
        &#34;&#34;&#34;Transition rates from active to refractory.
        
        Array of transition rates from active to refractory of all neurons of
        the network. It cannot be set nor deleted, but can be reset with
        `MicroNetwork.reset_parameters`.
        &#34;&#34;&#34;
        return self._beta

    @property
    def gamma(self):
        &#34;&#34;&#34;Transition rates from refractory to sensitive.
        
        Array of transition rates from refractory to sensitive of all neurons of
        the network. It cannot be set nor deleted, but can be reset with
        `MicroNetwork.reset_parameters`.
        &#34;&#34;&#34;
        return self._gamma

    @property
    def theta(self):
        &#34;&#34;&#34;Thresholds.
        
        Array of thresholds of all neurons of the network. It cannot be set nor
        deleted, but it can be reset with `MicroNetwork.reset_parameters`.
        &#34;&#34;&#34;
        return self._theta

    @property
    def W(self):
        &#34;&#34;&#34;Weight matrix.
        
        Array of weights of connection between neurons of the network. An
        element `W[j,k]` of `W` is the weight of the connection *from* `k` *to*
        `j`. It has to be a real matrix of shape \\(N \\times N\\), where
        \\(N\\) is the size of the network. It cannot be deleted.
        &#34;&#34;&#34;
        return self._W

    @W.setter
    def W(self, new_value):
        try:
            new_value = np.array(new_value, float)
        except (TypeError, ValueError) as err:
            raise ValueError(&#39;A weight matrix must have real entries.&#39;) from err
        if new_value.shape != (self.size(), self.size()):
            raise PopNetError(&#39;A weight matrix should be square with shape N x &#39;
                              &#39;N, where N is the size of the network.&#39;)
        self._W = new_value

    def reset_parameters(self, params=None):
        &#34;&#34;&#34;Randomly generate the parameters of the network&#39;s neurons.

        Generate the parameters that characterize the neurons of the network.
        All parameters are taken from logistic distributions with means and
        scaling factors consistent with the values given by the populations.
        Since transition rates must be positive, the logistic distributions for
        them are in fact truncated --- see the
        [Notes](micronetwork-reset-parameters-notes) section below.

        Parameters
        ----------
        params : list or tuple of str or str, optional
            Parameters to be reset. It should contain only valid parameters
            (`&#39;alpha&#39;`, `&#39;beta&#39;`, `&#39;gamma&#39;`, `&#39;theta&#39;` or `&#39;W&#39;`), or be a single
            parameter given as a string. Defaults to `None`, in which case all
            parameters are reset.

        Raises
        ------
        TypeError
            If `params` is neither a list, a tuple nor a string.
        PopNetError
            If an entry of `params` is not a valid population parameter.

        Notes {#micronetwork-reset-parameters-notes}
        -----
        All transition rates `alpha`, `beta` and `gamma` should always be
        positive. Hence, when taking samples from logistic distributions to
        get individual values for these pararameters for all neurons of the
        network, we actually truncate the logistic distributions by rejecting
        all negative values and replacing them with other samples.
        &#34;&#34;&#34;
        valid_params = (&#39;alpha&#39;, &#39;beta&#39;, &#39;gamma&#39;, &#39;theta&#39;, &#39;W&#39;)
        if params is None:
            params = valid_params
        if isinstance(params, str):
            params = (params,)
        if not isinstance(params, (list, tuple)):
            raise TypeError(&#39;\&#39;params\&#39; should be a list, tuple or string.&#39;)
        if any(param not in valid_params for param in params):
            raise PopNetError(f&#39;An entry in {params} is not a valid population &#39;
                              &#39;parameter.&#39;)
        rng = np.random.default_rng()

        def sample_rate(rng, mean, scale, size):
            sample = rng.logistic(mean, scale, size=size)
            nsteps = 0
            while np.any(sample &lt; 0) or nsteps &gt; 100:
                sample = np.where(sample &lt; 0, rng.logistic(mean, scale), sample)
                nsteps += 1
            return sample

        if &#39;alpha&#39; in params:
            self._alpha = np.concatenate(
                        [sample_rate(rng, pop.alpha, pop.scale_alpha, pop.size)
                         for pop in self.populations])
        if &#39;beta&#39; in params:
            self._beta  = np.concatenate(
                        [sample_rate(rng, pop.beta, pop.scale_beta, pop.size)
                         for pop in self.populations])
        if &#39;gamma&#39; in params:
            self._gamma = np.concatenate(
                        [sample_rate(rng, pop.gamma, pop.scale_gamma, pop.size)
                         for pop in self.populations])
        if &#39;theta&#39; in params:
            self._theta = np.concatenate(
                        [rng.logistic(pop.theta, pop.scale_theta, size=pop.size)
                         for pop in self.populations])
        if &#39;W&#39; in params:
            self._W = np.block([[rng.logistic(
                                    self.c[J,K]/popK.size,
                                    self.scale_c[J,K]/popK.size,
                                    size=(popJ.size, popK.size)) 
                                for K, popK in enumerate(self.populations)] 
                                for J, popJ in enumerate(self.populations)])

    def size(self):
        &#34;&#34;&#34;Get the size of the network.&#34;&#34;&#34;
        return np.sum([pop.size for pop in self.populations])

    @property
    def underlying(self):
        raise AttributeError(&#39;\&#39;MicroNetwork\&#39; object has no attribute &#39;
                             &#39;\&#39;underlying\&#39;&#39;)


class Configuration:
    &#34;&#34;&#34;Configurations used in numerical experiments.

    The `Configuration` class allows to easily group together all parameters
    that are needed to perform numerical experiments. Although the base class
    can be used with any network of any number of populations, it is better to
    use the `ConfigurationOne` subclass for the case where the network has only
    one population and the `MicroConfiguration` subclass when the network has a
    defined microscopic structure, as more features are available in these
    cases.

    Parameters
    ----------
    network : Network
        Network associated with the configuration.
    ID : str, optional
        ID to associate with the configuration. Defaults to `None`, in which case
        the network&#39;s ID is used.
    **kwargs
        Keyword arguments used to initialize other data attributes.

    Attributes
    ----------
    ID : str
        ID of the configuration. See `Configuration.ID`.
    network : Network
        Network associated with the configuration. See `Configuration.network`.
    initial_state : array_like
        Initial state of the network. See `Configuration.initial_state`.
    Q : array_like
        Input in the network. See `Configuration.Q`.
    initial_time, final_time : float
        Times between which the evolution of the network&#39;s state is studied.
        See `Configuration.initial_time` and `Configuration.final_time`.
    iterations : int
        Number of iterations used for the numerical integration, if performed.
        See `Configuration.iterations`.
    delta : float
        Time interval between two iterations. See `Configuration.delta`.

    Raises
    ------
    TypeError
        If the second argument is not a `Network` instance.
    KeyError
        If a keyword argument is not a valid attribute.

    &#34;&#34;&#34;

    def __init__(self, network, ID=None, **kwargs):
        if not isinstance(network, Network):
            raise TypeError(&#39;The network associated with a configuration &#39;
                            &#39;should indeed be a Network instance.&#39;)
        self._network = network

        if ID is None:
            ID = network.ID
        self.ID = ID

        state_attributes = {&#39;Q&#39;: np.zeros(p := len(self.network.populations)), 
                            &#39;initial_state&#39;: np.zeros(p * (2*p + 3))}
        float_attributes = {&#39;initial_time&#39;: 0., &#39;final_time&#39;: 10.}
        int_attributes = {&#39;iterations&#39;: 1000}

        # Here the time attributes have to be initialized without calling the 
        # setter methods, because they reference each other, so they all have to
        # be already defined when a setter is called. 
        for attr in kwargs:
            if attr in state_attributes:
                setattr(self, attr, kwargs[attr])
                state_attributes.pop(attr)
            elif attr in float_attributes:
                setattr(self, &#39;_&#39;+attr, float(kwargs[attr]))
                float_attributes.pop(attr)
            elif attr in int_attributes:
                setattr(self, &#39;_&#39;+attr, int(kwargs[attr]))
                int_attributes.pop(attr)
            else:
                raise KeyError(f&#39;{attr} is not a valid parameter for the &#39;
                               &#39;Configuration class.&#39;)

        for attr in state_attributes:
            setattr(self, attr, state_attributes[attr])
        for attr in float_attributes:
            setattr(self, &#39;_&#39;+attr, float_attributes[attr])
        for attr in int_attributes:
            setattr(self, &#39;_&#39;+attr, int_attributes[attr])

        self.delta = (self.final_time - self.initial_time) / self.iterations

        A_labels = [f&#39;A[{pop.ID}]&#39; for pop in self.network.populations]
        R_labels = [f&#39;R[{pop.ID}]&#39; for pop in self.network.populations]
        CAA_labels = [f&#39;CAA[{popJ.ID},{popK.ID}]&#39;
                        for J, popJ in enumerate(self.network.populations)
                        for popK in self.network.populations[J:]]
        CRR_labels = [f&#39;CRR[{popJ.ID},{popK.ID}]&#39;
                        for J, popJ in enumerate(self.network.populations)
                        for popK in self.network.populations[J:]]
        CAR_labels = [f&#39;CAR[{popJ.ID},{popK.ID}]&#39;
                        for popJ in self.network.populations
                        for popK in self.network.populations]
        self._variables = (A_labels + R_labels 
                            + CAA_labels + CRR_labels + CAR_labels)

    def __str__(self):
        string = (f&#39;Configuration {self.ID}\n\n&#39;
                  f&#39;Network used: {self.network.ID}\n&#39;)
        string += (&#39;\nParameters:\n&#39;
                  f&#39;       ti = {self.initial_time}\n&#39;
                  f&#39;       tf = {self.final_time}\n&#39;
                  f&#39;       \u0394t = {self.delta}\n&#39;
                  f&#39;{self.iterations:&gt;9} iterations\n&#39;)
        if self._other_params_string() is not None:
            string += self._other_params_string()
        string += (&#39;\nInput:\n&#39;
                  f&#39;        Q = {self.Q}\n&#39;)
        string += &#39;\nInitial state:\n&#39;
        for var, val in zip(self._variables, self.initial_state):
            string += f&#39;{var:&gt;9} = {val}\n&#39;
        return string[:-1] #Remove the last &#39;\n&#39;

    @staticmethod
    def load(load_ID, new_ID=None, network=None, folder=None):
        &#34;&#34;&#34;Alias for `load_config`.&#34;&#34;&#34;
        return load_config(load_ID, new_ID=None, network=None, folder=None)

    @property
    def ID(self):
        &#34;&#34;&#34;ID of the configuration.

        ID given to the configuration. It has to be a string that begins with
        the associated network&#39;s ID. It is used to name files when saving the
        configuration. Setting its value will raise an error if it is not a
        string or if it does not begin with the network&#39;s ID.
        &#34;&#34;&#34;
        return self._ID

    @ID.setter
    def ID(self, new_ID):
        if not isinstance(new_ID, str):
            raise TypeError(&#39;The configuration\&#39;s ID should be a string.&#39;)
        if new_ID[:len(self.network.ID)] != self.network.ID:
            raise ValueError(&#39;The ID of the configuration should begin with &#39;
                             &#39;that of the network&#39;)
        self._ID = new_ID

    @property
    def network(self):
        &#34;&#34;&#34;Network associated with the configuration.

        Network associated with the configuration, as a `Network` instance. It
        is set at initialization, but it cannot be reset nor deleted afterwards.
        &#34;&#34;&#34;
        return self._network

    @property
    def initial_state(self):
        &#34;&#34;&#34;Initial state of the configuration.

        The initial state of the network. As detailed in the
        [Notes](#configuration-initial-state-notes) section below, if the
        network has *p* populations, the initial state always has *p*(2*p*+3)
        components. The setter method ensures that the initial state is always
        a NumPy array of floats of the correct length. If it is set as a shorter
        array, it will be filled with zeros and a warning will be issued.

        Notes {#configuration-initial-state-notes}
        -----
        Since it is simpler to assume that every configuration can be used with
        any PopNet executor, the initial state of any configuration should have
        the number of components of the highest dimensional dynamical system
        studied by this package, which is the extended system. For a network of
        *p* populations, the extended system has *p*(2*p*+3) dimensions: there
        are *p* equations for *A*&#39;s, *p* equations for *R*&#39;s, *p*(*p*+1)/2
        equations for covariances between *A*&#39;s, *p*(*p*+1)/2 equations for
        covariances between *R*&#39;s, and *p*&lt;sup&gt;2&lt;/sup&gt; equations for covariances
        between *A*&#39;s and *R*&#39;s. The states are assumed to be ordered as
        follows:
        \\[ 
            (\\begin{aligned}[t]
            &amp; A_1, A_2, ..., A_p, \\\\
            &amp; R_1, R_2, ..., R_p, \\\\
            &amp; \\mathrm{C}_{AA}^{11}, \\mathrm{C}_{AA}^{12}, ..., 
                \\mathrm{C}_{AA}^{1p}, \\mathrm{C}_{AA}^{22}, ..., 
                \\mathrm{C}_{AA}^{2p}, \\mathrm{C}_{AA}^{33}, ..., 
                \\mathrm{C}_{AA}^{3p}, ..., \\mathrm{C}_{AA}^{pp}, \\\\
            &amp; \\mathrm{C}_{RR}^{11}, \\mathrm{C}_{RR}^{12}, ..., 
                \\mathrm{C}_{RR}^{1p}, \\mathrm{C}_{RR}^{22}, ..., 
                \\mathrm{C}_{RR}^{2p}, \\mathrm{C}_{RR}^{33}, ..., 
                \\mathrm{C}_{RR}^{3p}, ..., \\mathrm{C}_{RR}^{pp}, \\\\
            &amp; \\mathrm{C}_{AR}^{11}, \\mathrm{C}_{AR}^{12}, ..., 
                \\mathrm{C}_{AR}^{1p}, \\mathrm{C}_{AR}^{21}, ...,
                \\mathrm{C}_{AR}^{2p}, ..., \\mathrm{C}_{AR}^{p1}, 
                \\mathrm{C}_{AR}^{p2}, ..., \\mathrm{C}_{AR}^{pp}).
            \\end{aligned}
        \\]
        Remark that there are no \\(\\mathrm{C}_{AA}^{21}\\) or
        \\(\\mathrm{C}_{RR}^{21}\\) components, for example, since the
        \\(\\mathrm{C}_{AA}\\) and \\(\\mathrm{C}_{RR}\\) matrices are symmetric
        and each independant state variable is given only one. This is not the
        case for \\(\\mathrm{C}_{AR}\\), since
        \\[
            \\mathrm{C}_{AR}^{JK} = \\mathrm{Cov}[A_J, R_K] \\neq 
            \\mathrm{Cov}[A_K, R_J] = \\mathrm{C}_{AR}^{KJ} 
        \\]
        in general. 
        &#34;&#34;&#34;
        return self._initial_state

    @initial_state.setter
    def initial_state(self, new_state):
        length = (p := len(self.network.populations)) * (2*p + 3)
        if len(new_state) != length:
            raise ValueError(f&#39;The state provided has {len(new_state)} &#39;
                             f&#39;components, but it should have {length} &#39;
                             f&#39;components for a network of {p} populations.&#39;)
        self._initial_state = np.array(new_state, float)

    @property
    def Q(self):
        &#34;&#34;&#34;Input in the network.

        Input in the populations of the network from an external source. It must
        have the same length as the number of populations of the network. The
        setter method ensures that the input is always of the correct length,
        and that it is always a NumPy array of floats. 
        &#34;&#34;&#34;
        return self._Q

    @Q.setter
    def Q(self, new_Q):
        try:
            float_new_Q = float(new_Q)
        except:
            pass
        else:
            new_Q = [float_new_Q]
        if len(new_Q) != (p := len(self.network.populations)):
            raise PopNetError(f&#39;The input Q should always have {p} components &#39;
                              f&#39;for a network of {p} populations.&#39;)
        self._Q = np.array(new_Q, float)

    @property
    def initial_time(self):
        &#34;&#34;&#34;Time from which the network&#39;s state is studied.

        Start of the period in which the evolution of the network&#39;s state is
        studied. When setting the initial time, the time interval
        `Configuration.delta` is adapted to ensure that the number of iterations
        and the time interval are still consistent with the total duration of
        the integration.
        &#34;&#34;&#34;
        return self._initial_time

    @initial_time.setter
    def initial_time(self, new_initial_time):
        self._initial_time = float(new_initial_time)
        self._delta = (self.final_time - self.initial_time) / self.iterations

    @property
    def final_time(self):
        &#34;&#34;&#34;Time until which the network&#39;s state is studied.

        End of the period in which the evolution of the network&#39;s state is
        studied. When setting the final time, the time interval
        `Configuration.delta` is adapted to ensure that the number of iterations
        and the time interval are still consistent with the total duration of
        the integration.
        &#34;&#34;&#34;
        return self._final_time

    @final_time.setter
    def final_time(self, new_final_time):
        self._final_time = float(new_final_time)
        self._delta = (self.final_time - self.initial_time) / self.iterations

    @property
    def delta(self):
        &#34;&#34;&#34;Time interval between two iterations in the numerical integration.
        
        Time interval between two consecutive iterations in a numerical
        integration performed using this configuration. This is not used for
        simulations of the microscopic network&#39;s dynamics. When setting the time
        interval, the number of iterations `Configuration.iterations` is adapted
        to ensure that the number of iterations and the time interval are still
        consistent with the total length of time of the integration.
        &#34;&#34;&#34;
        return self._delta

    @delta.setter
    def delta(self, new_delta):
        self._delta = float(new_delta)
        self._iterations = round((self.final_time - self.initial_time) 
                                 / self.delta)

    @property
    def iterations(self):
        &#34;&#34;&#34;Number of iterations of the numerical integration.

        Total number of iterations of a numerical integration performed using
        this configuration. It is also the number of time steps added after the
        initial time to get the times array when doing statistics from
        simulations of the network&#39;s microscopic dynamics. In both cases, the
        length of the times array is `1 + iterations`. This is not used when
        only one simulation of the microscopic dynamics is performed.

        When setting the number of iterations, the time interval
        `Configuration.delta` will be adapted to ensure that the number of
        iterations and the time interval are still consistent with the total
        length of time of the integration. 
        &#34;&#34;&#34;
        return self._iterations

    @iterations.setter
    def iterations(self, new_number_of_iterations):
        self._iterations = int(new_number_of_iterations)
        self._delta = (self.final_time - self.initial_time) / self.iterations

    def add_random_uniform_perturbation(self, R, axes=None):
        &#34;&#34;&#34;Add a random perturbation to the initial state.

        Add a random perturbation to the initial state, taken from a uniform
        distribution on an *N*--sphere of radius `R`. The dimension *N* is the
        number of components perturbated as given by `axes`. 

        Parameters
        ----------
        R : float
            Norm of the perturbation. Corresponds to the radius of the
            *N*--sphere in which the perturbation is randomly taken.
        axes : list or tuple of ints, optional
            Axes to change in the initial state. Defaults to `None`, in which
            case every component is changed. 

        Notes
        -----
        To generate a uniform distribution on an *N*--sphere of radius `R`, we
        use the method described in [1]: every component of the perturbation is
        first taken from a standard normal distribution, and then the resulting
        vector is scaled to have a norm of `R`.

        References
        ----------
         1. Muller, M. E. “A note on a method for generating points uniformly on
            *N*-dimensional spheres.” *Commun. ACM* **2**, 19--20 (1959).
            doi:[10.1145/377939.377946](https://doi.org/10.1145/377939.377946).
        &#34;&#34;&#34;
        if axes is None:
            axes = np.arange(len(self.initial_state))
        ball = np.random.default_rng().normal(size=len(axes))
        ball = R * ball / np.linalg.norm(ball)
        perturbation = np.zeros(len(self.initial_state))
        perturbation[np.array(axes)] = ball
        self.initial_state = self.initial_state + perturbation

    def add_to_initial_state(self, perturbation):
        &#34;&#34;&#34;Add a given perturbation to the initial state.&#34;&#34;&#34;
        if perturbation is None:
            return 
        self.initial_state = self.initial_state + np.array(perturbation, float)

    def copy(self, new_ID):
        &#34;&#34;&#34;Copy the configuration.

        Return a copy of the configuration with a new ID.

        Parameters
        ----------
        new_ID : str
            ID to give to the new configuration.

        Returns
        -------
        Configuration
            The copied configuration.
        &#34;&#34;&#34;
        new_config = deepcopy(self)
        new_config.ID = new_ID
        return new_config

    def microscopized(self, sizes, new_ID=None):
        &#34;&#34;&#34;Get a microscopic version of the configuration.

        Return a copy of the configuration, but with a microscopic structure
        where population sizes are given by `sizes`.

        Parameters
        ----------
        sizes : list or tuple of int
            Sizes to give to the populations of the network, in the same order
            as in the network&#39;s attribute.
        new_ID : str
            ID to give to the new configuration. Defaults to `None`, in which
            case the configuration&#39;s ID is used.
        &#34;&#34;&#34;
        if new_ID is None:
            new_ID = self.ID
        net = self.network.copy(self.network.ID)
        for pop, size in zip(net.populations, sizes):
            pop.size = size
        try:
            net = net.underlying()
        except AttributeError:
            pass
        configuration = config(net, ID=new_ID)
        for param, value in self.__dict__.items():
            if param in (&#39;_network&#39;, &#39;_ID&#39;):
                continue
            setattr(configuration, param, value)
        configuration.reset_micro_initial_state()
        return configuration

    def save(self, save_network=True, folder=None, note=None):
        &#34;&#34;&#34;Save the current configuration.

        Save the string representation of the configuration in a text file,
        under the name *ID - Configuration.txt*, where *ID* is the actual ID of
        the configuration.

        Parameters
        ----------
        save_network : bool, optional
            Decides if the network parameters are saved as well in the same
            folder, using `Network.save`. Defaults to `True`.
        folder : str, optional
            A folder in which the file is saved. If it does not exist in the
            current directory, it is created. Defaults to `None`, in which case
            the file is saved in the current directory.
        note : str, optional
            If not `None`, an additional section &#34;Additional notes:&#34; is written
            in the file, and `note` is written there. 
        &#34;&#34;&#34;
        if save_network:
            self.network.save(folder=folder)
        filename = _internals._format_filename(folder, self.ID, &#39;Configuration&#39;)
        _internals._make_sure_folder_exists(folder)
        with open(filename, &#39;w&#39;, encoding=&#39;utf-8&#39;) as file:
            file.write(str(self))
            if note is not None:
                file.write(&#39;\n\nAdditional notes:\n&#39;)
                file.write(note)

    def set_initial_state_from(self, other):
        &#34;&#34;&#34;Set the initial state from another configuration.

        Set the initial state from another configuration, where the network can
        have another number of populations.
            - If the other configuration has *less* populations, only the state
              components associated with the first populations will be set.
            - If the other configuration has the *same* number of populations,
              the initial state will simply be copied.
            - If the other configuration has *more* populations, the initial
              state will be set according to the first populations of the
              other configuration.

        Parameters
        ----------
        other : Configuration
            Other configuration from which to take the initial state.

        Raises
        ------
        TypeError
            If `other` is not a `Configuration` instance.
        &#34;&#34;&#34;
        if not isinstance(other, Configuration):
            raise TypeError(&#39;The initial state can only be copied from another &#39;
                            &#39;\&#39;Configuration\&#39; instance.&#39;)
        sp = len(self.network.populations)
        op = len(other.network.populations)
        if op == sp:
            self.initial_state = other.initial_state
            return
        mp = min(sp, op)
        self.initial_state[:mp] = other.initial_state[:mp]
        self.initial_state[sp:sp+mp] = other.initial_state[op:op+mp]
        def loop(start, step):
            sn, on = start(sp), start(op)
            for j in range(mp):
                self.initial_state[sn : sn + step(mp,j)] = \
                    other.initial_state[on : on + step(mp,j)]
                sn, on = sn + step(sp, j), on + step(op, j)
        loop(lambda p: 2*p, lambda p,j: p - j)                    # CAA
        loop(lambda p: 2*p + round(p*(p+1)/2), lambda p,j: p - j) # CRR
        loop(lambda p: 2*p + p*(p+1), lambda p,j: p)              # CAR

    def set_random_initial_state(self, bound_cov=0.06):
        &#34;&#34;&#34;Set the initial state with random values.

        Set the initial state with random values. For each population, the
        values for *A* and *R* and chosen from uniform distributions in the
        triangle \\(\\{(x,y) \\in [0,1)^2 : x + y &lt; 1\\}\\), using the method
        described in [1]. All variances are chosen from uniform distributions
        between 0 and `bound_cov`, and all non-symmetric covariances from
        uniform distributions between `-bound_cov` and `bound_cov`, regardless
        of the values of the expectations. 

        Parameters
        ----------
        bound_cov : float, optional
            Positive number which sets the distributions of covariances.
            Variances are all taken from a uniform distribution between zero and
            `bound_cov`, and non-symmetric covariances are taken from a uniform
            distribution between `-bound_cov` and `bound_cov`. Defaults to 0.06.

        Raises
        ------
        TypeError
            If `bound_cov` cannot be converted to a float.
        ValueError
            If `bound_cov` is not a positive number.

        References
        ----------
         1. Osada, R., Funkhouser, T., Chazelle, B. &amp; Dobkin, D. “Shape
            distributions.” *ACM Trans. Graph.* **21**, 807--832 (2002).
            doi:[10.1145/571647.571648](https://doi.org/10.1145/571647.571648).
        &#34;&#34;&#34;
        p = len(self.network.populations)
        state = np.zeros(p*(2*p+3))
        rng = np.random.default_rng()
        try:
            bound_cov = float(bound_cov)
        except TypeError as error:
            raise TypeError(&#39;The bound to choose covariances should be a &#39;
                            &#39;number.&#39;) from error
        if bound_cov &lt; 0:
            raise ValueError(&#39;The bound to choose covariances should be &#39;
                             &#39;positive.&#39;)
        for J in range(p):
            a, b = rng.random(size=2)
            state[J] = np.sqrt(a) * (1 - b)
            state[p+J] = np.sqrt(a) * b
        state[2*p : p*(p+3)] = bound_cov * rng.random(size=p*(p+1))
        state[p*(p+3) :] = -bound_cov + 2*bound_cov * rng.random(size=p**2)
        self.initial_state = state

    def _other_params_string(self):
        &#34;&#34;&#34;Optional parameters for subclasses to write in `str(self)`.&#34;&#34;&#34;
        pass


class MicroConfiguration(Configuration):
    &#34;&#34;&#34;Configurations used in numerical simulations.

    The `MicroConfiguration` class extends the `Configuration` class to cases
    where the microscopic structure of the network is needed to perform
    numerical simulations. It adds two new properties:

     - `MicroConfiguration.micro_initial_state`, which gives the network&#39;s
       microscopic initial state;
     - `MicroConfiguration.executions`, which gives the number of trajectories
       generated when performing simulations in chain.

    It also provides a method to reset it from the macroscopic initial state,
    and another to modify the sizes of the populations of the network while also
    updating the network&#39;s parameters and the microscopic initial state.

    Since this configuration class requires the network to have a microscopic
    structure, it has to be initialized from a `MicroNetwork` instance. Besides
    that, the initialization is the same as in the base class.

    The data attributes are the same as in the base class.

    Raises
    ------
    popnet.exceptions.PopNetError
        If the network used is not a `MicroNetwork`.

    &#34;&#34;&#34;

    def __init__(self, network, ID=None, **kwargs):
        if &#39;executions&#39; in kwargs:
            self.executions = kwargs.pop(&#39;executions&#39;)
        else:
            self.executions = 1
        super().__init__(network, ID=ID, **kwargs)
        if not isinstance(network, MicroNetwork):
            raise PopNetError(&#39;The network used with a \&#39;MicroConfiguration\&#39; &#39;
                              &#39;should be a \&#39;MicroNetwork\&#39;.&#39;)

    @Configuration.initial_state.setter
    def initial_state(self, new_state):
        Configuration.initial_state.fset(self, new_state)
        self.reset_micro_initial_state()

    @property
    def micro_initial_state(self):
        &#34;&#34;&#34;Microscopic initial state of the network.

        States of all neurons of the network. It is always consistent with the
        macrosopic initial state `Configuration.initial_state`, in the sense
        that the microscopic initial state can only be set from macroscopic one.
        For more details on this process, see
        `MicroConfiguration.reset_micro_initial_state`.

        The microscopic initial state cannot be set manually, but it can be
        reset at any time with `MicroConfiguration.reset_micro_initial_state`.
        Note also that when the macroscopic initial state is changed, the
        microscopic one is also reset.
        &#34;&#34;&#34;
        return self._micro_initial_state

    @property
    def executions(self):
        &#34;&#34;&#34;Number of simulations to be done.

        Number of simulations to be performed when doing simulations in chain
        to obtain statistics. It cannot be deleted.
        &#34;&#34;&#34;
        return self._executions

    @executions.setter
    def executions(self, new_number):
        try:
            new_number = int(new_number)
        except TypeError as error:
            raise TypeError(&#39;The number of simulations to be done should be &#39;
                            &#39;a number.&#39;) from error
        if new_number &lt; 0:
            raise ValueError(&#39;The number of simulations to be done has to be &#39;
                             &#39;positive.&#39;)
        self._executions = new_number

    def microscopized(self, sizes, new_ID=None):
        &#34;&#34;&#34;Get a resized microscopic copy of the configuration.

        Return a copy of the configuration where population sizes are given by
        `sizes`.

        Parameters
        ----------
        sizes : list or tuple of int
            Sizes to give to the populations of the network, in the same order
            as in the network&#39;s attribute.
        new_ID : str
            ID to give to the new configuration. Defaults to `None`, in which
            case the configuration&#39;s ID is used.
        &#34;&#34;&#34;
        if new_ID is None:
            new_ID = self.ID
        micro_config = self.copy(new_ID)
        micro_config.resize_network(sizes)
        return micro_config

    def resize_network(self, new_sizes):
        &#34;&#34;&#34;Change the sizes of the network&#39;s populations.

        Change the size of each population of the network, and reset the
        network&#39;s parameters and the microscopic initial state to be consistent
        with this change.

        Parameters
        ----------
        new_sizes : list or tuple of int
            A new size for each population, given in the order prescribed by
            the network&#39;s list of populations.
        &#34;&#34;&#34;
        for pop, new_size in zip(self.network.populations, new_sizes):
            pop.size = new_size
        self.network.reset_parameters()
        self.reset_micro_initial_state()
        
    def reset_micro_initial_state(self):
        &#34;&#34;&#34;Randomly generate a microscopic initial state.
        
        Create a microscopic initial state for the network, consistent with its
        macroscopic initial state. If *J* is a population of the network, each
        neuron of *J* is chosen randomly between the values `1` (active), `1j`
        (refractory) and `0` (sensitive), with probabilities corresponding to
        the active, refractory and sensitive fractions of *J*.
        &#34;&#34;&#34;
        A = self.initial_state[: (p := len(self.network.populations))]
        R = self.initial_state[p : 2*p]
        S = 1 - A - R
        rng = np.random.default_rng()
        self._micro_initial_state = np.concatenate(
                [rng.choice((0.,1.,1j), p=(S[J],A[J],R[J]), size=popJ.size)
                 for J, popJ in enumerate(self.network.populations)])

    def _other_params_string(self):
        &#34;&#34;&#34;Add `executions` to `str(self)`.&#34;&#34;&#34;
        if self.executions == 1:
            return f&#39;{1:&gt;9} execution\n&#39;
        else:
            return f&#39;{self.executions:&gt;9} executions\n&#39;


class ConfigurationOne(Configuration):
    &#34;&#34;&#34;Extends `Configuration` in the special case of a single population.

    Extends the `Configuration` class by adding methods specific to the case of 
    only one population. The new methods allow to:

     - Verify if a state is in the domain where variables make sense,
       physiologically speaking;
     - Set the initial state randomly in the physiological domain;
     - Set the input and the initial state to coordinates where there is a fixed
       point.

    The initialization is the same as in the base class, except for a
    verification that the network has indeed a single population.

    The data attributes are the same as in the base class.

    Raises
    ------
    popnet.exceptions.PopNetError
        If the network does not have precisely one population.

    &#34;&#34;&#34;

    def __init__(self, network, ID=None, **kwargs):
        super().__init__(network, ID=ID, **kwargs)
        if network.ID[0] != &#39;1&#39;:
            raise PopNetError(&#39;The subclass ConfigurationOne should be used &#39;
                              &#39;only for configurations where the network has &#39;
                              &#39;indeed one population. The network used here &#39;
                              f&#39;has {network.ID[0]}&#39;)
        self._variables = [&#39;A&#39;, &#39;R&#39;, &#39;CAA&#39;, &#39;CRR&#39;, &#39;CAR&#39;]

    def set_random_initial_state(self, domain=&#39;physiological&#39;, bound_cov=0.06):
        &#34;&#34;&#34;Set the initial state randomly.

        Overrides the corresponding base class method to choose an initial state
        in a given domain. The expectations are always chosen from a uniform
        distribution in the triangle \\(\\{(x,y) \\in [0,1)^2 : x + y &lt; 1\\}\\).

        Parameters
        ----------
        domain : {&#39;physiological&#39;, &#39;bounded&#39;}, optional
            The domain in which the state is chosen. If &#39;physiological&#39;, the
            state is chosen in the so-called physiological domain, where
            expectations and covariances are valid values for the random
            variables they represent. If &#39;bounded&#39;, the base class method is
            called. Defaults to `&#39;physiological&#39;`.
        bound_cov : float, optional
            Positive number which sets the distributions of covariances, in the
            case where `domain` is set to `&#39;bounded&#39;`. See the base class method
            for details. Defaults to 0.06.

        Raises
        ------
        NotImplementedError
            If the requested domain is not valid. 

        See Also
        --------
        Configuration.set_random_initial_state
        &#34;&#34;&#34;
        rng = np.random.default_rng()
        if domain == &#39;physiological&#39;:
            a, b = rng.random(size=2)
            A = np.sqrt(a) * (1 - b)
            R = np.sqrt(a) * b
            CAA = A * (1 - A) * rng.random()
            CRR = R * (1 - R) * rng.random()
            CAR = -np.sqrt(CAA*CRR) + 2*np.sqrt(CAA*CRR) * rng.random()
            new_state = [A, R, CAA, CRR, CAR]
            if self.state_in_domain(new_state, verbose=False):
                self.initial_state = new_state
            else:
                self.set_random_initial_state()
            return
        elif domain == &#39;bounded&#39;:
            super().set_random_initial_state(bound_cov=bound_cov)
            return
        raise NotImplementedError(f&#39;No &#34;{domain}&#34; domain has been implemented &#39;
                                  &#39;yet for the states of a network with a &#39;
                                  &#39;single population.&#39;)

    def set_to_fixed_point(self, form, set_state=True):
        &#34;&#34;&#34;Set the initial state at a fixed point of the extended system.

        Set the input and (possibly) the initial state to coordinates where
        there is a fixed point of form *i*), *ii*) or *iii*) of the extended
        Wilson--Cowan system obtained from the closure that uses a second-order
        Taylor approximation. It is possible to set only the input and not the
        intial state with the `set_state` argument.

        Parameters
        ----------
        form : {&#39;i&#39;, &#39;ii&#39;, &#39;iii&#39;}
            The desired form of fixed point.
        set_state : bool, optional
            Decides if the initial state is set to or near the fixed point.
            Defaults to `True`.

        Raises
        ------
        NotImplementedError
            If `form` is `&#39;i&#39;`. 
        ValueError
            If `form` is neither of `&#39;i&#39;`, `&#39;ii&#39;` or `&#39;iii&#39;`.
        &#34;&#34;&#34;
        pop = self.network.populations[0]
        c = self.network.c[0,0]
        Sigma = pop.alpha/2 + pop.beta + pop.gamma
        Pi = pop.alpha*pop.beta/2 + pop.alpha*pop.gamma/2 + pop.beta*pop.gamma
        if form == &#39;i&#39;:
            raise NotImplementedError(&#39;The coordinates for a form i) fixed &#39;
                                      &#39;point have not been implemented yet.&#39;)
        elif form == &#39;ii&#39;:
            S = 4 * pop.scale_theta * Sigma / (pop.alpha * c)
            A = pop.gamma / (pop.beta + pop.gamma) * (1 - S)
            R = pop.beta  / (pop.beta + pop.gamma) * (1 - S)
            CAR = (2*pop.gamma / (pop.beta+pop.gamma) * (Sigma * Pi - pop.beta
                    * pop.gamma * pop.alpha * c / (4*pop.scale_theta))
                    / ( (pop.alpha + 2*pop.gamma) * 
                        (pop.alpha * c / (4*pop.scale_theta))**2 ))
            CAA = pop.alpha / (2*pop.gamma) * CAR
            CRR = pop.beta / pop.gamma * CAR
            self.Q = pop.theta - c * A
        elif form == &#39;iii&#39;:
            S = 4 * pop.scale_theta * Pi / (pop.gamma * pop.alpha * c)
            A = pop.gamma / (pop.beta + pop.gamma) * (1 - S)
            R = pop.beta  / (pop.beta + pop.gamma) * (1 - S)
            CAR = (pop.beta / pop.gamma * ( Pi**2 - pop.beta*pop.gamma**2
                    * pop.alpha * c / (4*pop.scale_theta) )
                    / ( (pop.beta+pop.gamma)**2 
                        * (pop.alpha * c / (4*pop.scale_theta))**2 ))
            CAA = pop.gamma / pop.beta * CAR
            CRR = pop.beta / pop.gamma * CAR
            self.Q = pop.theta - c * A
        else:
            raise ValueError(&#39;Unknown fixed point form.&#39;)
        if set_state:
            self.initial_state = [A, R, CAA, CRR, CAR]

    def state_in_domain(self, state=None, verbose=False):
        &#34;&#34;&#34;Verify if a state is in the physiological domain.

        Parameters
        ----------
        state : array_like, optional
            The state to verify. Defaults to `None`, in which case the initial
            state is verified.
        verbose : bool, optional
            If `True`, a warning will be issued if the state is not in the
            physiological domain. Defaults to `False`.

        Returns
        -------
        bool
            `True` if the state is in the physiological domain, else `False`.

        Warns
        -----
        popnet.exceptions.PopNetWarning
            If `verbose` is `True` and if the state is not in the physiological
            domain.
        &#34;&#34;&#34;
        if state is None:
            state = self.initial_state
        A = state[0]
        R = state[1]
        S = 1 - A - R
        CAA = state[2]
        CRR = state[3]
        CAR = state[4]
        CSS = CAA + 2*CAR + CRR
        if A &lt; 0 or R &lt; 0 or S &lt; 0:
            ok = False
        elif CAA &gt; A * (1 - A) or CAA &lt; 0:
            ok = False
        elif CRR &gt; R * (1 - R) or CRR &lt; 0:
            ok = False
        elif CSS &gt; S * (1 - S) or CSS &lt; 0:
            ok = False
        elif CAR**2 &gt; CAA * CRR:
            ok = False
        elif CAR &lt; -A*R:
            ok = False
        elif CAR &gt; A*S - CAA:
            ok = False
        elif CAR &gt; R*S - CRR:
            ok = False
        else:
            ok = True
        if not ok and verbose:
            warn(f&#39;The state {state} does not make sense, physiologically &#39;
                 &#39;speaking.&#39;, category=PopNetWarning, stacklevel=2)
        return ok


class MicroConfigurationOne(ConfigurationOne, MicroConfiguration):
    &#34;&#34;&#34;Extends `MicroConfiguration` in the special case of a single population.

    Combines the features of `ConfigurationOne` and `MicroConfiguration` in
    order to be used for cases where the microscopic structure of a network
    containing a single population is needed.

    &#34;&#34;&#34;

    pass


def build_network(ID, matrix):
    &#34;&#34;&#34;Get a network from a weight matrix.

    Get a network with a weight matrix given by `matrix`.

    Parameters
    ----------
    ID : str
        ID given to the network.
    matrix : array_like
        Weight matrix specifying the connections between neurons in the network.
        It has to be square and to have real entries.

    Returns
    -------
    MicroNetwork
        Network initialized with weight matrix corresponding to `matrix`.
    &#34;&#34;&#34;
    N = matrix.shape[0]
    if matrix.shape != (N, N):
        raise ValueError(&#39;The given matrix should be square.&#39;)
    net = default_network(ID, scale=&#39;micro&#39;)
    net.c = N * np.mean(matrix)
    net.W = matrix
    return net


def default_config(ID, scale=&#39;macro&#39;):
    &#34;&#34;&#34;Define a configuration with default parameters.

    Define a new configuration with default parameters and a given ID. The
    network associated with this configuration will be defined with
    `default_network`, using the same `scale`.

    Parameters
    ----------
    ID : str
        ID given to the new configuration. Its first character should be a
        positive integer, which is taken to be the number of populations.
    scale : {&#39;macro&#39;, &#39;micro&#39;}, optional
        Determine whether the new network has a defined microscopic structure.
        If `&#39;micro&#39;`, a default size of 100 neurons will be given to each
        population. If `&#39;macro&#39;`, population sizes will remain undefined.

    Returns
    -------
    Configuration, MicroConfiguration, ConfigurationOne or MicroConfigurationOne
        The configuration with default parameters. It will be a subclass of
        `Configuration` if it is more appropriate according to `scale` and to
        the number of populations of the network.
    &#34;&#34;&#34;
    net = default_network(ID, scale=scale)
    return config(net, ID)


def default_network(ID, scale=&#39;macro&#39;):
    &#34;&#34;&#34;Define a network with default parameters.
    
    Define a new network with default parameters and a given ID.

    Parameters
    ----------
    ID : str
        ID given to the new network. Its first character should be a positive
        integer, which is taken to be the number of populations.
    scale : {&#39;macro&#39;, &#39;micro&#39;}, optional
        Determine whether the network has a defined microscopic structure. If
        `&#39;micro&#39;`, a default size of 100 neurons will be given to each
        population. If `&#39;macro&#39;`, population sizes will remain undefined.

    Returns
    -------
    Network or MicroNetwork
        The network with default parameters. It will be a `MicroNetwork`
        instance if the sizes of the populations are defined.

    Raises
    ------
    popnet.exceptions.PopNetError
        If a non-valid value is passed to `scale`.
    &#34;&#34;&#34;
    p = int(ID[0])
    if p == 1:
        pops = [Population(&#39;Population&#39;)]
    else:
        pops = [Population(f&#39;Population {j+1}&#39;, ID=str(j+1)) for j in range(p)]
    if scale == &#39;macro&#39;:
        return Network(ID, pops)
    elif scale == &#39;micro&#39;:
        for pop in pops:
            pop.size = 100
        return MicroNetwork(ID, pops)
    raise PopNetError(f&#39;Unknown scale {scale} to create a network.&#39;)


def load_config(load_ID, new_ID=None, network=None, folder=None):
    &#34;&#34;&#34;Load a configuration from a text file.

    Load the configuration parameters from a text file. This text file is
    expected to be named *ID - Configuration.txt* (with *ID* replaced with
    the configuration&#39;s actual ID). When reading it as a single string, it
    is also expected to have the format of a string representation of a
    `Configuration` instance. Note that this is the format of text file saved
    by `Configuration.save`.

    Parameters
    ----------
    load_ID : str
        ID of the configuration to load. 
    new_ID : str, optional
        ID of the configuration to create with the parameters of `load_ID`.
        Defaults to `None`, in which case `load_ID` is used. 
    network : Network, optional
        The network to associate with the configuration. Defaults to `None`,
        in which case a new `Network` instance is created with `load_network`.
    folder : str, optional
        Folder in which the text file is located. If given, if should be in
        the current directory. Defaults to `None`, in which case the text
        file is expected to be in the current directory.

    Returns
    -------
    Configuration
        The loaded configuration with ID `new_ID`. It will be a subclass of
        `Configuration` if it is more appropriate according to the number of
        populations of the network and to their sizes.

    Raises
    ------
    FileNotFoundError
        If no file is found with the expected name.
    popnet.exceptions.PopNetError
        If the file contains inconsistent information or unexpected
        parameters to set.
    popnet.exceptions.FormatError
        If the file does not have the expected format.

    Warns
    -----
    popnet.exceptions.PopNetWarning
        If the information in the file is inconsistent.
    &#34;&#34;&#34;
    filename = _internals._format_filename(folder, load_ID, &#39;Configuration&#39;)
    if new_ID is None:
        new_ID = load_ID
    try:
        with open(filename, &#39;r&#39;, encoding=&#39;utf-8&#39;) as file:
            lines = file.readlines()
    except FileNotFoundError as error:
        raise FileNotFoundError(&#39;No file is available to load configuration &#39;
                                f&#39;{load_ID}. Maybe the configuration has not &#39;
                                &#39;been saved, or maybe the file containing the &#39;
                                &#39;data does not have the expected name. It &#39;
                                &#39;should have the format ID - Configuration.txt.&#39;
                                ) from error
    loaded_config = _read_config_file(load_ID, new_ID, network, folder, lines)
    if loaded_config is None:
        raise FormatError(f&#39;It seems that the file {load_ID} - Configuration.txt&#39;
                          &#39; does not have the correct format to import the conf&#39;
                          f&#39;iguration {load_ID}. It should have the format of a&#39;
                          &#39; string representation of a Configuration instance.&#39;)
    return loaded_config


def load_network(load_ID, new_ID=None, folder=None):
    &#34;&#34;&#34;Load a network from a text file.

    Define a new network from parameters in a text file. This file is expected
    to be named *ID - Network parameters.txt* where *ID* is the network&#39;s
    actual ID. If the file is read as a single string, it is expected to have
    the format of a string representation of a `Network` instance. Note that
    this is the format of text file saved by `Network.save`.

    Parameters
    ----------
    load_ID : str
        ID of the network to load. 
    new_ID : str, optional
        ID of the network to define. Defaults to `None`, in which case
        `load_ID` is used. 
    folder : str, optional
        Folder in which the text file is located. If given, if should be in
        the current directory. Defaults to `None`, in which case the text
        file is expected to be in the current directory.

    Returns
    -------
    Network or MicroNetwork
        The loaded network. It will be a `MicroNetwork` if a size is given for
        every population.

    Raises
    ------
    FileNotFoundError
        If no file is found with the expected name.
    popnet.exceptions.PopNetError
        If the information in the file is not consistent with `load_ID`.
    popnet.exceptions.FormatError
        If the file does not have the expected format.
    &#34;&#34;&#34;
    filename = _internals._format_filename(folder, load_ID, &#39;Network parameters&#39;)
    if new_ID is None:
        new_ID = load_ID
    try:
        with open(filename, &#39;r&#39;, encoding=&#39;utf-8&#39;) as file:
            lines = file.readlines()
    except FileNotFoundError as error:
        raise FileNotFoundError(f&#39;No file is available to load network {load_ID}&#39;
                                &#39;. Maybe no parameters have been saved, or maybe&#39;
                                &#39; the file containing the data does not have the&#39;
                                f&#39; expected name. It should be {load_ID} - &#39;
                                &#39;Network parameters.txt.&#39;) from error
    if load_ID != (other_ID := lines[0].strip().split()[-1]):
        raise PopNetError(f&#39;The file {load_ID} - Network parameters.txt seems &#39;
                          f&#39;to contain information about a network {other_ID} &#39;
                          f&#39;rather than {load_ID}; PopNet is confused.&#39;)
    j = 2
    populations = []
    while j &lt; len(lines):
        if lines[j].startswith(&#39;Connection matrix&#39;):
            break
        # At index j+1 a population&#39;s description starts. We loop until the
        # end of the description, that is, when an empty line is reached.
        k = j + 1
        while lines[k] != &#39;\n&#39;:
            k += 1
        populations.append(Population._load(lines[j : k]))
        j = k + 1
    else:
        raise FormatError(f&#39;It seems that the file {load_ID} - Network param&#39;
                          &#39;eters.txt does not have the correct format to import&#39;
                          f&#39; the network {load_ID}. It should have the format &#39;
                          &#39;of a string representation of a Network instance.&#39;)
    if any(pop.size is None for pop in populations):
        net = Network(new_ID, populations)
    else:
        net = MicroNetwork(new_ID, populations)
    # Set the connection matrix from the file&#39;s data.
    string = &#39;&#39;.join(lines[j+1 : j+1+len(net.populations)])
    net._set_c_from_string(string)
    if isinstance(net, MicroNetwork):
        net.reset_parameters()
    return net


def config(network, ID=None, **kwargs):
    &#34;&#34;&#34;Define a configuration from a given network.

    Define a new configuration using the most appropriate class constructor
    according to the number of populations of the network and to the type of
    the network.

    Parameters
    ----------
    network : Network
        The network used with this configuration.
    ID : str, optional
        The ID to associate with the configuration. The default is to take the
        network&#39;s ID.
    **kwargs
        Keyword arguments to be passed to the class constructor.

    Returns
    -------
    Configuration, MicroConfiguration, ConfigurationOne or MicroConfigurationOne
        A configuration initialized with the given ID and network. It will be a
        subclass of `Configuration` if it is more appropriate according to the
        number of populations of the network and to their sizes.
    &#34;&#34;&#34;
    if ID is None:
        ID = network.ID
    if isinstance(network, MicroNetwork) and ID[0] == &#39;1&#39;:
        return MicroConfigurationOne(network, ID=ID, **kwargs)
    if isinstance(network, MicroNetwork):
        return MicroConfiguration(network, ID=ID, **kwargs)
    if ID[0] == &#39;1&#39;:
        return ConfigurationOne(network, ID=ID, **kwargs)
    return Configuration(network, ID=ID, **kwargs)


def network(ID, populations):
    &#34;&#34;&#34;Define a network from given populations.

    Define a `Network` instance from already defined populations. If all
    populations have a defined size, the network will rather be a `MicroNetwork`
    instance.

    Parameters
    ----------
    ID : str
        ID given to the network.
    populations : tuple of Population or Population
        Populations that define the network.

    Returns
    -------
    Network or MicroNetwork
        The network composed of the populations listed in `populations`.

    Raises
    ------
    TypeError
        If `populations` cannot be converted into a tuple of `Population`
        instances.
    &#34;&#34;&#34;
    net = Network(ID, populations)
    try:
        net = net.underlying()
    except PopNetError:
        pass
    return net


def population(name, ID=None, size=None):
    &#34;&#34;&#34;Define a population of biological neurons.

    Define a `Population` instance with a given name, possibly with a
    microscopic structure.

    Parameters
    ----------
    name : str
        Name of the population.
    ID : str, optional
        ID of the population. It must be a single character. If not given, the
        last character of `name` is used if it is a number, else the first one
        is used.
    size : int, optional
        Number of neurons of the population. It must be positive. Defaults to
        `None`, in which case no size is defined for the population.

    Returns
    -------
    Population
        The population initialized with the given name, ID and size.
    &#34;&#34;&#34;
    pop = Population(name, ID=ID, size=size)
    return pop


def _read_config_file(load_ID, new_ID, network, folder, lines):
    &#34;&#34;&#34;Read a configuration file given as a list of lines.

    If the file does not have the expected format, return `None`. Else, return
    loaded configuration. See `popnet.load_config` for details.
    &#34;&#34;&#34;
    if not lines[0].startswith(&#39;Configuration&#39;):
        return None
    if load_ID != (other_ID := lines[0].strip().split()[-1]):
        raise PopNetError(f&#39;The file {load_ID} - Configuration.txt seems to cont&#39;
                          f&#39;ain the information about a configuration {other_ID}&#39;
                          f&#39; rather than {load_ID}; PopNet is confused.&#39;)
    if not lines[2].startswith(&#39;Network&#39;):
        return None
    # If no network was given, load it from the ID given in the file.
    if network is None:
        network_ID = lines[2].strip().split()[-1]
        network = load_network(network_ID, folder=folder)
    # Define the configuration.
    configuration = config(network, ID=new_ID)
    if not lines[4].startswith(&#39;Parameters&#39;):
        return None
    # Load parameters. 
    params = {&#39;initial_time&#39;: None, &#39;final_time&#39;: None, 
              &#39;iterations&#39;: None, &#39;delta&#39;: None, &#39;executions&#39;: None}
    for j in range(5, len(lines)):
        if lines[j].startswith(&#39;Input&#39;):
            break
        words = lines[j].strip().split()
        if len(words) == 0:
            continue
        elif len(words) == 2:
            param = words[1]
            val = words[0]
        elif len(words) == 3:
            param = words[0].replace(&#39;ti&#39;, &#39;initial_time&#39;)
            param = param.replace(&#39;tf&#39;, &#39;final_time&#39;)
            param = param.replace(u&#39;\u0394t&#39;, &#39;delta&#39;)
            val = words[2]
        else:
            raise FormatError(f&#39;Unexpected line {lines[j]} in saved file for &#39;
                              f&#39;configuration {load_ID}.&#39;)
        if param in params:
            params[param] = val
        elif param == &#39;execution&#39;:
            params[&#39;executions&#39;] = val
        else:
            raise PopNetError(f&#39;Unexpected parameter {param} to load with &#39;
                              f&#39;configuration {load_ID}&#39;)
    else:
        # If the loop ended without breaking, something went wrong.
        return None
    for param in params:
        if param == &#39;delta&#39; and params[&#39;iterations&#39;] is not None:
            if params[param] not in (None, str(configuration.delta)):
                warn(f&#39;The time interval given in the file {load_ID} - Configu&#39;
                     f&#39;ration.txt is {params[param]}. However, with the initial&#39;
                     f&#39; time of {configuration.initial_time}, the final time of&#39;
                     f&#39; {configuration.final_time}, and &#39;
                     f&#39;{configuration.iterations} iterations, the time interval&#39;
                     f&#39; should have been {configuration.delta}. The value given&#39;
                     &#39; in the file has been replaced by the latter.&#39;, 
                     category=PopNetWarning, stacklevel=3)
                continue
        if params[param] is not None:
            setattr(configuration, param, params[param])
    # Set the input value.
    string_Q = lines[j+1].split(&#39;=&#39;)[-1].strip()
    configuration.Q = ast.literal_eval(re.sub(r&#39;\s+&#39;, &#39;,&#39;, string_Q))
    if not lines[j+3].startswith(&#39;Initial state&#39;):
        return None
    # Set the initial state.
    state = []
    for line in lines[j+4 : j+4+len(configuration.initial_state)]:
        state.append(float(line.strip().split()[-1]))
    configuration.initial_state = state
    return configuration</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="popnet.structures.build_network"><code class="name flex">
<span>def <span class="ident">build_network</span></span>(<span>ID, matrix)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a network from a weight matrix.</p>
<p>Get a network with a weight matrix given by <code>matrix</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ID</code></strong> :&ensp;<code>str</code></dt>
<dd>ID given to the network.</dd>
<dt><strong><code>matrix</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Weight matrix specifying the connections between neurons in the network.
It has to be square and to have real entries.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="popnet.structures.MicroNetwork" href="#popnet.structures.MicroNetwork">MicroNetwork</a></code></dt>
<dd>Network initialized with weight matrix corresponding to <code>matrix</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_network(ID, matrix):
    &#34;&#34;&#34;Get a network from a weight matrix.

    Get a network with a weight matrix given by `matrix`.

    Parameters
    ----------
    ID : str
        ID given to the network.
    matrix : array_like
        Weight matrix specifying the connections between neurons in the network.
        It has to be square and to have real entries.

    Returns
    -------
    MicroNetwork
        Network initialized with weight matrix corresponding to `matrix`.
    &#34;&#34;&#34;
    N = matrix.shape[0]
    if matrix.shape != (N, N):
        raise ValueError(&#39;The given matrix should be square.&#39;)
    net = default_network(ID, scale=&#39;micro&#39;)
    net.c = N * np.mean(matrix)
    net.W = matrix
    return net</code></pre>
</details>
</dd>
<dt id="popnet.structures.config"><code class="name flex">
<span>def <span class="ident">config</span></span>(<span>network, ID=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Define a configuration from a given network.</p>
<p>Define a new configuration using the most appropriate class constructor
according to the number of populations of the network and to the type of
the network.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>network</code></strong> :&ensp;<code><a title="popnet.structures.Network" href="#popnet.structures.Network">Network</a></code></dt>
<dd>The network used with this configuration.</dd>
<dt><strong><code>ID</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The ID to associate with the configuration. The default is to take the
network's ID.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments to be passed to the class constructor.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="popnet.structures.Configuration" href="#popnet.structures.Configuration">Configuration</a>, <a title="popnet.structures.MicroConfiguration" href="#popnet.structures.MicroConfiguration">MicroConfiguration</a>, <a title="popnet.structures.ConfigurationOne" href="#popnet.structures.ConfigurationOne">ConfigurationOne</a></code> or <code><a title="popnet.structures.MicroConfigurationOne" href="#popnet.structures.MicroConfigurationOne">MicroConfigurationOne</a></code></dt>
<dd>A configuration initialized with the given ID and network. It will be a
subclass of <code><a title="popnet.structures.Configuration" href="#popnet.structures.Configuration">Configuration</a></code> if it is more appropriate according to the
number of populations of the network and to their sizes.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def config(network, ID=None, **kwargs):
    &#34;&#34;&#34;Define a configuration from a given network.

    Define a new configuration using the most appropriate class constructor
    according to the number of populations of the network and to the type of
    the network.

    Parameters
    ----------
    network : Network
        The network used with this configuration.
    ID : str, optional
        The ID to associate with the configuration. The default is to take the
        network&#39;s ID.
    **kwargs
        Keyword arguments to be passed to the class constructor.

    Returns
    -------
    Configuration, MicroConfiguration, ConfigurationOne or MicroConfigurationOne
        A configuration initialized with the given ID and network. It will be a
        subclass of `Configuration` if it is more appropriate according to the
        number of populations of the network and to their sizes.
    &#34;&#34;&#34;
    if ID is None:
        ID = network.ID
    if isinstance(network, MicroNetwork) and ID[0] == &#39;1&#39;:
        return MicroConfigurationOne(network, ID=ID, **kwargs)
    if isinstance(network, MicroNetwork):
        return MicroConfiguration(network, ID=ID, **kwargs)
    if ID[0] == &#39;1&#39;:
        return ConfigurationOne(network, ID=ID, **kwargs)
    return Configuration(network, ID=ID, **kwargs)</code></pre>
</details>
</dd>
<dt id="popnet.structures.default_config"><code class="name flex">
<span>def <span class="ident">default_config</span></span>(<span>ID, scale='macro')</span>
</code></dt>
<dd>
<div class="desc"><p>Define a configuration with default parameters.</p>
<p>Define a new configuration with default parameters and a given ID. The
network associated with this configuration will be defined with
<code><a title="popnet.structures.default_network" href="#popnet.structures.default_network">default_network()</a></code>, using the same <code>scale</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ID</code></strong> :&ensp;<code>str</code></dt>
<dd>ID given to the new configuration. Its first character should be a
positive integer, which is taken to be the number of populations.</dd>
<dt><strong><code>scale</code></strong> :&ensp;<code>{'macro', 'micro'}</code>, optional</dt>
<dd>Determine whether the new network has a defined microscopic structure.
If <code>'micro'</code>, a default size of 100 neurons will be given to each
population. If <code>'macro'</code>, population sizes will remain undefined.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="popnet.structures.Configuration" href="#popnet.structures.Configuration">Configuration</a>, <a title="popnet.structures.MicroConfiguration" href="#popnet.structures.MicroConfiguration">MicroConfiguration</a>, <a title="popnet.structures.ConfigurationOne" href="#popnet.structures.ConfigurationOne">ConfigurationOne</a></code> or <code><a title="popnet.structures.MicroConfigurationOne" href="#popnet.structures.MicroConfigurationOne">MicroConfigurationOne</a></code></dt>
<dd>The configuration with default parameters. It will be a subclass of
<code><a title="popnet.structures.Configuration" href="#popnet.structures.Configuration">Configuration</a></code> if it is more appropriate according to <code>scale</code> and to
the number of populations of the network.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def default_config(ID, scale=&#39;macro&#39;):
    &#34;&#34;&#34;Define a configuration with default parameters.

    Define a new configuration with default parameters and a given ID. The
    network associated with this configuration will be defined with
    `default_network`, using the same `scale`.

    Parameters
    ----------
    ID : str
        ID given to the new configuration. Its first character should be a
        positive integer, which is taken to be the number of populations.
    scale : {&#39;macro&#39;, &#39;micro&#39;}, optional
        Determine whether the new network has a defined microscopic structure.
        If `&#39;micro&#39;`, a default size of 100 neurons will be given to each
        population. If `&#39;macro&#39;`, population sizes will remain undefined.

    Returns
    -------
    Configuration, MicroConfiguration, ConfigurationOne or MicroConfigurationOne
        The configuration with default parameters. It will be a subclass of
        `Configuration` if it is more appropriate according to `scale` and to
        the number of populations of the network.
    &#34;&#34;&#34;
    net = default_network(ID, scale=scale)
    return config(net, ID)</code></pre>
</details>
</dd>
<dt id="popnet.structures.default_network"><code class="name flex">
<span>def <span class="ident">default_network</span></span>(<span>ID, scale='macro')</span>
</code></dt>
<dd>
<div class="desc"><p>Define a network with default parameters.</p>
<p>Define a new network with default parameters and a given ID.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ID</code></strong> :&ensp;<code>str</code></dt>
<dd>ID given to the new network. Its first character should be a positive
integer, which is taken to be the number of populations.</dd>
<dt><strong><code>scale</code></strong> :&ensp;<code>{'macro', 'micro'}</code>, optional</dt>
<dd>Determine whether the network has a defined microscopic structure. If
<code>'micro'</code>, a default size of 100 neurons will be given to each
population. If <code>'macro'</code>, population sizes will remain undefined.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="popnet.structures.Network" href="#popnet.structures.Network">Network</a></code> or <code><a title="popnet.structures.MicroNetwork" href="#popnet.structures.MicroNetwork">MicroNetwork</a></code></dt>
<dd>The network with default parameters. It will be a <code><a title="popnet.structures.MicroNetwork" href="#popnet.structures.MicroNetwork">MicroNetwork</a></code>
instance if the sizes of the populations are defined.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="popnet.exceptions.PopNetError" href="exceptions.html#popnet.exceptions.PopNetError">PopNetError</a></code></dt>
<dd>If a non-valid value is passed to <code>scale</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def default_network(ID, scale=&#39;macro&#39;):
    &#34;&#34;&#34;Define a network with default parameters.
    
    Define a new network with default parameters and a given ID.

    Parameters
    ----------
    ID : str
        ID given to the new network. Its first character should be a positive
        integer, which is taken to be the number of populations.
    scale : {&#39;macro&#39;, &#39;micro&#39;}, optional
        Determine whether the network has a defined microscopic structure. If
        `&#39;micro&#39;`, a default size of 100 neurons will be given to each
        population. If `&#39;macro&#39;`, population sizes will remain undefined.

    Returns
    -------
    Network or MicroNetwork
        The network with default parameters. It will be a `MicroNetwork`
        instance if the sizes of the populations are defined.

    Raises
    ------
    popnet.exceptions.PopNetError
        If a non-valid value is passed to `scale`.
    &#34;&#34;&#34;
    p = int(ID[0])
    if p == 1:
        pops = [Population(&#39;Population&#39;)]
    else:
        pops = [Population(f&#39;Population {j+1}&#39;, ID=str(j+1)) for j in range(p)]
    if scale == &#39;macro&#39;:
        return Network(ID, pops)
    elif scale == &#39;micro&#39;:
        for pop in pops:
            pop.size = 100
        return MicroNetwork(ID, pops)
    raise PopNetError(f&#39;Unknown scale {scale} to create a network.&#39;)</code></pre>
</details>
</dd>
<dt id="popnet.structures.load_config"><code class="name flex">
<span>def <span class="ident">load_config</span></span>(<span>load_ID, new_ID=None, network=None, folder=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Load a configuration from a text file.</p>
<p>Load the configuration parameters from a text file. This text file is
expected to be named <em>ID - Configuration.txt</em> (with <em>ID</em> replaced with
the configuration's actual ID). When reading it as a single string, it
is also expected to have the format of a string representation of a
<code><a title="popnet.structures.Configuration" href="#popnet.structures.Configuration">Configuration</a></code> instance. Note that this is the format of text file saved
by <code><a title="popnet.structures.Configuration.save" href="#popnet.structures.Configuration.save">Configuration.save()</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>load_ID</code></strong> :&ensp;<code>str</code></dt>
<dd>ID of the configuration to load.</dd>
<dt><strong><code>new_ID</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>ID of the configuration to create with the parameters of <code>load_ID</code>.
Defaults to <code>None</code>, in which case <code>load_ID</code> is used.</dd>
<dt><strong><code>network</code></strong> :&ensp;<code><a title="popnet.structures.Network" href="#popnet.structures.Network">Network</a></code>, optional</dt>
<dd>The network to associate with the configuration. Defaults to <code>None</code>,
in which case a new <code><a title="popnet.structures.Network" href="#popnet.structures.Network">Network</a></code> instance is created with <code><a title="popnet.structures.load_network" href="#popnet.structures.load_network">load_network()</a></code>.</dd>
<dt><strong><code>folder</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Folder in which the text file is located. If given, if should be in
the current directory. Defaults to <code>None</code>, in which case the text
file is expected to be in the current directory.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="popnet.structures.Configuration" href="#popnet.structures.Configuration">Configuration</a></code></dt>
<dd>The loaded configuration with ID <code>new_ID</code>. It will be a subclass of
<code><a title="popnet.structures.Configuration" href="#popnet.structures.Configuration">Configuration</a></code> if it is more appropriate according to the number of
populations of the network and to their sizes.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>FileNotFoundError</code></dt>
<dd>If no file is found with the expected name.</dd>
<dt><code><a title="popnet.exceptions.PopNetError" href="exceptions.html#popnet.exceptions.PopNetError">PopNetError</a></code></dt>
<dd>If the file contains inconsistent information or unexpected
parameters to set.</dd>
<dt><code><a title="popnet.exceptions.FormatError" href="exceptions.html#popnet.exceptions.FormatError">FormatError</a></code></dt>
<dd>If the file does not have the expected format.</dd>
</dl>
<h2 id="warns">Warns</h2>
<dl>
<dt><code><a title="popnet.exceptions.PopNetWarning" href="exceptions.html#popnet.exceptions.PopNetWarning">PopNetWarning</a></code></dt>
<dd>If the information in the file is inconsistent.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_config(load_ID, new_ID=None, network=None, folder=None):
    &#34;&#34;&#34;Load a configuration from a text file.

    Load the configuration parameters from a text file. This text file is
    expected to be named *ID - Configuration.txt* (with *ID* replaced with
    the configuration&#39;s actual ID). When reading it as a single string, it
    is also expected to have the format of a string representation of a
    `Configuration` instance. Note that this is the format of text file saved
    by `Configuration.save`.

    Parameters
    ----------
    load_ID : str
        ID of the configuration to load. 
    new_ID : str, optional
        ID of the configuration to create with the parameters of `load_ID`.
        Defaults to `None`, in which case `load_ID` is used. 
    network : Network, optional
        The network to associate with the configuration. Defaults to `None`,
        in which case a new `Network` instance is created with `load_network`.
    folder : str, optional
        Folder in which the text file is located. If given, if should be in
        the current directory. Defaults to `None`, in which case the text
        file is expected to be in the current directory.

    Returns
    -------
    Configuration
        The loaded configuration with ID `new_ID`. It will be a subclass of
        `Configuration` if it is more appropriate according to the number of
        populations of the network and to their sizes.

    Raises
    ------
    FileNotFoundError
        If no file is found with the expected name.
    popnet.exceptions.PopNetError
        If the file contains inconsistent information or unexpected
        parameters to set.
    popnet.exceptions.FormatError
        If the file does not have the expected format.

    Warns
    -----
    popnet.exceptions.PopNetWarning
        If the information in the file is inconsistent.
    &#34;&#34;&#34;
    filename = _internals._format_filename(folder, load_ID, &#39;Configuration&#39;)
    if new_ID is None:
        new_ID = load_ID
    try:
        with open(filename, &#39;r&#39;, encoding=&#39;utf-8&#39;) as file:
            lines = file.readlines()
    except FileNotFoundError as error:
        raise FileNotFoundError(&#39;No file is available to load configuration &#39;
                                f&#39;{load_ID}. Maybe the configuration has not &#39;
                                &#39;been saved, or maybe the file containing the &#39;
                                &#39;data does not have the expected name. It &#39;
                                &#39;should have the format ID - Configuration.txt.&#39;
                                ) from error
    loaded_config = _read_config_file(load_ID, new_ID, network, folder, lines)
    if loaded_config is None:
        raise FormatError(f&#39;It seems that the file {load_ID} - Configuration.txt&#39;
                          &#39; does not have the correct format to import the conf&#39;
                          f&#39;iguration {load_ID}. It should have the format of a&#39;
                          &#39; string representation of a Configuration instance.&#39;)
    return loaded_config</code></pre>
</details>
</dd>
<dt id="popnet.structures.load_network"><code class="name flex">
<span>def <span class="ident">load_network</span></span>(<span>load_ID, new_ID=None, folder=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Load a network from a text file.</p>
<p>Define a new network from parameters in a text file. This file is expected
to be named <em>ID - Network parameters.txt</em> where <em>ID</em> is the network's
actual ID. If the file is read as a single string, it is expected to have
the format of a string representation of a <code><a title="popnet.structures.Network" href="#popnet.structures.Network">Network</a></code> instance. Note that
this is the format of text file saved by <code><a title="popnet.structures.Network.save" href="#popnet.structures.Network.save">Network.save()</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>load_ID</code></strong> :&ensp;<code>str</code></dt>
<dd>ID of the network to load.</dd>
<dt><strong><code>new_ID</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>ID of the network to define. Defaults to <code>None</code>, in which case
<code>load_ID</code> is used.</dd>
<dt><strong><code>folder</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Folder in which the text file is located. If given, if should be in
the current directory. Defaults to <code>None</code>, in which case the text
file is expected to be in the current directory.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="popnet.structures.Network" href="#popnet.structures.Network">Network</a></code> or <code><a title="popnet.structures.MicroNetwork" href="#popnet.structures.MicroNetwork">MicroNetwork</a></code></dt>
<dd>The loaded network. It will be a <code><a title="popnet.structures.MicroNetwork" href="#popnet.structures.MicroNetwork">MicroNetwork</a></code> if a size is given for
every population.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>FileNotFoundError</code></dt>
<dd>If no file is found with the expected name.</dd>
<dt><code><a title="popnet.exceptions.PopNetError" href="exceptions.html#popnet.exceptions.PopNetError">PopNetError</a></code></dt>
<dd>If the information in the file is not consistent with <code>load_ID</code>.</dd>
<dt><code><a title="popnet.exceptions.FormatError" href="exceptions.html#popnet.exceptions.FormatError">FormatError</a></code></dt>
<dd>If the file does not have the expected format.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_network(load_ID, new_ID=None, folder=None):
    &#34;&#34;&#34;Load a network from a text file.

    Define a new network from parameters in a text file. This file is expected
    to be named *ID - Network parameters.txt* where *ID* is the network&#39;s
    actual ID. If the file is read as a single string, it is expected to have
    the format of a string representation of a `Network` instance. Note that
    this is the format of text file saved by `Network.save`.

    Parameters
    ----------
    load_ID : str
        ID of the network to load. 
    new_ID : str, optional
        ID of the network to define. Defaults to `None`, in which case
        `load_ID` is used. 
    folder : str, optional
        Folder in which the text file is located. If given, if should be in
        the current directory. Defaults to `None`, in which case the text
        file is expected to be in the current directory.

    Returns
    -------
    Network or MicroNetwork
        The loaded network. It will be a `MicroNetwork` if a size is given for
        every population.

    Raises
    ------
    FileNotFoundError
        If no file is found with the expected name.
    popnet.exceptions.PopNetError
        If the information in the file is not consistent with `load_ID`.
    popnet.exceptions.FormatError
        If the file does not have the expected format.
    &#34;&#34;&#34;
    filename = _internals._format_filename(folder, load_ID, &#39;Network parameters&#39;)
    if new_ID is None:
        new_ID = load_ID
    try:
        with open(filename, &#39;r&#39;, encoding=&#39;utf-8&#39;) as file:
            lines = file.readlines()
    except FileNotFoundError as error:
        raise FileNotFoundError(f&#39;No file is available to load network {load_ID}&#39;
                                &#39;. Maybe no parameters have been saved, or maybe&#39;
                                &#39; the file containing the data does not have the&#39;
                                f&#39; expected name. It should be {load_ID} - &#39;
                                &#39;Network parameters.txt.&#39;) from error
    if load_ID != (other_ID := lines[0].strip().split()[-1]):
        raise PopNetError(f&#39;The file {load_ID} - Network parameters.txt seems &#39;
                          f&#39;to contain information about a network {other_ID} &#39;
                          f&#39;rather than {load_ID}; PopNet is confused.&#39;)
    j = 2
    populations = []
    while j &lt; len(lines):
        if lines[j].startswith(&#39;Connection matrix&#39;):
            break
        # At index j+1 a population&#39;s description starts. We loop until the
        # end of the description, that is, when an empty line is reached.
        k = j + 1
        while lines[k] != &#39;\n&#39;:
            k += 1
        populations.append(Population._load(lines[j : k]))
        j = k + 1
    else:
        raise FormatError(f&#39;It seems that the file {load_ID} - Network param&#39;
                          &#39;eters.txt does not have the correct format to import&#39;
                          f&#39; the network {load_ID}. It should have the format &#39;
                          &#39;of a string representation of a Network instance.&#39;)
    if any(pop.size is None for pop in populations):
        net = Network(new_ID, populations)
    else:
        net = MicroNetwork(new_ID, populations)
    # Set the connection matrix from the file&#39;s data.
    string = &#39;&#39;.join(lines[j+1 : j+1+len(net.populations)])
    net._set_c_from_string(string)
    if isinstance(net, MicroNetwork):
        net.reset_parameters()
    return net</code></pre>
</details>
</dd>
<dt id="popnet.structures.network"><code class="name flex">
<span>def <span class="ident">network</span></span>(<span>ID, populations)</span>
</code></dt>
<dd>
<div class="desc"><p>Define a network from given populations.</p>
<p>Define a <code><a title="popnet.structures.Network" href="#popnet.structures.Network">Network</a></code> instance from already defined populations. If all
populations have a defined size, the network will rather be a <code><a title="popnet.structures.MicroNetwork" href="#popnet.structures.MicroNetwork">MicroNetwork</a></code>
instance.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ID</code></strong> :&ensp;<code>str</code></dt>
<dd>ID given to the network.</dd>
<dt><strong><code>populations</code></strong> :&ensp;<code>tuple</code> of <code><a title="popnet.structures.Population" href="#popnet.structures.Population">Population</a></code> or <code><a title="popnet.structures.Population" href="#popnet.structures.Population">Population</a></code></dt>
<dd>Populations that define the network.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="popnet.structures.Network" href="#popnet.structures.Network">Network</a></code> or <code><a title="popnet.structures.MicroNetwork" href="#popnet.structures.MicroNetwork">MicroNetwork</a></code></dt>
<dd>The network composed of the populations listed in <code>populations</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>populations</code> cannot be converted into a tuple of <code><a title="popnet.structures.Population" href="#popnet.structures.Population">Population</a></code>
instances.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def network(ID, populations):
    &#34;&#34;&#34;Define a network from given populations.

    Define a `Network` instance from already defined populations. If all
    populations have a defined size, the network will rather be a `MicroNetwork`
    instance.

    Parameters
    ----------
    ID : str
        ID given to the network.
    populations : tuple of Population or Population
        Populations that define the network.

    Returns
    -------
    Network or MicroNetwork
        The network composed of the populations listed in `populations`.

    Raises
    ------
    TypeError
        If `populations` cannot be converted into a tuple of `Population`
        instances.
    &#34;&#34;&#34;
    net = Network(ID, populations)
    try:
        net = net.underlying()
    except PopNetError:
        pass
    return net</code></pre>
</details>
</dd>
<dt id="popnet.structures.population"><code class="name flex">
<span>def <span class="ident">population</span></span>(<span>name, ID=None, size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Define a population of biological neurons.</p>
<p>Define a <code><a title="popnet.structures.Population" href="#popnet.structures.Population">Population</a></code> instance with a given name, possibly with a
microscopic structure.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the population.</dd>
<dt><strong><code>ID</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>ID of the population. It must be a single character. If not given, the
last character of <code>name</code> is used if it is a number, else the first one
is used.</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of neurons of the population. It must be positive. Defaults to
<code>None</code>, in which case no size is defined for the population.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="popnet.structures.Population" href="#popnet.structures.Population">Population</a></code></dt>
<dd>The population initialized with the given name, ID and size.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def population(name, ID=None, size=None):
    &#34;&#34;&#34;Define a population of biological neurons.

    Define a `Population` instance with a given name, possibly with a
    microscopic structure.

    Parameters
    ----------
    name : str
        Name of the population.
    ID : str, optional
        ID of the population. It must be a single character. If not given, the
        last character of `name` is used if it is a number, else the first one
        is used.
    size : int, optional
        Number of neurons of the population. It must be positive. Defaults to
        `None`, in which case no size is defined for the population.

    Returns
    -------
    Population
        The population initialized with the given name, ID and size.
    &#34;&#34;&#34;
    pop = Population(name, ID=ID, size=size)
    return pop</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="popnet.structures.Configuration"><code class="flex name class">
<span>class <span class="ident">Configuration</span></span>
<span>(</span><span>network, ID=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Configurations used in numerical experiments.</p>
<p>The <code><a title="popnet.structures.Configuration" href="#popnet.structures.Configuration">Configuration</a></code> class allows to easily group together all parameters
that are needed to perform numerical experiments. Although the base class
can be used with any network of any number of populations, it is better to
use the <code><a title="popnet.structures.ConfigurationOne" href="#popnet.structures.ConfigurationOne">ConfigurationOne</a></code> subclass for the case where the network has only
one population and the <code><a title="popnet.structures.MicroConfiguration" href="#popnet.structures.MicroConfiguration">MicroConfiguration</a></code> subclass when the network has a
defined microscopic structure, as more features are available in these
cases.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>network</code></strong> :&ensp;<code><a title="popnet.structures.Network" href="#popnet.structures.Network">Network</a></code></dt>
<dd>Network associated with the configuration.</dd>
<dt><strong><code>ID</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>ID to associate with the configuration. Defaults to <code>None</code>, in which case
the network's ID is used.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments used to initialize other data attributes.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>ID</code></strong> :&ensp;<code>str</code></dt>
<dd>ID of the configuration. See <code><a title="popnet.structures.Configuration.ID" href="#popnet.structures.Configuration.ID">Configuration.ID</a></code>.</dd>
<dt><strong><code>network</code></strong> :&ensp;<code><a title="popnet.structures.Network" href="#popnet.structures.Network">Network</a></code></dt>
<dd>Network associated with the configuration. See <code><a title="popnet.structures.Configuration.network" href="#popnet.structures.Configuration.network">Configuration.network</a></code>.</dd>
<dt><strong><code>initial_state</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Initial state of the network. See <code><a title="popnet.structures.Configuration.initial_state" href="#popnet.structures.Configuration.initial_state">Configuration.initial_state</a></code>.</dd>
<dt><strong><code>Q</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Input in the network. See <code><a title="popnet.structures.Configuration.Q" href="#popnet.structures.Configuration.Q">Configuration.Q</a></code>.</dd>
<dt><strong><code>initial_time</code></strong>, <strong><code>final_time</code></strong> :&ensp;<code>float</code></dt>
<dd>Times between which the evolution of the network's state is studied.
See <code><a title="popnet.structures.Configuration.initial_time" href="#popnet.structures.Configuration.initial_time">Configuration.initial_time</a></code> and <code><a title="popnet.structures.Configuration.final_time" href="#popnet.structures.Configuration.final_time">Configuration.final_time</a></code>.</dd>
<dt><strong><code>iterations</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of iterations used for the numerical integration, if performed.
See <code><a title="popnet.structures.Configuration.iterations" href="#popnet.structures.Configuration.iterations">Configuration.iterations</a></code>.</dd>
<dt><strong><code>delta</code></strong> :&ensp;<code>float</code></dt>
<dd>Time interval between two iterations. See <code><a title="popnet.structures.Configuration.delta" href="#popnet.structures.Configuration.delta">Configuration.delta</a></code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If the second argument is not a <code><a title="popnet.structures.Network" href="#popnet.structures.Network">Network</a></code> instance.</dd>
<dt><code>KeyError</code></dt>
<dd>If a keyword argument is not a valid attribute.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Configuration:
    &#34;&#34;&#34;Configurations used in numerical experiments.

    The `Configuration` class allows to easily group together all parameters
    that are needed to perform numerical experiments. Although the base class
    can be used with any network of any number of populations, it is better to
    use the `ConfigurationOne` subclass for the case where the network has only
    one population and the `MicroConfiguration` subclass when the network has a
    defined microscopic structure, as more features are available in these
    cases.

    Parameters
    ----------
    network : Network
        Network associated with the configuration.
    ID : str, optional
        ID to associate with the configuration. Defaults to `None`, in which case
        the network&#39;s ID is used.
    **kwargs
        Keyword arguments used to initialize other data attributes.

    Attributes
    ----------
    ID : str
        ID of the configuration. See `Configuration.ID`.
    network : Network
        Network associated with the configuration. See `Configuration.network`.
    initial_state : array_like
        Initial state of the network. See `Configuration.initial_state`.
    Q : array_like
        Input in the network. See `Configuration.Q`.
    initial_time, final_time : float
        Times between which the evolution of the network&#39;s state is studied.
        See `Configuration.initial_time` and `Configuration.final_time`.
    iterations : int
        Number of iterations used for the numerical integration, if performed.
        See `Configuration.iterations`.
    delta : float
        Time interval between two iterations. See `Configuration.delta`.

    Raises
    ------
    TypeError
        If the second argument is not a `Network` instance.
    KeyError
        If a keyword argument is not a valid attribute.

    &#34;&#34;&#34;

    def __init__(self, network, ID=None, **kwargs):
        if not isinstance(network, Network):
            raise TypeError(&#39;The network associated with a configuration &#39;
                            &#39;should indeed be a Network instance.&#39;)
        self._network = network

        if ID is None:
            ID = network.ID
        self.ID = ID

        state_attributes = {&#39;Q&#39;: np.zeros(p := len(self.network.populations)), 
                            &#39;initial_state&#39;: np.zeros(p * (2*p + 3))}
        float_attributes = {&#39;initial_time&#39;: 0., &#39;final_time&#39;: 10.}
        int_attributes = {&#39;iterations&#39;: 1000}

        # Here the time attributes have to be initialized without calling the 
        # setter methods, because they reference each other, so they all have to
        # be already defined when a setter is called. 
        for attr in kwargs:
            if attr in state_attributes:
                setattr(self, attr, kwargs[attr])
                state_attributes.pop(attr)
            elif attr in float_attributes:
                setattr(self, &#39;_&#39;+attr, float(kwargs[attr]))
                float_attributes.pop(attr)
            elif attr in int_attributes:
                setattr(self, &#39;_&#39;+attr, int(kwargs[attr]))
                int_attributes.pop(attr)
            else:
                raise KeyError(f&#39;{attr} is not a valid parameter for the &#39;
                               &#39;Configuration class.&#39;)

        for attr in state_attributes:
            setattr(self, attr, state_attributes[attr])
        for attr in float_attributes:
            setattr(self, &#39;_&#39;+attr, float_attributes[attr])
        for attr in int_attributes:
            setattr(self, &#39;_&#39;+attr, int_attributes[attr])

        self.delta = (self.final_time - self.initial_time) / self.iterations

        A_labels = [f&#39;A[{pop.ID}]&#39; for pop in self.network.populations]
        R_labels = [f&#39;R[{pop.ID}]&#39; for pop in self.network.populations]
        CAA_labels = [f&#39;CAA[{popJ.ID},{popK.ID}]&#39;
                        for J, popJ in enumerate(self.network.populations)
                        for popK in self.network.populations[J:]]
        CRR_labels = [f&#39;CRR[{popJ.ID},{popK.ID}]&#39;
                        for J, popJ in enumerate(self.network.populations)
                        for popK in self.network.populations[J:]]
        CAR_labels = [f&#39;CAR[{popJ.ID},{popK.ID}]&#39;
                        for popJ in self.network.populations
                        for popK in self.network.populations]
        self._variables = (A_labels + R_labels 
                            + CAA_labels + CRR_labels + CAR_labels)

    def __str__(self):
        string = (f&#39;Configuration {self.ID}\n\n&#39;
                  f&#39;Network used: {self.network.ID}\n&#39;)
        string += (&#39;\nParameters:\n&#39;
                  f&#39;       ti = {self.initial_time}\n&#39;
                  f&#39;       tf = {self.final_time}\n&#39;
                  f&#39;       \u0394t = {self.delta}\n&#39;
                  f&#39;{self.iterations:&gt;9} iterations\n&#39;)
        if self._other_params_string() is not None:
            string += self._other_params_string()
        string += (&#39;\nInput:\n&#39;
                  f&#39;        Q = {self.Q}\n&#39;)
        string += &#39;\nInitial state:\n&#39;
        for var, val in zip(self._variables, self.initial_state):
            string += f&#39;{var:&gt;9} = {val}\n&#39;
        return string[:-1] #Remove the last &#39;\n&#39;

    @staticmethod
    def load(load_ID, new_ID=None, network=None, folder=None):
        &#34;&#34;&#34;Alias for `load_config`.&#34;&#34;&#34;
        return load_config(load_ID, new_ID=None, network=None, folder=None)

    @property
    def ID(self):
        &#34;&#34;&#34;ID of the configuration.

        ID given to the configuration. It has to be a string that begins with
        the associated network&#39;s ID. It is used to name files when saving the
        configuration. Setting its value will raise an error if it is not a
        string or if it does not begin with the network&#39;s ID.
        &#34;&#34;&#34;
        return self._ID

    @ID.setter
    def ID(self, new_ID):
        if not isinstance(new_ID, str):
            raise TypeError(&#39;The configuration\&#39;s ID should be a string.&#39;)
        if new_ID[:len(self.network.ID)] != self.network.ID:
            raise ValueError(&#39;The ID of the configuration should begin with &#39;
                             &#39;that of the network&#39;)
        self._ID = new_ID

    @property
    def network(self):
        &#34;&#34;&#34;Network associated with the configuration.

        Network associated with the configuration, as a `Network` instance. It
        is set at initialization, but it cannot be reset nor deleted afterwards.
        &#34;&#34;&#34;
        return self._network

    @property
    def initial_state(self):
        &#34;&#34;&#34;Initial state of the configuration.

        The initial state of the network. As detailed in the
        [Notes](#configuration-initial-state-notes) section below, if the
        network has *p* populations, the initial state always has *p*(2*p*+3)
        components. The setter method ensures that the initial state is always
        a NumPy array of floats of the correct length. If it is set as a shorter
        array, it will be filled with zeros and a warning will be issued.

        Notes {#configuration-initial-state-notes}
        -----
        Since it is simpler to assume that every configuration can be used with
        any PopNet executor, the initial state of any configuration should have
        the number of components of the highest dimensional dynamical system
        studied by this package, which is the extended system. For a network of
        *p* populations, the extended system has *p*(2*p*+3) dimensions: there
        are *p* equations for *A*&#39;s, *p* equations for *R*&#39;s, *p*(*p*+1)/2
        equations for covariances between *A*&#39;s, *p*(*p*+1)/2 equations for
        covariances between *R*&#39;s, and *p*&lt;sup&gt;2&lt;/sup&gt; equations for covariances
        between *A*&#39;s and *R*&#39;s. The states are assumed to be ordered as
        follows:
        \\[ 
            (\\begin{aligned}[t]
            &amp; A_1, A_2, ..., A_p, \\\\
            &amp; R_1, R_2, ..., R_p, \\\\
            &amp; \\mathrm{C}_{AA}^{11}, \\mathrm{C}_{AA}^{12}, ..., 
                \\mathrm{C}_{AA}^{1p}, \\mathrm{C}_{AA}^{22}, ..., 
                \\mathrm{C}_{AA}^{2p}, \\mathrm{C}_{AA}^{33}, ..., 
                \\mathrm{C}_{AA}^{3p}, ..., \\mathrm{C}_{AA}^{pp}, \\\\
            &amp; \\mathrm{C}_{RR}^{11}, \\mathrm{C}_{RR}^{12}, ..., 
                \\mathrm{C}_{RR}^{1p}, \\mathrm{C}_{RR}^{22}, ..., 
                \\mathrm{C}_{RR}^{2p}, \\mathrm{C}_{RR}^{33}, ..., 
                \\mathrm{C}_{RR}^{3p}, ..., \\mathrm{C}_{RR}^{pp}, \\\\
            &amp; \\mathrm{C}_{AR}^{11}, \\mathrm{C}_{AR}^{12}, ..., 
                \\mathrm{C}_{AR}^{1p}, \\mathrm{C}_{AR}^{21}, ...,
                \\mathrm{C}_{AR}^{2p}, ..., \\mathrm{C}_{AR}^{p1}, 
                \\mathrm{C}_{AR}^{p2}, ..., \\mathrm{C}_{AR}^{pp}).
            \\end{aligned}
        \\]
        Remark that there are no \\(\\mathrm{C}_{AA}^{21}\\) or
        \\(\\mathrm{C}_{RR}^{21}\\) components, for example, since the
        \\(\\mathrm{C}_{AA}\\) and \\(\\mathrm{C}_{RR}\\) matrices are symmetric
        and each independant state variable is given only one. This is not the
        case for \\(\\mathrm{C}_{AR}\\), since
        \\[
            \\mathrm{C}_{AR}^{JK} = \\mathrm{Cov}[A_J, R_K] \\neq 
            \\mathrm{Cov}[A_K, R_J] = \\mathrm{C}_{AR}^{KJ} 
        \\]
        in general. 
        &#34;&#34;&#34;
        return self._initial_state

    @initial_state.setter
    def initial_state(self, new_state):
        length = (p := len(self.network.populations)) * (2*p + 3)
        if len(new_state) != length:
            raise ValueError(f&#39;The state provided has {len(new_state)} &#39;
                             f&#39;components, but it should have {length} &#39;
                             f&#39;components for a network of {p} populations.&#39;)
        self._initial_state = np.array(new_state, float)

    @property
    def Q(self):
        &#34;&#34;&#34;Input in the network.

        Input in the populations of the network from an external source. It must
        have the same length as the number of populations of the network. The
        setter method ensures that the input is always of the correct length,
        and that it is always a NumPy array of floats. 
        &#34;&#34;&#34;
        return self._Q

    @Q.setter
    def Q(self, new_Q):
        try:
            float_new_Q = float(new_Q)
        except:
            pass
        else:
            new_Q = [float_new_Q]
        if len(new_Q) != (p := len(self.network.populations)):
            raise PopNetError(f&#39;The input Q should always have {p} components &#39;
                              f&#39;for a network of {p} populations.&#39;)
        self._Q = np.array(new_Q, float)

    @property
    def initial_time(self):
        &#34;&#34;&#34;Time from which the network&#39;s state is studied.

        Start of the period in which the evolution of the network&#39;s state is
        studied. When setting the initial time, the time interval
        `Configuration.delta` is adapted to ensure that the number of iterations
        and the time interval are still consistent with the total duration of
        the integration.
        &#34;&#34;&#34;
        return self._initial_time

    @initial_time.setter
    def initial_time(self, new_initial_time):
        self._initial_time = float(new_initial_time)
        self._delta = (self.final_time - self.initial_time) / self.iterations

    @property
    def final_time(self):
        &#34;&#34;&#34;Time until which the network&#39;s state is studied.

        End of the period in which the evolution of the network&#39;s state is
        studied. When setting the final time, the time interval
        `Configuration.delta` is adapted to ensure that the number of iterations
        and the time interval are still consistent with the total duration of
        the integration.
        &#34;&#34;&#34;
        return self._final_time

    @final_time.setter
    def final_time(self, new_final_time):
        self._final_time = float(new_final_time)
        self._delta = (self.final_time - self.initial_time) / self.iterations

    @property
    def delta(self):
        &#34;&#34;&#34;Time interval between two iterations in the numerical integration.
        
        Time interval between two consecutive iterations in a numerical
        integration performed using this configuration. This is not used for
        simulations of the microscopic network&#39;s dynamics. When setting the time
        interval, the number of iterations `Configuration.iterations` is adapted
        to ensure that the number of iterations and the time interval are still
        consistent with the total length of time of the integration.
        &#34;&#34;&#34;
        return self._delta

    @delta.setter
    def delta(self, new_delta):
        self._delta = float(new_delta)
        self._iterations = round((self.final_time - self.initial_time) 
                                 / self.delta)

    @property
    def iterations(self):
        &#34;&#34;&#34;Number of iterations of the numerical integration.

        Total number of iterations of a numerical integration performed using
        this configuration. It is also the number of time steps added after the
        initial time to get the times array when doing statistics from
        simulations of the network&#39;s microscopic dynamics. In both cases, the
        length of the times array is `1 + iterations`. This is not used when
        only one simulation of the microscopic dynamics is performed.

        When setting the number of iterations, the time interval
        `Configuration.delta` will be adapted to ensure that the number of
        iterations and the time interval are still consistent with the total
        length of time of the integration. 
        &#34;&#34;&#34;
        return self._iterations

    @iterations.setter
    def iterations(self, new_number_of_iterations):
        self._iterations = int(new_number_of_iterations)
        self._delta = (self.final_time - self.initial_time) / self.iterations

    def add_random_uniform_perturbation(self, R, axes=None):
        &#34;&#34;&#34;Add a random perturbation to the initial state.

        Add a random perturbation to the initial state, taken from a uniform
        distribution on an *N*--sphere of radius `R`. The dimension *N* is the
        number of components perturbated as given by `axes`. 

        Parameters
        ----------
        R : float
            Norm of the perturbation. Corresponds to the radius of the
            *N*--sphere in which the perturbation is randomly taken.
        axes : list or tuple of ints, optional
            Axes to change in the initial state. Defaults to `None`, in which
            case every component is changed. 

        Notes
        -----
        To generate a uniform distribution on an *N*--sphere of radius `R`, we
        use the method described in [1]: every component of the perturbation is
        first taken from a standard normal distribution, and then the resulting
        vector is scaled to have a norm of `R`.

        References
        ----------
         1. Muller, M. E. “A note on a method for generating points uniformly on
            *N*-dimensional spheres.” *Commun. ACM* **2**, 19--20 (1959).
            doi:[10.1145/377939.377946](https://doi.org/10.1145/377939.377946).
        &#34;&#34;&#34;
        if axes is None:
            axes = np.arange(len(self.initial_state))
        ball = np.random.default_rng().normal(size=len(axes))
        ball = R * ball / np.linalg.norm(ball)
        perturbation = np.zeros(len(self.initial_state))
        perturbation[np.array(axes)] = ball
        self.initial_state = self.initial_state + perturbation

    def add_to_initial_state(self, perturbation):
        &#34;&#34;&#34;Add a given perturbation to the initial state.&#34;&#34;&#34;
        if perturbation is None:
            return 
        self.initial_state = self.initial_state + np.array(perturbation, float)

    def copy(self, new_ID):
        &#34;&#34;&#34;Copy the configuration.

        Return a copy of the configuration with a new ID.

        Parameters
        ----------
        new_ID : str
            ID to give to the new configuration.

        Returns
        -------
        Configuration
            The copied configuration.
        &#34;&#34;&#34;
        new_config = deepcopy(self)
        new_config.ID = new_ID
        return new_config

    def microscopized(self, sizes, new_ID=None):
        &#34;&#34;&#34;Get a microscopic version of the configuration.

        Return a copy of the configuration, but with a microscopic structure
        where population sizes are given by `sizes`.

        Parameters
        ----------
        sizes : list or tuple of int
            Sizes to give to the populations of the network, in the same order
            as in the network&#39;s attribute.
        new_ID : str
            ID to give to the new configuration. Defaults to `None`, in which
            case the configuration&#39;s ID is used.
        &#34;&#34;&#34;
        if new_ID is None:
            new_ID = self.ID
        net = self.network.copy(self.network.ID)
        for pop, size in zip(net.populations, sizes):
            pop.size = size
        try:
            net = net.underlying()
        except AttributeError:
            pass
        configuration = config(net, ID=new_ID)
        for param, value in self.__dict__.items():
            if param in (&#39;_network&#39;, &#39;_ID&#39;):
                continue
            setattr(configuration, param, value)
        configuration.reset_micro_initial_state()
        return configuration

    def save(self, save_network=True, folder=None, note=None):
        &#34;&#34;&#34;Save the current configuration.

        Save the string representation of the configuration in a text file,
        under the name *ID - Configuration.txt*, where *ID* is the actual ID of
        the configuration.

        Parameters
        ----------
        save_network : bool, optional
            Decides if the network parameters are saved as well in the same
            folder, using `Network.save`. Defaults to `True`.
        folder : str, optional
            A folder in which the file is saved. If it does not exist in the
            current directory, it is created. Defaults to `None`, in which case
            the file is saved in the current directory.
        note : str, optional
            If not `None`, an additional section &#34;Additional notes:&#34; is written
            in the file, and `note` is written there. 
        &#34;&#34;&#34;
        if save_network:
            self.network.save(folder=folder)
        filename = _internals._format_filename(folder, self.ID, &#39;Configuration&#39;)
        _internals._make_sure_folder_exists(folder)
        with open(filename, &#39;w&#39;, encoding=&#39;utf-8&#39;) as file:
            file.write(str(self))
            if note is not None:
                file.write(&#39;\n\nAdditional notes:\n&#39;)
                file.write(note)

    def set_initial_state_from(self, other):
        &#34;&#34;&#34;Set the initial state from another configuration.

        Set the initial state from another configuration, where the network can
        have another number of populations.
            - If the other configuration has *less* populations, only the state
              components associated with the first populations will be set.
            - If the other configuration has the *same* number of populations,
              the initial state will simply be copied.
            - If the other configuration has *more* populations, the initial
              state will be set according to the first populations of the
              other configuration.

        Parameters
        ----------
        other : Configuration
            Other configuration from which to take the initial state.

        Raises
        ------
        TypeError
            If `other` is not a `Configuration` instance.
        &#34;&#34;&#34;
        if not isinstance(other, Configuration):
            raise TypeError(&#39;The initial state can only be copied from another &#39;
                            &#39;\&#39;Configuration\&#39; instance.&#39;)
        sp = len(self.network.populations)
        op = len(other.network.populations)
        if op == sp:
            self.initial_state = other.initial_state
            return
        mp = min(sp, op)
        self.initial_state[:mp] = other.initial_state[:mp]
        self.initial_state[sp:sp+mp] = other.initial_state[op:op+mp]
        def loop(start, step):
            sn, on = start(sp), start(op)
            for j in range(mp):
                self.initial_state[sn : sn + step(mp,j)] = \
                    other.initial_state[on : on + step(mp,j)]
                sn, on = sn + step(sp, j), on + step(op, j)
        loop(lambda p: 2*p, lambda p,j: p - j)                    # CAA
        loop(lambda p: 2*p + round(p*(p+1)/2), lambda p,j: p - j) # CRR
        loop(lambda p: 2*p + p*(p+1), lambda p,j: p)              # CAR

    def set_random_initial_state(self, bound_cov=0.06):
        &#34;&#34;&#34;Set the initial state with random values.

        Set the initial state with random values. For each population, the
        values for *A* and *R* and chosen from uniform distributions in the
        triangle \\(\\{(x,y) \\in [0,1)^2 : x + y &lt; 1\\}\\), using the method
        described in [1]. All variances are chosen from uniform distributions
        between 0 and `bound_cov`, and all non-symmetric covariances from
        uniform distributions between `-bound_cov` and `bound_cov`, regardless
        of the values of the expectations. 

        Parameters
        ----------
        bound_cov : float, optional
            Positive number which sets the distributions of covariances.
            Variances are all taken from a uniform distribution between zero and
            `bound_cov`, and non-symmetric covariances are taken from a uniform
            distribution between `-bound_cov` and `bound_cov`. Defaults to 0.06.

        Raises
        ------
        TypeError
            If `bound_cov` cannot be converted to a float.
        ValueError
            If `bound_cov` is not a positive number.

        References
        ----------
         1. Osada, R., Funkhouser, T., Chazelle, B. &amp; Dobkin, D. “Shape
            distributions.” *ACM Trans. Graph.* **21**, 807--832 (2002).
            doi:[10.1145/571647.571648](https://doi.org/10.1145/571647.571648).
        &#34;&#34;&#34;
        p = len(self.network.populations)
        state = np.zeros(p*(2*p+3))
        rng = np.random.default_rng()
        try:
            bound_cov = float(bound_cov)
        except TypeError as error:
            raise TypeError(&#39;The bound to choose covariances should be a &#39;
                            &#39;number.&#39;) from error
        if bound_cov &lt; 0:
            raise ValueError(&#39;The bound to choose covariances should be &#39;
                             &#39;positive.&#39;)
        for J in range(p):
            a, b = rng.random(size=2)
            state[J] = np.sqrt(a) * (1 - b)
            state[p+J] = np.sqrt(a) * b
        state[2*p : p*(p+3)] = bound_cov * rng.random(size=p*(p+1))
        state[p*(p+3) :] = -bound_cov + 2*bound_cov * rng.random(size=p**2)
        self.initial_state = state

    def _other_params_string(self):
        &#34;&#34;&#34;Optional parameters for subclasses to write in `str(self)`.&#34;&#34;&#34;
        pass</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="popnet.structures.ConfigurationOne" href="#popnet.structures.ConfigurationOne">ConfigurationOne</a></li>
<li><a title="popnet.structures.MicroConfiguration" href="#popnet.structures.MicroConfiguration">MicroConfiguration</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="popnet.structures.Configuration.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>load_ID, new_ID=None, network=None, folder=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for <code><a title="popnet.structures.load_config" href="#popnet.structures.load_config">load_config()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(load_ID, new_ID=None, network=None, folder=None):
    &#34;&#34;&#34;Alias for `load_config`.&#34;&#34;&#34;
    return load_config(load_ID, new_ID=None, network=None, folder=None)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="popnet.structures.Configuration.ID"><code class="name">var <span class="ident">ID</span></code></dt>
<dd>
<div class="desc"><p>ID of the configuration.</p>
<p>ID given to the configuration. It has to be a string that begins with
the associated network's ID. It is used to name files when saving the
configuration. Setting its value will raise an error if it is not a
string or if it does not begin with the network's ID.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ID(self):
    &#34;&#34;&#34;ID of the configuration.

    ID given to the configuration. It has to be a string that begins with
    the associated network&#39;s ID. It is used to name files when saving the
    configuration. Setting its value will raise an error if it is not a
    string or if it does not begin with the network&#39;s ID.
    &#34;&#34;&#34;
    return self._ID</code></pre>
</details>
</dd>
<dt id="popnet.structures.Configuration.Q"><code class="name">var <span class="ident">Q</span></code></dt>
<dd>
<div class="desc"><p>Input in the network.</p>
<p>Input in the populations of the network from an external source. It must
have the same length as the number of populations of the network. The
setter method ensures that the input is always of the correct length,
and that it is always a NumPy array of floats.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Q(self):
    &#34;&#34;&#34;Input in the network.

    Input in the populations of the network from an external source. It must
    have the same length as the number of populations of the network. The
    setter method ensures that the input is always of the correct length,
    and that it is always a NumPy array of floats. 
    &#34;&#34;&#34;
    return self._Q</code></pre>
</details>
</dd>
<dt id="popnet.structures.Configuration.delta"><code class="name">var <span class="ident">delta</span></code></dt>
<dd>
<div class="desc"><p>Time interval between two iterations in the numerical integration.</p>
<p>Time interval between two consecutive iterations in a numerical
integration performed using this configuration. This is not used for
simulations of the microscopic network's dynamics. When setting the time
interval, the number of iterations <code><a title="popnet.structures.Configuration.iterations" href="#popnet.structures.Configuration.iterations">Configuration.iterations</a></code> is adapted
to ensure that the number of iterations and the time interval are still
consistent with the total length of time of the integration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def delta(self):
    &#34;&#34;&#34;Time interval between two iterations in the numerical integration.
    
    Time interval between two consecutive iterations in a numerical
    integration performed using this configuration. This is not used for
    simulations of the microscopic network&#39;s dynamics. When setting the time
    interval, the number of iterations `Configuration.iterations` is adapted
    to ensure that the number of iterations and the time interval are still
    consistent with the total length of time of the integration.
    &#34;&#34;&#34;
    return self._delta</code></pre>
</details>
</dd>
<dt id="popnet.structures.Configuration.final_time"><code class="name">var <span class="ident">final_time</span></code></dt>
<dd>
<div class="desc"><p>Time until which the network's state is studied.</p>
<p>End of the period in which the evolution of the network's state is
studied. When setting the final time, the time interval
<code><a title="popnet.structures.Configuration.delta" href="#popnet.structures.Configuration.delta">Configuration.delta</a></code> is adapted to ensure that the number of iterations
and the time interval are still consistent with the total duration of
the integration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def final_time(self):
    &#34;&#34;&#34;Time until which the network&#39;s state is studied.

    End of the period in which the evolution of the network&#39;s state is
    studied. When setting the final time, the time interval
    `Configuration.delta` is adapted to ensure that the number of iterations
    and the time interval are still consistent with the total duration of
    the integration.
    &#34;&#34;&#34;
    return self._final_time</code></pre>
</details>
</dd>
<dt id="popnet.structures.Configuration.initial_state"><code class="name">var <span class="ident">initial_state</span></code></dt>
<dd>
<div class="desc"><p>Initial state of the configuration.</p>
<p>The initial state of the network. As detailed in the
<a href="#configuration-initial-state-notes">Notes</a> section below, if the
network has <em>p</em> populations, the initial state always has <em>p</em>(2<em>p</em>+3)
components. The setter method ensures that the initial state is always
a NumPy array of floats of the correct length. If it is set as a shorter
array, it will be filled with zeros and a warning will be issued.</p>
<h2 id="configuration-initial-state-notes">Notes</h2>
<p>Since it is simpler to assume that every configuration can be used with
any PopNet executor, the initial state of any configuration should have
the number of components of the highest dimensional dynamical system
studied by this package, which is the extended system. For a network of
<em>p</em> populations, the extended system has <em>p</em>(2<em>p</em>+3) dimensions: there
are <em>p</em> equations for <em>A</em>'s, <em>p</em> equations for <em>R</em>'s, <em>p</em>(<em>p</em>+1)/2
equations for covariances between <em>A</em>'s, <em>p</em>(<em>p</em>+1)/2 equations for
covariances between <em>R</em>'s, and <em>p</em><sup>2</sup> equations for covariances
between <em>A</em>'s and <em>R</em>'s. The states are assumed to be ordered as
follows:
<span><span class="MathJax_Preview">
(\begin{aligned}[t]
&amp; A_1, A_2, ..., A_p, \\
&amp; R_1, R_2, ..., R_p, \\
&amp; \mathrm{C}_{AA}^{11}, \mathrm{C}_{AA}^{12}, ...,
\mathrm{C}_{AA}^{1p}, \mathrm{C}_{AA}^{22}, ...,
\mathrm{C}_{AA}^{2p}, \mathrm{C}_{AA}^{33}, ...,
\mathrm{C}_{AA}^{3p}, ..., \mathrm{C}_{AA}^{pp}, \\
&amp; \mathrm{C}_{RR}^{11}, \mathrm{C}_{RR}^{12}, ...,
\mathrm{C}_{RR}^{1p}, \mathrm{C}_{RR}^{22}, ...,
\mathrm{C}_{RR}^{2p}, \mathrm{C}_{RR}^{33}, ...,
\mathrm{C}_{RR}^{3p}, ..., \mathrm{C}_{RR}^{pp}, \\
&amp; \mathrm{C}_{AR}^{11}, \mathrm{C}_{AR}^{12}, ...,
\mathrm{C}_{AR}^{1p}, \mathrm{C}_{AR}^{21}, ...,
\mathrm{C}_{AR}^{2p}, ..., \mathrm{C}_{AR}^{p1},
\mathrm{C}_{AR}^{p2}, ..., \mathrm{C}_{AR}^{pp}).
\end{aligned}
</span><script type="math/tex; mode=display">
(\begin{aligned}[t]
& A_1, A_2, ..., A_p, \\
& R_1, R_2, ..., R_p, \\
& \mathrm{C}_{AA}^{11}, \mathrm{C}_{AA}^{12}, ...,
\mathrm{C}_{AA}^{1p}, \mathrm{C}_{AA}^{22}, ...,
\mathrm{C}_{AA}^{2p}, \mathrm{C}_{AA}^{33}, ...,
\mathrm{C}_{AA}^{3p}, ..., \mathrm{C}_{AA}^{pp}, \\
& \mathrm{C}_{RR}^{11}, \mathrm{C}_{RR}^{12}, ...,
\mathrm{C}_{RR}^{1p}, \mathrm{C}_{RR}^{22}, ...,
\mathrm{C}_{RR}^{2p}, \mathrm{C}_{RR}^{33}, ...,
\mathrm{C}_{RR}^{3p}, ..., \mathrm{C}_{RR}^{pp}, \\
& \mathrm{C}_{AR}^{11}, \mathrm{C}_{AR}^{12}, ...,
\mathrm{C}_{AR}^{1p}, \mathrm{C}_{AR}^{21}, ...,
\mathrm{C}_{AR}^{2p}, ..., \mathrm{C}_{AR}^{p1},
\mathrm{C}_{AR}^{p2}, ..., \mathrm{C}_{AR}^{pp}).
\end{aligned}
</script></span>
Remark that there are no <span><span class="MathJax_Preview">\mathrm{C}_{AA}^{21}</span><script type="math/tex">\mathrm{C}_{AA}^{21}</script></span> or
<span><span class="MathJax_Preview">\mathrm{C}_{RR}^{21}</span><script type="math/tex">\mathrm{C}_{RR}^{21}</script></span> components, for example, since the
<span><span class="MathJax_Preview">\mathrm{C}_{AA}</span><script type="math/tex">\mathrm{C}_{AA}</script></span> and <span><span class="MathJax_Preview">\mathrm{C}_{RR}</span><script type="math/tex">\mathrm{C}_{RR}</script></span> matrices are symmetric
and each independant state variable is given only one. This is not the
case for <span><span class="MathJax_Preview">\mathrm{C}_{AR}</span><script type="math/tex">\mathrm{C}_{AR}</script></span>, since
<span><span class="MathJax_Preview">
\mathrm{C}_{AR}^{JK} = \mathrm{Cov}[A_J, R_K] \neq
\mathrm{Cov}[A_K, R_J] = \mathrm{C}_{AR}^{KJ}
</span><script type="math/tex; mode=display">
\mathrm{C}_{AR}^{JK} = \mathrm{Cov}[A_J, R_K] \neq
\mathrm{Cov}[A_K, R_J] = \mathrm{C}_{AR}^{KJ}
</script></span>
in general.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def initial_state(self):
    &#34;&#34;&#34;Initial state of the configuration.

    The initial state of the network. As detailed in the
    [Notes](#configuration-initial-state-notes) section below, if the
    network has *p* populations, the initial state always has *p*(2*p*+3)
    components. The setter method ensures that the initial state is always
    a NumPy array of floats of the correct length. If it is set as a shorter
    array, it will be filled with zeros and a warning will be issued.

    Notes {#configuration-initial-state-notes}
    -----
    Since it is simpler to assume that every configuration can be used with
    any PopNet executor, the initial state of any configuration should have
    the number of components of the highest dimensional dynamical system
    studied by this package, which is the extended system. For a network of
    *p* populations, the extended system has *p*(2*p*+3) dimensions: there
    are *p* equations for *A*&#39;s, *p* equations for *R*&#39;s, *p*(*p*+1)/2
    equations for covariances between *A*&#39;s, *p*(*p*+1)/2 equations for
    covariances between *R*&#39;s, and *p*&lt;sup&gt;2&lt;/sup&gt; equations for covariances
    between *A*&#39;s and *R*&#39;s. The states are assumed to be ordered as
    follows:
    \\[ 
        (\\begin{aligned}[t]
        &amp; A_1, A_2, ..., A_p, \\\\
        &amp; R_1, R_2, ..., R_p, \\\\
        &amp; \\mathrm{C}_{AA}^{11}, \\mathrm{C}_{AA}^{12}, ..., 
            \\mathrm{C}_{AA}^{1p}, \\mathrm{C}_{AA}^{22}, ..., 
            \\mathrm{C}_{AA}^{2p}, \\mathrm{C}_{AA}^{33}, ..., 
            \\mathrm{C}_{AA}^{3p}, ..., \\mathrm{C}_{AA}^{pp}, \\\\
        &amp; \\mathrm{C}_{RR}^{11}, \\mathrm{C}_{RR}^{12}, ..., 
            \\mathrm{C}_{RR}^{1p}, \\mathrm{C}_{RR}^{22}, ..., 
            \\mathrm{C}_{RR}^{2p}, \\mathrm{C}_{RR}^{33}, ..., 
            \\mathrm{C}_{RR}^{3p}, ..., \\mathrm{C}_{RR}^{pp}, \\\\
        &amp; \\mathrm{C}_{AR}^{11}, \\mathrm{C}_{AR}^{12}, ..., 
            \\mathrm{C}_{AR}^{1p}, \\mathrm{C}_{AR}^{21}, ...,
            \\mathrm{C}_{AR}^{2p}, ..., \\mathrm{C}_{AR}^{p1}, 
            \\mathrm{C}_{AR}^{p2}, ..., \\mathrm{C}_{AR}^{pp}).
        \\end{aligned}
    \\]
    Remark that there are no \\(\\mathrm{C}_{AA}^{21}\\) or
    \\(\\mathrm{C}_{RR}^{21}\\) components, for example, since the
    \\(\\mathrm{C}_{AA}\\) and \\(\\mathrm{C}_{RR}\\) matrices are symmetric
    and each independant state variable is given only one. This is not the
    case for \\(\\mathrm{C}_{AR}\\), since
    \\[
        \\mathrm{C}_{AR}^{JK} = \\mathrm{Cov}[A_J, R_K] \\neq 
        \\mathrm{Cov}[A_K, R_J] = \\mathrm{C}_{AR}^{KJ} 
    \\]
    in general. 
    &#34;&#34;&#34;
    return self._initial_state</code></pre>
</details>
</dd>
<dt id="popnet.structures.Configuration.initial_time"><code class="name">var <span class="ident">initial_time</span></code></dt>
<dd>
<div class="desc"><p>Time from which the network's state is studied.</p>
<p>Start of the period in which the evolution of the network's state is
studied. When setting the initial time, the time interval
<code><a title="popnet.structures.Configuration.delta" href="#popnet.structures.Configuration.delta">Configuration.delta</a></code> is adapted to ensure that the number of iterations
and the time interval are still consistent with the total duration of
the integration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def initial_time(self):
    &#34;&#34;&#34;Time from which the network&#39;s state is studied.

    Start of the period in which the evolution of the network&#39;s state is
    studied. When setting the initial time, the time interval
    `Configuration.delta` is adapted to ensure that the number of iterations
    and the time interval are still consistent with the total duration of
    the integration.
    &#34;&#34;&#34;
    return self._initial_time</code></pre>
</details>
</dd>
<dt id="popnet.structures.Configuration.iterations"><code class="name">var <span class="ident">iterations</span></code></dt>
<dd>
<div class="desc"><p>Number of iterations of the numerical integration.</p>
<p>Total number of iterations of a numerical integration performed using
this configuration. It is also the number of time steps added after the
initial time to get the times array when doing statistics from
simulations of the network's microscopic dynamics. In both cases, the
length of the times array is <code>1 + iterations</code>. This is not used when
only one simulation of the microscopic dynamics is performed.</p>
<p>When setting the number of iterations, the time interval
<code><a title="popnet.structures.Configuration.delta" href="#popnet.structures.Configuration.delta">Configuration.delta</a></code> will be adapted to ensure that the number of
iterations and the time interval are still consistent with the total
length of time of the integration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def iterations(self):
    &#34;&#34;&#34;Number of iterations of the numerical integration.

    Total number of iterations of a numerical integration performed using
    this configuration. It is also the number of time steps added after the
    initial time to get the times array when doing statistics from
    simulations of the network&#39;s microscopic dynamics. In both cases, the
    length of the times array is `1 + iterations`. This is not used when
    only one simulation of the microscopic dynamics is performed.

    When setting the number of iterations, the time interval
    `Configuration.delta` will be adapted to ensure that the number of
    iterations and the time interval are still consistent with the total
    length of time of the integration. 
    &#34;&#34;&#34;
    return self._iterations</code></pre>
</details>
</dd>
<dt id="popnet.structures.Configuration.network"><code class="name">var <span class="ident">network</span></code></dt>
<dd>
<div class="desc"><p>Network associated with the configuration.</p>
<p>Network associated with the configuration, as a <code><a title="popnet.structures.Network" href="#popnet.structures.Network">Network</a></code> instance. It
is set at initialization, but it cannot be reset nor deleted afterwards.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def network(self):
    &#34;&#34;&#34;Network associated with the configuration.

    Network associated with the configuration, as a `Network` instance. It
    is set at initialization, but it cannot be reset nor deleted afterwards.
    &#34;&#34;&#34;
    return self._network</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="popnet.structures.Configuration.add_random_uniform_perturbation"><code class="name flex">
<span>def <span class="ident">add_random_uniform_perturbation</span></span>(<span>self, R, axes=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a random perturbation to the initial state.</p>
<p>Add a random perturbation to the initial state, taken from a uniform
distribution on an <em>N</em>&ndash;sphere of radius <code>R</code>. The dimension <em>N</em> is the
number of components perturbated as given by <code>axes</code>. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>R</code></strong> :&ensp;<code>float</code></dt>
<dd>Norm of the perturbation. Corresponds to the radius of the
<em>N</em>&ndash;sphere in which the perturbation is randomly taken.</dd>
<dt><strong><code>axes</code></strong> :&ensp;<code>list</code> or <code>tuple</code> of <code>ints</code>, optional</dt>
<dd>Axes to change in the initial state. Defaults to <code>None</code>, in which
case every component is changed.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>To generate a uniform distribution on an <em>N</em>&ndash;sphere of radius <code>R</code>, we
use the method described in [1]: every component of the perturbation is
first taken from a standard normal distribution, and then the resulting
vector is scaled to have a norm of <code>R</code>.</p>
<h2 id="references">References</h2>
<ol class="references">
<li>Muller, M. E. “A note on a method for generating points uniformly on
<em>N</em>-dimensional spheres.” <em>Commun. ACM</em> <strong>2</strong>, 19&ndash;20 (1959).
doi:<a href="https://doi.org/10.1145/377939.377946">10.1145/377939.377946</a>.</li>
</ol></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_random_uniform_perturbation(self, R, axes=None):
    &#34;&#34;&#34;Add a random perturbation to the initial state.

    Add a random perturbation to the initial state, taken from a uniform
    distribution on an *N*--sphere of radius `R`. The dimension *N* is the
    number of components perturbated as given by `axes`. 

    Parameters
    ----------
    R : float
        Norm of the perturbation. Corresponds to the radius of the
        *N*--sphere in which the perturbation is randomly taken.
    axes : list or tuple of ints, optional
        Axes to change in the initial state. Defaults to `None`, in which
        case every component is changed. 

    Notes
    -----
    To generate a uniform distribution on an *N*--sphere of radius `R`, we
    use the method described in [1]: every component of the perturbation is
    first taken from a standard normal distribution, and then the resulting
    vector is scaled to have a norm of `R`.

    References
    ----------
     1. Muller, M. E. “A note on a method for generating points uniformly on
        *N*-dimensional spheres.” *Commun. ACM* **2**, 19--20 (1959).
        doi:[10.1145/377939.377946](https://doi.org/10.1145/377939.377946).
    &#34;&#34;&#34;
    if axes is None:
        axes = np.arange(len(self.initial_state))
    ball = np.random.default_rng().normal(size=len(axes))
    ball = R * ball / np.linalg.norm(ball)
    perturbation = np.zeros(len(self.initial_state))
    perturbation[np.array(axes)] = ball
    self.initial_state = self.initial_state + perturbation</code></pre>
</details>
</dd>
<dt id="popnet.structures.Configuration.add_to_initial_state"><code class="name flex">
<span>def <span class="ident">add_to_initial_state</span></span>(<span>self, perturbation)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a given perturbation to the initial state.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_to_initial_state(self, perturbation):
    &#34;&#34;&#34;Add a given perturbation to the initial state.&#34;&#34;&#34;
    if perturbation is None:
        return 
    self.initial_state = self.initial_state + np.array(perturbation, float)</code></pre>
</details>
</dd>
<dt id="popnet.structures.Configuration.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, new_ID)</span>
</code></dt>
<dd>
<div class="desc"><p>Copy the configuration.</p>
<p>Return a copy of the configuration with a new ID.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>new_ID</code></strong> :&ensp;<code>str</code></dt>
<dd>ID to give to the new configuration.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="popnet.structures.Configuration" href="#popnet.structures.Configuration">Configuration</a></code></dt>
<dd>The copied configuration.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self, new_ID):
    &#34;&#34;&#34;Copy the configuration.

    Return a copy of the configuration with a new ID.

    Parameters
    ----------
    new_ID : str
        ID to give to the new configuration.

    Returns
    -------
    Configuration
        The copied configuration.
    &#34;&#34;&#34;
    new_config = deepcopy(self)
    new_config.ID = new_ID
    return new_config</code></pre>
</details>
</dd>
<dt id="popnet.structures.Configuration.microscopized"><code class="name flex">
<span>def <span class="ident">microscopized</span></span>(<span>self, sizes, new_ID=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a microscopic version of the configuration.</p>
<p>Return a copy of the configuration, but with a microscopic structure
where population sizes are given by <code>sizes</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>sizes</code></strong> :&ensp;<code>list</code> or <code>tuple</code> of <code>int</code></dt>
<dd>Sizes to give to the populations of the network, in the same order
as in the network's attribute.</dd>
<dt><strong><code>new_ID</code></strong> :&ensp;<code>str</code></dt>
<dd>ID to give to the new configuration. Defaults to <code>None</code>, in which
case the configuration's ID is used.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def microscopized(self, sizes, new_ID=None):
    &#34;&#34;&#34;Get a microscopic version of the configuration.

    Return a copy of the configuration, but with a microscopic structure
    where population sizes are given by `sizes`.

    Parameters
    ----------
    sizes : list or tuple of int
        Sizes to give to the populations of the network, in the same order
        as in the network&#39;s attribute.
    new_ID : str
        ID to give to the new configuration. Defaults to `None`, in which
        case the configuration&#39;s ID is used.
    &#34;&#34;&#34;
    if new_ID is None:
        new_ID = self.ID
    net = self.network.copy(self.network.ID)
    for pop, size in zip(net.populations, sizes):
        pop.size = size
    try:
        net = net.underlying()
    except AttributeError:
        pass
    configuration = config(net, ID=new_ID)
    for param, value in self.__dict__.items():
        if param in (&#39;_network&#39;, &#39;_ID&#39;):
            continue
        setattr(configuration, param, value)
    configuration.reset_micro_initial_state()
    return configuration</code></pre>
</details>
</dd>
<dt id="popnet.structures.Configuration.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, save_network=True, folder=None, note=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Save the current configuration.</p>
<p>Save the string representation of the configuration in a text file,
under the name <em>ID - Configuration.txt</em>, where <em>ID</em> is the actual ID of
the configuration.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>save_network</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Decides if the network parameters are saved as well in the same
folder, using <code><a title="popnet.structures.Network.save" href="#popnet.structures.Network.save">Network.save()</a></code>. Defaults to <code>True</code>.</dd>
<dt><strong><code>folder</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>A folder in which the file is saved. If it does not exist in the
current directory, it is created. Defaults to <code>None</code>, in which case
the file is saved in the current directory.</dd>
<dt><strong><code>note</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>If not <code>None</code>, an additional section "Additional notes:" is written
in the file, and <code>note</code> is written there.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, save_network=True, folder=None, note=None):
    &#34;&#34;&#34;Save the current configuration.

    Save the string representation of the configuration in a text file,
    under the name *ID - Configuration.txt*, where *ID* is the actual ID of
    the configuration.

    Parameters
    ----------
    save_network : bool, optional
        Decides if the network parameters are saved as well in the same
        folder, using `Network.save`. Defaults to `True`.
    folder : str, optional
        A folder in which the file is saved. If it does not exist in the
        current directory, it is created. Defaults to `None`, in which case
        the file is saved in the current directory.
    note : str, optional
        If not `None`, an additional section &#34;Additional notes:&#34; is written
        in the file, and `note` is written there. 
    &#34;&#34;&#34;
    if save_network:
        self.network.save(folder=folder)
    filename = _internals._format_filename(folder, self.ID, &#39;Configuration&#39;)
    _internals._make_sure_folder_exists(folder)
    with open(filename, &#39;w&#39;, encoding=&#39;utf-8&#39;) as file:
        file.write(str(self))
        if note is not None:
            file.write(&#39;\n\nAdditional notes:\n&#39;)
            file.write(note)</code></pre>
</details>
</dd>
<dt id="popnet.structures.Configuration.set_initial_state_from"><code class="name flex">
<span>def <span class="ident">set_initial_state_from</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the initial state from another configuration.</p>
<p>Set the initial state from another configuration, where the network can
have another number of populations.
- If the other configuration has <em>less</em> populations, only the state
components associated with the first populations will be set.
- If the other configuration has the <em>same</em> number of populations,
the initial state will simply be copied.
- If the other configuration has <em>more</em> populations, the initial
state will be set according to the first populations of the
other configuration.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code><a title="popnet.structures.Configuration" href="#popnet.structures.Configuration">Configuration</a></code></dt>
<dd>Other configuration from which to take the initial state.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>other</code> is not a <code><a title="popnet.structures.Configuration" href="#popnet.structures.Configuration">Configuration</a></code> instance.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_initial_state_from(self, other):
    &#34;&#34;&#34;Set the initial state from another configuration.

    Set the initial state from another configuration, where the network can
    have another number of populations.
        - If the other configuration has *less* populations, only the state
          components associated with the first populations will be set.
        - If the other configuration has the *same* number of populations,
          the initial state will simply be copied.
        - If the other configuration has *more* populations, the initial
          state will be set according to the first populations of the
          other configuration.

    Parameters
    ----------
    other : Configuration
        Other configuration from which to take the initial state.

    Raises
    ------
    TypeError
        If `other` is not a `Configuration` instance.
    &#34;&#34;&#34;
    if not isinstance(other, Configuration):
        raise TypeError(&#39;The initial state can only be copied from another &#39;
                        &#39;\&#39;Configuration\&#39; instance.&#39;)
    sp = len(self.network.populations)
    op = len(other.network.populations)
    if op == sp:
        self.initial_state = other.initial_state
        return
    mp = min(sp, op)
    self.initial_state[:mp] = other.initial_state[:mp]
    self.initial_state[sp:sp+mp] = other.initial_state[op:op+mp]
    def loop(start, step):
        sn, on = start(sp), start(op)
        for j in range(mp):
            self.initial_state[sn : sn + step(mp,j)] = \
                other.initial_state[on : on + step(mp,j)]
            sn, on = sn + step(sp, j), on + step(op, j)
    loop(lambda p: 2*p, lambda p,j: p - j)                    # CAA
    loop(lambda p: 2*p + round(p*(p+1)/2), lambda p,j: p - j) # CRR
    loop(lambda p: 2*p + p*(p+1), lambda p,j: p)              # CAR</code></pre>
</details>
</dd>
<dt id="popnet.structures.Configuration.set_random_initial_state"><code class="name flex">
<span>def <span class="ident">set_random_initial_state</span></span>(<span>self, bound_cov=0.06)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the initial state with random values.</p>
<p>Set the initial state with random values. For each population, the
values for <em>A</em> and <em>R</em> and chosen from uniform distributions in the
triangle <span><span class="MathJax_Preview">\{(x,y) \in [0,1)^2 : x + y &lt; 1\}</span><script type="math/tex">\{(x,y) \in [0,1)^2 : x + y < 1\}</script></span>, using the method
described in [1]. All variances are chosen from uniform distributions
between 0 and <code>bound_cov</code>, and all non-symmetric covariances from
uniform distributions between <code>-bound_cov</code> and <code>bound_cov</code>, regardless
of the values of the expectations. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>bound_cov</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Positive number which sets the distributions of covariances.
Variances are all taken from a uniform distribution between zero and
<code>bound_cov</code>, and non-symmetric covariances are taken from a uniform
distribution between <code>-bound_cov</code> and <code>bound_cov</code>. Defaults to 0.06.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>bound_cov</code> cannot be converted to a float.</dd>
<dt><code>ValueError</code></dt>
<dd>If <code>bound_cov</code> is not a positive number.</dd>
</dl>
<h2 id="references">References</h2>
<ol class="references">
<li>Osada, R., Funkhouser, T., Chazelle, B. &amp; Dobkin, D. “Shape
distributions.” <em>ACM Trans. Graph.</em> <strong>21</strong>, 807&ndash;832 (2002).
doi:<a href="https://doi.org/10.1145/571647.571648">10.1145/571647.571648</a>.</li>
</ol></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_random_initial_state(self, bound_cov=0.06):
    &#34;&#34;&#34;Set the initial state with random values.

    Set the initial state with random values. For each population, the
    values for *A* and *R* and chosen from uniform distributions in the
    triangle \\(\\{(x,y) \\in [0,1)^2 : x + y &lt; 1\\}\\), using the method
    described in [1]. All variances are chosen from uniform distributions
    between 0 and `bound_cov`, and all non-symmetric covariances from
    uniform distributions between `-bound_cov` and `bound_cov`, regardless
    of the values of the expectations. 

    Parameters
    ----------
    bound_cov : float, optional
        Positive number which sets the distributions of covariances.
        Variances are all taken from a uniform distribution between zero and
        `bound_cov`, and non-symmetric covariances are taken from a uniform
        distribution between `-bound_cov` and `bound_cov`. Defaults to 0.06.

    Raises
    ------
    TypeError
        If `bound_cov` cannot be converted to a float.
    ValueError
        If `bound_cov` is not a positive number.

    References
    ----------
     1. Osada, R., Funkhouser, T., Chazelle, B. &amp; Dobkin, D. “Shape
        distributions.” *ACM Trans. Graph.* **21**, 807--832 (2002).
        doi:[10.1145/571647.571648](https://doi.org/10.1145/571647.571648).
    &#34;&#34;&#34;
    p = len(self.network.populations)
    state = np.zeros(p*(2*p+3))
    rng = np.random.default_rng()
    try:
        bound_cov = float(bound_cov)
    except TypeError as error:
        raise TypeError(&#39;The bound to choose covariances should be a &#39;
                        &#39;number.&#39;) from error
    if bound_cov &lt; 0:
        raise ValueError(&#39;The bound to choose covariances should be &#39;
                         &#39;positive.&#39;)
    for J in range(p):
        a, b = rng.random(size=2)
        state[J] = np.sqrt(a) * (1 - b)
        state[p+J] = np.sqrt(a) * b
    state[2*p : p*(p+3)] = bound_cov * rng.random(size=p*(p+1))
    state[p*(p+3) :] = -bound_cov + 2*bound_cov * rng.random(size=p**2)
    self.initial_state = state</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="popnet.structures.ConfigurationOne"><code class="flex name class">
<span>class <span class="ident">ConfigurationOne</span></span>
<span>(</span><span>network, ID=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Extends <code><a title="popnet.structures.Configuration" href="#popnet.structures.Configuration">Configuration</a></code> in the special case of a single population.</p>
<p>Extends the <code><a title="popnet.structures.Configuration" href="#popnet.structures.Configuration">Configuration</a></code> class by adding methods specific to the case of
only one population. The new methods allow to:</p>
<ul>
<li>Verify if a state is in the domain where variables make sense,
physiologically speaking;</li>
<li>Set the initial state randomly in the physiological domain;</li>
<li>Set the input and the initial state to coordinates where there is a fixed
point.</li>
</ul>
<p>The initialization is the same as in the base class, except for a
verification that the network has indeed a single population.</p>
<p>The data attributes are the same as in the base class.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="popnet.exceptions.PopNetError" href="exceptions.html#popnet.exceptions.PopNetError">PopNetError</a></code></dt>
<dd>If the network does not have precisely one population.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConfigurationOne(Configuration):
    &#34;&#34;&#34;Extends `Configuration` in the special case of a single population.

    Extends the `Configuration` class by adding methods specific to the case of 
    only one population. The new methods allow to:

     - Verify if a state is in the domain where variables make sense,
       physiologically speaking;
     - Set the initial state randomly in the physiological domain;
     - Set the input and the initial state to coordinates where there is a fixed
       point.

    The initialization is the same as in the base class, except for a
    verification that the network has indeed a single population.

    The data attributes are the same as in the base class.

    Raises
    ------
    popnet.exceptions.PopNetError
        If the network does not have precisely one population.

    &#34;&#34;&#34;

    def __init__(self, network, ID=None, **kwargs):
        super().__init__(network, ID=ID, **kwargs)
        if network.ID[0] != &#39;1&#39;:
            raise PopNetError(&#39;The subclass ConfigurationOne should be used &#39;
                              &#39;only for configurations where the network has &#39;
                              &#39;indeed one population. The network used here &#39;
                              f&#39;has {network.ID[0]}&#39;)
        self._variables = [&#39;A&#39;, &#39;R&#39;, &#39;CAA&#39;, &#39;CRR&#39;, &#39;CAR&#39;]

    def set_random_initial_state(self, domain=&#39;physiological&#39;, bound_cov=0.06):
        &#34;&#34;&#34;Set the initial state randomly.

        Overrides the corresponding base class method to choose an initial state
        in a given domain. The expectations are always chosen from a uniform
        distribution in the triangle \\(\\{(x,y) \\in [0,1)^2 : x + y &lt; 1\\}\\).

        Parameters
        ----------
        domain : {&#39;physiological&#39;, &#39;bounded&#39;}, optional
            The domain in which the state is chosen. If &#39;physiological&#39;, the
            state is chosen in the so-called physiological domain, where
            expectations and covariances are valid values for the random
            variables they represent. If &#39;bounded&#39;, the base class method is
            called. Defaults to `&#39;physiological&#39;`.
        bound_cov : float, optional
            Positive number which sets the distributions of covariances, in the
            case where `domain` is set to `&#39;bounded&#39;`. See the base class method
            for details. Defaults to 0.06.

        Raises
        ------
        NotImplementedError
            If the requested domain is not valid. 

        See Also
        --------
        Configuration.set_random_initial_state
        &#34;&#34;&#34;
        rng = np.random.default_rng()
        if domain == &#39;physiological&#39;:
            a, b = rng.random(size=2)
            A = np.sqrt(a) * (1 - b)
            R = np.sqrt(a) * b
            CAA = A * (1 - A) * rng.random()
            CRR = R * (1 - R) * rng.random()
            CAR = -np.sqrt(CAA*CRR) + 2*np.sqrt(CAA*CRR) * rng.random()
            new_state = [A, R, CAA, CRR, CAR]
            if self.state_in_domain(new_state, verbose=False):
                self.initial_state = new_state
            else:
                self.set_random_initial_state()
            return
        elif domain == &#39;bounded&#39;:
            super().set_random_initial_state(bound_cov=bound_cov)
            return
        raise NotImplementedError(f&#39;No &#34;{domain}&#34; domain has been implemented &#39;
                                  &#39;yet for the states of a network with a &#39;
                                  &#39;single population.&#39;)

    def set_to_fixed_point(self, form, set_state=True):
        &#34;&#34;&#34;Set the initial state at a fixed point of the extended system.

        Set the input and (possibly) the initial state to coordinates where
        there is a fixed point of form *i*), *ii*) or *iii*) of the extended
        Wilson--Cowan system obtained from the closure that uses a second-order
        Taylor approximation. It is possible to set only the input and not the
        intial state with the `set_state` argument.

        Parameters
        ----------
        form : {&#39;i&#39;, &#39;ii&#39;, &#39;iii&#39;}
            The desired form of fixed point.
        set_state : bool, optional
            Decides if the initial state is set to or near the fixed point.
            Defaults to `True`.

        Raises
        ------
        NotImplementedError
            If `form` is `&#39;i&#39;`. 
        ValueError
            If `form` is neither of `&#39;i&#39;`, `&#39;ii&#39;` or `&#39;iii&#39;`.
        &#34;&#34;&#34;
        pop = self.network.populations[0]
        c = self.network.c[0,0]
        Sigma = pop.alpha/2 + pop.beta + pop.gamma
        Pi = pop.alpha*pop.beta/2 + pop.alpha*pop.gamma/2 + pop.beta*pop.gamma
        if form == &#39;i&#39;:
            raise NotImplementedError(&#39;The coordinates for a form i) fixed &#39;
                                      &#39;point have not been implemented yet.&#39;)
        elif form == &#39;ii&#39;:
            S = 4 * pop.scale_theta * Sigma / (pop.alpha * c)
            A = pop.gamma / (pop.beta + pop.gamma) * (1 - S)
            R = pop.beta  / (pop.beta + pop.gamma) * (1 - S)
            CAR = (2*pop.gamma / (pop.beta+pop.gamma) * (Sigma * Pi - pop.beta
                    * pop.gamma * pop.alpha * c / (4*pop.scale_theta))
                    / ( (pop.alpha + 2*pop.gamma) * 
                        (pop.alpha * c / (4*pop.scale_theta))**2 ))
            CAA = pop.alpha / (2*pop.gamma) * CAR
            CRR = pop.beta / pop.gamma * CAR
            self.Q = pop.theta - c * A
        elif form == &#39;iii&#39;:
            S = 4 * pop.scale_theta * Pi / (pop.gamma * pop.alpha * c)
            A = pop.gamma / (pop.beta + pop.gamma) * (1 - S)
            R = pop.beta  / (pop.beta + pop.gamma) * (1 - S)
            CAR = (pop.beta / pop.gamma * ( Pi**2 - pop.beta*pop.gamma**2
                    * pop.alpha * c / (4*pop.scale_theta) )
                    / ( (pop.beta+pop.gamma)**2 
                        * (pop.alpha * c / (4*pop.scale_theta))**2 ))
            CAA = pop.gamma / pop.beta * CAR
            CRR = pop.beta / pop.gamma * CAR
            self.Q = pop.theta - c * A
        else:
            raise ValueError(&#39;Unknown fixed point form.&#39;)
        if set_state:
            self.initial_state = [A, R, CAA, CRR, CAR]

    def state_in_domain(self, state=None, verbose=False):
        &#34;&#34;&#34;Verify if a state is in the physiological domain.

        Parameters
        ----------
        state : array_like, optional
            The state to verify. Defaults to `None`, in which case the initial
            state is verified.
        verbose : bool, optional
            If `True`, a warning will be issued if the state is not in the
            physiological domain. Defaults to `False`.

        Returns
        -------
        bool
            `True` if the state is in the physiological domain, else `False`.

        Warns
        -----
        popnet.exceptions.PopNetWarning
            If `verbose` is `True` and if the state is not in the physiological
            domain.
        &#34;&#34;&#34;
        if state is None:
            state = self.initial_state
        A = state[0]
        R = state[1]
        S = 1 - A - R
        CAA = state[2]
        CRR = state[3]
        CAR = state[4]
        CSS = CAA + 2*CAR + CRR
        if A &lt; 0 or R &lt; 0 or S &lt; 0:
            ok = False
        elif CAA &gt; A * (1 - A) or CAA &lt; 0:
            ok = False
        elif CRR &gt; R * (1 - R) or CRR &lt; 0:
            ok = False
        elif CSS &gt; S * (1 - S) or CSS &lt; 0:
            ok = False
        elif CAR**2 &gt; CAA * CRR:
            ok = False
        elif CAR &lt; -A*R:
            ok = False
        elif CAR &gt; A*S - CAA:
            ok = False
        elif CAR &gt; R*S - CRR:
            ok = False
        else:
            ok = True
        if not ok and verbose:
            warn(f&#39;The state {state} does not make sense, physiologically &#39;
                 &#39;speaking.&#39;, category=PopNetWarning, stacklevel=2)
        return ok</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="popnet.structures.Configuration" href="#popnet.structures.Configuration">Configuration</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="popnet.structures.MicroConfigurationOne" href="#popnet.structures.MicroConfigurationOne">MicroConfigurationOne</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="popnet.structures.ConfigurationOne.set_random_initial_state"><code class="name flex">
<span>def <span class="ident">set_random_initial_state</span></span>(<span>self, domain='physiological', bound_cov=0.06)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the initial state randomly.</p>
<p>Overrides the corresponding base class method to choose an initial state
in a given domain. The expectations are always chosen from a uniform
distribution in the triangle <span><span class="MathJax_Preview">\{(x,y) \in [0,1)^2 : x + y &lt; 1\}</span><script type="math/tex">\{(x,y) \in [0,1)^2 : x + y < 1\}</script></span>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>domain</code></strong> :&ensp;<code>{'physiological', 'bounded'}</code>, optional</dt>
<dd>The domain in which the state is chosen. If 'physiological', the
state is chosen in the so-called physiological domain, where
expectations and covariances are valid values for the random
variables they represent. If 'bounded', the base class method is
called. Defaults to <code>'physiological'</code>.</dd>
<dt><strong><code>bound_cov</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Positive number which sets the distributions of covariances, in the
case where <code>domain</code> is set to <code>'bounded'</code>. See the base class method
for details. Defaults to 0.06.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NotImplementedError</code></dt>
<dd>If the requested domain is not valid.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code><a title="popnet.structures.Configuration.set_random_initial_state" href="#popnet.structures.Configuration.set_random_initial_state">Configuration.set_random_initial_state()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_random_initial_state(self, domain=&#39;physiological&#39;, bound_cov=0.06):
    &#34;&#34;&#34;Set the initial state randomly.

    Overrides the corresponding base class method to choose an initial state
    in a given domain. The expectations are always chosen from a uniform
    distribution in the triangle \\(\\{(x,y) \\in [0,1)^2 : x + y &lt; 1\\}\\).

    Parameters
    ----------
    domain : {&#39;physiological&#39;, &#39;bounded&#39;}, optional
        The domain in which the state is chosen. If &#39;physiological&#39;, the
        state is chosen in the so-called physiological domain, where
        expectations and covariances are valid values for the random
        variables they represent. If &#39;bounded&#39;, the base class method is
        called. Defaults to `&#39;physiological&#39;`.
    bound_cov : float, optional
        Positive number which sets the distributions of covariances, in the
        case where `domain` is set to `&#39;bounded&#39;`. See the base class method
        for details. Defaults to 0.06.

    Raises
    ------
    NotImplementedError
        If the requested domain is not valid. 

    See Also
    --------
    Configuration.set_random_initial_state
    &#34;&#34;&#34;
    rng = np.random.default_rng()
    if domain == &#39;physiological&#39;:
        a, b = rng.random(size=2)
        A = np.sqrt(a) * (1 - b)
        R = np.sqrt(a) * b
        CAA = A * (1 - A) * rng.random()
        CRR = R * (1 - R) * rng.random()
        CAR = -np.sqrt(CAA*CRR) + 2*np.sqrt(CAA*CRR) * rng.random()
        new_state = [A, R, CAA, CRR, CAR]
        if self.state_in_domain(new_state, verbose=False):
            self.initial_state = new_state
        else:
            self.set_random_initial_state()
        return
    elif domain == &#39;bounded&#39;:
        super().set_random_initial_state(bound_cov=bound_cov)
        return
    raise NotImplementedError(f&#39;No &#34;{domain}&#34; domain has been implemented &#39;
                              &#39;yet for the states of a network with a &#39;
                              &#39;single population.&#39;)</code></pre>
</details>
</dd>
<dt id="popnet.structures.ConfigurationOne.set_to_fixed_point"><code class="name flex">
<span>def <span class="ident">set_to_fixed_point</span></span>(<span>self, form, set_state=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the initial state at a fixed point of the extended system.</p>
<p>Set the input and (possibly) the initial state to coordinates where
there is a fixed point of form <em>i</em>), <em>ii</em>) or <em>iii</em>) of the extended
Wilson&ndash;Cowan system obtained from the closure that uses a second-order
Taylor approximation. It is possible to set only the input and not the
intial state with the <code>set_state</code> argument.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>form</code></strong> :&ensp;<code>{'i', 'ii', 'iii'}</code></dt>
<dd>The desired form of fixed point.</dd>
<dt><strong><code>set_state</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Decides if the initial state is set to or near the fixed point.
Defaults to <code>True</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NotImplementedError</code></dt>
<dd>If <code>form</code> is <code>'i'</code>.</dd>
<dt><code>ValueError</code></dt>
<dd>If <code>form</code> is neither of <code>'i'</code>, <code>'ii'</code> or <code>'iii'</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_to_fixed_point(self, form, set_state=True):
    &#34;&#34;&#34;Set the initial state at a fixed point of the extended system.

    Set the input and (possibly) the initial state to coordinates where
    there is a fixed point of form *i*), *ii*) or *iii*) of the extended
    Wilson--Cowan system obtained from the closure that uses a second-order
    Taylor approximation. It is possible to set only the input and not the
    intial state with the `set_state` argument.

    Parameters
    ----------
    form : {&#39;i&#39;, &#39;ii&#39;, &#39;iii&#39;}
        The desired form of fixed point.
    set_state : bool, optional
        Decides if the initial state is set to or near the fixed point.
        Defaults to `True`.

    Raises
    ------
    NotImplementedError
        If `form` is `&#39;i&#39;`. 
    ValueError
        If `form` is neither of `&#39;i&#39;`, `&#39;ii&#39;` or `&#39;iii&#39;`.
    &#34;&#34;&#34;
    pop = self.network.populations[0]
    c = self.network.c[0,0]
    Sigma = pop.alpha/2 + pop.beta + pop.gamma
    Pi = pop.alpha*pop.beta/2 + pop.alpha*pop.gamma/2 + pop.beta*pop.gamma
    if form == &#39;i&#39;:
        raise NotImplementedError(&#39;The coordinates for a form i) fixed &#39;
                                  &#39;point have not been implemented yet.&#39;)
    elif form == &#39;ii&#39;:
        S = 4 * pop.scale_theta * Sigma / (pop.alpha * c)
        A = pop.gamma / (pop.beta + pop.gamma) * (1 - S)
        R = pop.beta  / (pop.beta + pop.gamma) * (1 - S)
        CAR = (2*pop.gamma / (pop.beta+pop.gamma) * (Sigma * Pi - pop.beta
                * pop.gamma * pop.alpha * c / (4*pop.scale_theta))
                / ( (pop.alpha + 2*pop.gamma) * 
                    (pop.alpha * c / (4*pop.scale_theta))**2 ))
        CAA = pop.alpha / (2*pop.gamma) * CAR
        CRR = pop.beta / pop.gamma * CAR
        self.Q = pop.theta - c * A
    elif form == &#39;iii&#39;:
        S = 4 * pop.scale_theta * Pi / (pop.gamma * pop.alpha * c)
        A = pop.gamma / (pop.beta + pop.gamma) * (1 - S)
        R = pop.beta  / (pop.beta + pop.gamma) * (1 - S)
        CAR = (pop.beta / pop.gamma * ( Pi**2 - pop.beta*pop.gamma**2
                * pop.alpha * c / (4*pop.scale_theta) )
                / ( (pop.beta+pop.gamma)**2 
                    * (pop.alpha * c / (4*pop.scale_theta))**2 ))
        CAA = pop.gamma / pop.beta * CAR
        CRR = pop.beta / pop.gamma * CAR
        self.Q = pop.theta - c * A
    else:
        raise ValueError(&#39;Unknown fixed point form.&#39;)
    if set_state:
        self.initial_state = [A, R, CAA, CRR, CAR]</code></pre>
</details>
</dd>
<dt id="popnet.structures.ConfigurationOne.state_in_domain"><code class="name flex">
<span>def <span class="ident">state_in_domain</span></span>(<span>self, state=None, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Verify if a state is in the physiological domain.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<code>array_like</code>, optional</dt>
<dd>The state to verify. Defaults to <code>None</code>, in which case the initial
state is verified.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If <code>True</code>, a warning will be issued if the state is not in the
physiological domain. Defaults to <code>False</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd><code>True</code> if the state is in the physiological domain, else <code>False</code>.</dd>
</dl>
<h2 id="warns">Warns</h2>
<dl>
<dt><code><a title="popnet.exceptions.PopNetWarning" href="exceptions.html#popnet.exceptions.PopNetWarning">PopNetWarning</a></code></dt>
<dd>If <code>verbose</code> is <code>True</code> and if the state is not in the physiological
domain.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def state_in_domain(self, state=None, verbose=False):
    &#34;&#34;&#34;Verify if a state is in the physiological domain.

    Parameters
    ----------
    state : array_like, optional
        The state to verify. Defaults to `None`, in which case the initial
        state is verified.
    verbose : bool, optional
        If `True`, a warning will be issued if the state is not in the
        physiological domain. Defaults to `False`.

    Returns
    -------
    bool
        `True` if the state is in the physiological domain, else `False`.

    Warns
    -----
    popnet.exceptions.PopNetWarning
        If `verbose` is `True` and if the state is not in the physiological
        domain.
    &#34;&#34;&#34;
    if state is None:
        state = self.initial_state
    A = state[0]
    R = state[1]
    S = 1 - A - R
    CAA = state[2]
    CRR = state[3]
    CAR = state[4]
    CSS = CAA + 2*CAR + CRR
    if A &lt; 0 or R &lt; 0 or S &lt; 0:
        ok = False
    elif CAA &gt; A * (1 - A) or CAA &lt; 0:
        ok = False
    elif CRR &gt; R * (1 - R) or CRR &lt; 0:
        ok = False
    elif CSS &gt; S * (1 - S) or CSS &lt; 0:
        ok = False
    elif CAR**2 &gt; CAA * CRR:
        ok = False
    elif CAR &lt; -A*R:
        ok = False
    elif CAR &gt; A*S - CAA:
        ok = False
    elif CAR &gt; R*S - CRR:
        ok = False
    else:
        ok = True
    if not ok and verbose:
        warn(f&#39;The state {state} does not make sense, physiologically &#39;
             &#39;speaking.&#39;, category=PopNetWarning, stacklevel=2)
    return ok</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="popnet.structures.Configuration" href="#popnet.structures.Configuration">Configuration</a></b></code>:
<ul class="hlist">
<li><code><a title="popnet.structures.Configuration.ID" href="#popnet.structures.Configuration.ID">ID</a></code></li>
<li><code><a title="popnet.structures.Configuration.Q" href="#popnet.structures.Configuration.Q">Q</a></code></li>
<li><code><a title="popnet.structures.Configuration.add_random_uniform_perturbation" href="#popnet.structures.Configuration.add_random_uniform_perturbation">add_random_uniform_perturbation</a></code></li>
<li><code><a title="popnet.structures.Configuration.add_to_initial_state" href="#popnet.structures.Configuration.add_to_initial_state">add_to_initial_state</a></code></li>
<li><code><a title="popnet.structures.Configuration.copy" href="#popnet.structures.Configuration.copy">copy</a></code></li>
<li><code><a title="popnet.structures.Configuration.delta" href="#popnet.structures.Configuration.delta">delta</a></code></li>
<li><code><a title="popnet.structures.Configuration.final_time" href="#popnet.structures.Configuration.final_time">final_time</a></code></li>
<li><code><a title="popnet.structures.Configuration.initial_state" href="#popnet.structures.Configuration.initial_state">initial_state</a></code></li>
<li><code><a title="popnet.structures.Configuration.initial_time" href="#popnet.structures.Configuration.initial_time">initial_time</a></code></li>
<li><code><a title="popnet.structures.Configuration.iterations" href="#popnet.structures.Configuration.iterations">iterations</a></code></li>
<li><code><a title="popnet.structures.Configuration.load" href="#popnet.structures.Configuration.load">load</a></code></li>
<li><code><a title="popnet.structures.Configuration.microscopized" href="#popnet.structures.Configuration.microscopized">microscopized</a></code></li>
<li><code><a title="popnet.structures.Configuration.network" href="#popnet.structures.Configuration.network">network</a></code></li>
<li><code><a title="popnet.structures.Configuration.save" href="#popnet.structures.Configuration.save">save</a></code></li>
<li><code><a title="popnet.structures.Configuration.set_initial_state_from" href="#popnet.structures.Configuration.set_initial_state_from">set_initial_state_from</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="popnet.structures.MicroConfiguration"><code class="flex name class">
<span>class <span class="ident">MicroConfiguration</span></span>
<span>(</span><span>network, ID=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Configurations used in numerical simulations.</p>
<p>The <code><a title="popnet.structures.MicroConfiguration" href="#popnet.structures.MicroConfiguration">MicroConfiguration</a></code> class extends the <code><a title="popnet.structures.Configuration" href="#popnet.structures.Configuration">Configuration</a></code> class to cases
where the microscopic structure of the network is needed to perform
numerical simulations. It adds two new properties:</p>
<ul>
<li><code><a title="popnet.structures.MicroConfiguration.micro_initial_state" href="#popnet.structures.MicroConfiguration.micro_initial_state">MicroConfiguration.micro_initial_state</a></code>, which gives the network's
microscopic initial state;</li>
<li><code><a title="popnet.structures.MicroConfiguration.executions" href="#popnet.structures.MicroConfiguration.executions">MicroConfiguration.executions</a></code>, which gives the number of trajectories
generated when performing simulations in chain.</li>
</ul>
<p>It also provides a method to reset it from the macroscopic initial state,
and another to modify the sizes of the populations of the network while also
updating the network's parameters and the microscopic initial state.</p>
<p>Since this configuration class requires the network to have a microscopic
structure, it has to be initialized from a <code><a title="popnet.structures.MicroNetwork" href="#popnet.structures.MicroNetwork">MicroNetwork</a></code> instance. Besides
that, the initialization is the same as in the base class.</p>
<p>The data attributes are the same as in the base class.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="popnet.exceptions.PopNetError" href="exceptions.html#popnet.exceptions.PopNetError">PopNetError</a></code></dt>
<dd>If the network used is not a <code><a title="popnet.structures.MicroNetwork" href="#popnet.structures.MicroNetwork">MicroNetwork</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MicroConfiguration(Configuration):
    &#34;&#34;&#34;Configurations used in numerical simulations.

    The `MicroConfiguration` class extends the `Configuration` class to cases
    where the microscopic structure of the network is needed to perform
    numerical simulations. It adds two new properties:

     - `MicroConfiguration.micro_initial_state`, which gives the network&#39;s
       microscopic initial state;
     - `MicroConfiguration.executions`, which gives the number of trajectories
       generated when performing simulations in chain.

    It also provides a method to reset it from the macroscopic initial state,
    and another to modify the sizes of the populations of the network while also
    updating the network&#39;s parameters and the microscopic initial state.

    Since this configuration class requires the network to have a microscopic
    structure, it has to be initialized from a `MicroNetwork` instance. Besides
    that, the initialization is the same as in the base class.

    The data attributes are the same as in the base class.

    Raises
    ------
    popnet.exceptions.PopNetError
        If the network used is not a `MicroNetwork`.

    &#34;&#34;&#34;

    def __init__(self, network, ID=None, **kwargs):
        if &#39;executions&#39; in kwargs:
            self.executions = kwargs.pop(&#39;executions&#39;)
        else:
            self.executions = 1
        super().__init__(network, ID=ID, **kwargs)
        if not isinstance(network, MicroNetwork):
            raise PopNetError(&#39;The network used with a \&#39;MicroConfiguration\&#39; &#39;
                              &#39;should be a \&#39;MicroNetwork\&#39;.&#39;)

    @Configuration.initial_state.setter
    def initial_state(self, new_state):
        Configuration.initial_state.fset(self, new_state)
        self.reset_micro_initial_state()

    @property
    def micro_initial_state(self):
        &#34;&#34;&#34;Microscopic initial state of the network.

        States of all neurons of the network. It is always consistent with the
        macrosopic initial state `Configuration.initial_state`, in the sense
        that the microscopic initial state can only be set from macroscopic one.
        For more details on this process, see
        `MicroConfiguration.reset_micro_initial_state`.

        The microscopic initial state cannot be set manually, but it can be
        reset at any time with `MicroConfiguration.reset_micro_initial_state`.
        Note also that when the macroscopic initial state is changed, the
        microscopic one is also reset.
        &#34;&#34;&#34;
        return self._micro_initial_state

    @property
    def executions(self):
        &#34;&#34;&#34;Number of simulations to be done.

        Number of simulations to be performed when doing simulations in chain
        to obtain statistics. It cannot be deleted.
        &#34;&#34;&#34;
        return self._executions

    @executions.setter
    def executions(self, new_number):
        try:
            new_number = int(new_number)
        except TypeError as error:
            raise TypeError(&#39;The number of simulations to be done should be &#39;
                            &#39;a number.&#39;) from error
        if new_number &lt; 0:
            raise ValueError(&#39;The number of simulations to be done has to be &#39;
                             &#39;positive.&#39;)
        self._executions = new_number

    def microscopized(self, sizes, new_ID=None):
        &#34;&#34;&#34;Get a resized microscopic copy of the configuration.

        Return a copy of the configuration where population sizes are given by
        `sizes`.

        Parameters
        ----------
        sizes : list or tuple of int
            Sizes to give to the populations of the network, in the same order
            as in the network&#39;s attribute.
        new_ID : str
            ID to give to the new configuration. Defaults to `None`, in which
            case the configuration&#39;s ID is used.
        &#34;&#34;&#34;
        if new_ID is None:
            new_ID = self.ID
        micro_config = self.copy(new_ID)
        micro_config.resize_network(sizes)
        return micro_config

    def resize_network(self, new_sizes):
        &#34;&#34;&#34;Change the sizes of the network&#39;s populations.

        Change the size of each population of the network, and reset the
        network&#39;s parameters and the microscopic initial state to be consistent
        with this change.

        Parameters
        ----------
        new_sizes : list or tuple of int
            A new size for each population, given in the order prescribed by
            the network&#39;s list of populations.
        &#34;&#34;&#34;
        for pop, new_size in zip(self.network.populations, new_sizes):
            pop.size = new_size
        self.network.reset_parameters()
        self.reset_micro_initial_state()
        
    def reset_micro_initial_state(self):
        &#34;&#34;&#34;Randomly generate a microscopic initial state.
        
        Create a microscopic initial state for the network, consistent with its
        macroscopic initial state. If *J* is a population of the network, each
        neuron of *J* is chosen randomly between the values `1` (active), `1j`
        (refractory) and `0` (sensitive), with probabilities corresponding to
        the active, refractory and sensitive fractions of *J*.
        &#34;&#34;&#34;
        A = self.initial_state[: (p := len(self.network.populations))]
        R = self.initial_state[p : 2*p]
        S = 1 - A - R
        rng = np.random.default_rng()
        self._micro_initial_state = np.concatenate(
                [rng.choice((0.,1.,1j), p=(S[J],A[J],R[J]), size=popJ.size)
                 for J, popJ in enumerate(self.network.populations)])

    def _other_params_string(self):
        &#34;&#34;&#34;Add `executions` to `str(self)`.&#34;&#34;&#34;
        if self.executions == 1:
            return f&#39;{1:&gt;9} execution\n&#39;
        else:
            return f&#39;{self.executions:&gt;9} executions\n&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="popnet.structures.Configuration" href="#popnet.structures.Configuration">Configuration</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="popnet.structures.MicroConfigurationOne" href="#popnet.structures.MicroConfigurationOne">MicroConfigurationOne</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="popnet.structures.MicroConfiguration.executions"><code class="name">var <span class="ident">executions</span></code></dt>
<dd>
<div class="desc"><p>Number of simulations to be done.</p>
<p>Number of simulations to be performed when doing simulations in chain
to obtain statistics. It cannot be deleted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def executions(self):
    &#34;&#34;&#34;Number of simulations to be done.

    Number of simulations to be performed when doing simulations in chain
    to obtain statistics. It cannot be deleted.
    &#34;&#34;&#34;
    return self._executions</code></pre>
</details>
</dd>
<dt id="popnet.structures.MicroConfiguration.micro_initial_state"><code class="name">var <span class="ident">micro_initial_state</span></code></dt>
<dd>
<div class="desc"><p>Microscopic initial state of the network.</p>
<p>States of all neurons of the network. It is always consistent with the
macrosopic initial state <code><a title="popnet.structures.Configuration.initial_state" href="#popnet.structures.Configuration.initial_state">Configuration.initial_state</a></code>, in the sense
that the microscopic initial state can only be set from macroscopic one.
For more details on this process, see
<code><a title="popnet.structures.MicroConfiguration.reset_micro_initial_state" href="#popnet.structures.MicroConfiguration.reset_micro_initial_state">MicroConfiguration.reset_micro_initial_state()</a></code>.</p>
<p>The microscopic initial state cannot be set manually, but it can be
reset at any time with <code><a title="popnet.structures.MicroConfiguration.reset_micro_initial_state" href="#popnet.structures.MicroConfiguration.reset_micro_initial_state">MicroConfiguration.reset_micro_initial_state()</a></code>.
Note also that when the macroscopic initial state is changed, the
microscopic one is also reset.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def micro_initial_state(self):
    &#34;&#34;&#34;Microscopic initial state of the network.

    States of all neurons of the network. It is always consistent with the
    macrosopic initial state `Configuration.initial_state`, in the sense
    that the microscopic initial state can only be set from macroscopic one.
    For more details on this process, see
    `MicroConfiguration.reset_micro_initial_state`.

    The microscopic initial state cannot be set manually, but it can be
    reset at any time with `MicroConfiguration.reset_micro_initial_state`.
    Note also that when the macroscopic initial state is changed, the
    microscopic one is also reset.
    &#34;&#34;&#34;
    return self._micro_initial_state</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="popnet.structures.MicroConfiguration.microscopized"><code class="name flex">
<span>def <span class="ident">microscopized</span></span>(<span>self, sizes, new_ID=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a resized microscopic copy of the configuration.</p>
<p>Return a copy of the configuration where population sizes are given by
<code>sizes</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>sizes</code></strong> :&ensp;<code>list</code> or <code>tuple</code> of <code>int</code></dt>
<dd>Sizes to give to the populations of the network, in the same order
as in the network's attribute.</dd>
<dt><strong><code>new_ID</code></strong> :&ensp;<code>str</code></dt>
<dd>ID to give to the new configuration. Defaults to <code>None</code>, in which
case the configuration's ID is used.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def microscopized(self, sizes, new_ID=None):
    &#34;&#34;&#34;Get a resized microscopic copy of the configuration.

    Return a copy of the configuration where population sizes are given by
    `sizes`.

    Parameters
    ----------
    sizes : list or tuple of int
        Sizes to give to the populations of the network, in the same order
        as in the network&#39;s attribute.
    new_ID : str
        ID to give to the new configuration. Defaults to `None`, in which
        case the configuration&#39;s ID is used.
    &#34;&#34;&#34;
    if new_ID is None:
        new_ID = self.ID
    micro_config = self.copy(new_ID)
    micro_config.resize_network(sizes)
    return micro_config</code></pre>
</details>
</dd>
<dt id="popnet.structures.MicroConfiguration.reset_micro_initial_state"><code class="name flex">
<span>def <span class="ident">reset_micro_initial_state</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Randomly generate a microscopic initial state.</p>
<p>Create a microscopic initial state for the network, consistent with its
macroscopic initial state. If <em>J</em> is a population of the network, each
neuron of <em>J</em> is chosen randomly between the values <code>1</code> (active), <code>1j</code>
(refractory) and <code>0</code> (sensitive), with probabilities corresponding to
the active, refractory and sensitive fractions of <em>J</em>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_micro_initial_state(self):
    &#34;&#34;&#34;Randomly generate a microscopic initial state.
    
    Create a microscopic initial state for the network, consistent with its
    macroscopic initial state. If *J* is a population of the network, each
    neuron of *J* is chosen randomly between the values `1` (active), `1j`
    (refractory) and `0` (sensitive), with probabilities corresponding to
    the active, refractory and sensitive fractions of *J*.
    &#34;&#34;&#34;
    A = self.initial_state[: (p := len(self.network.populations))]
    R = self.initial_state[p : 2*p]
    S = 1 - A - R
    rng = np.random.default_rng()
    self._micro_initial_state = np.concatenate(
            [rng.choice((0.,1.,1j), p=(S[J],A[J],R[J]), size=popJ.size)
             for J, popJ in enumerate(self.network.populations)])</code></pre>
</details>
</dd>
<dt id="popnet.structures.MicroConfiguration.resize_network"><code class="name flex">
<span>def <span class="ident">resize_network</span></span>(<span>self, new_sizes)</span>
</code></dt>
<dd>
<div class="desc"><p>Change the sizes of the network's populations.</p>
<p>Change the size of each population of the network, and reset the
network's parameters and the microscopic initial state to be consistent
with this change.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>new_sizes</code></strong> :&ensp;<code>list</code> or <code>tuple</code> of <code>int</code></dt>
<dd>A new size for each population, given in the order prescribed by
the network's list of populations.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resize_network(self, new_sizes):
    &#34;&#34;&#34;Change the sizes of the network&#39;s populations.

    Change the size of each population of the network, and reset the
    network&#39;s parameters and the microscopic initial state to be consistent
    with this change.

    Parameters
    ----------
    new_sizes : list or tuple of int
        A new size for each population, given in the order prescribed by
        the network&#39;s list of populations.
    &#34;&#34;&#34;
    for pop, new_size in zip(self.network.populations, new_sizes):
        pop.size = new_size
    self.network.reset_parameters()
    self.reset_micro_initial_state()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="popnet.structures.Configuration" href="#popnet.structures.Configuration">Configuration</a></b></code>:
<ul class="hlist">
<li><code><a title="popnet.structures.Configuration.ID" href="#popnet.structures.Configuration.ID">ID</a></code></li>
<li><code><a title="popnet.structures.Configuration.Q" href="#popnet.structures.Configuration.Q">Q</a></code></li>
<li><code><a title="popnet.structures.Configuration.add_random_uniform_perturbation" href="#popnet.structures.Configuration.add_random_uniform_perturbation">add_random_uniform_perturbation</a></code></li>
<li><code><a title="popnet.structures.Configuration.add_to_initial_state" href="#popnet.structures.Configuration.add_to_initial_state">add_to_initial_state</a></code></li>
<li><code><a title="popnet.structures.Configuration.copy" href="#popnet.structures.Configuration.copy">copy</a></code></li>
<li><code><a title="popnet.structures.Configuration.delta" href="#popnet.structures.Configuration.delta">delta</a></code></li>
<li><code><a title="popnet.structures.Configuration.final_time" href="#popnet.structures.Configuration.final_time">final_time</a></code></li>
<li><code><a title="popnet.structures.Configuration.initial_state" href="#popnet.structures.Configuration.initial_state">initial_state</a></code></li>
<li><code><a title="popnet.structures.Configuration.initial_time" href="#popnet.structures.Configuration.initial_time">initial_time</a></code></li>
<li><code><a title="popnet.structures.Configuration.iterations" href="#popnet.structures.Configuration.iterations">iterations</a></code></li>
<li><code><a title="popnet.structures.Configuration.load" href="#popnet.structures.Configuration.load">load</a></code></li>
<li><code><a title="popnet.structures.Configuration.network" href="#popnet.structures.Configuration.network">network</a></code></li>
<li><code><a title="popnet.structures.Configuration.save" href="#popnet.structures.Configuration.save">save</a></code></li>
<li><code><a title="popnet.structures.Configuration.set_initial_state_from" href="#popnet.structures.Configuration.set_initial_state_from">set_initial_state_from</a></code></li>
<li><code><a title="popnet.structures.Configuration.set_random_initial_state" href="#popnet.structures.Configuration.set_random_initial_state">set_random_initial_state</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="popnet.structures.MicroConfigurationOne"><code class="flex name class">
<span>class <span class="ident">MicroConfigurationOne</span></span>
<span>(</span><span>network, ID=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Extends <code><a title="popnet.structures.MicroConfiguration" href="#popnet.structures.MicroConfiguration">MicroConfiguration</a></code> in the special case of a single population.</p>
<p>Combines the features of <code><a title="popnet.structures.ConfigurationOne" href="#popnet.structures.ConfigurationOne">ConfigurationOne</a></code> and <code><a title="popnet.structures.MicroConfiguration" href="#popnet.structures.MicroConfiguration">MicroConfiguration</a></code> in
order to be used for cases where the microscopic structure of a network
containing a single population is needed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MicroConfigurationOne(ConfigurationOne, MicroConfiguration):
    &#34;&#34;&#34;Extends `MicroConfiguration` in the special case of a single population.

    Combines the features of `ConfigurationOne` and `MicroConfiguration` in
    order to be used for cases where the microscopic structure of a network
    containing a single population is needed.

    &#34;&#34;&#34;

    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="popnet.structures.ConfigurationOne" href="#popnet.structures.ConfigurationOne">ConfigurationOne</a></li>
<li><a title="popnet.structures.MicroConfiguration" href="#popnet.structures.MicroConfiguration">MicroConfiguration</a></li>
<li><a title="popnet.structures.Configuration" href="#popnet.structures.Configuration">Configuration</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="popnet.structures.ConfigurationOne" href="#popnet.structures.ConfigurationOne">ConfigurationOne</a></b></code>:
<ul class="hlist">
<li><code><a title="popnet.structures.ConfigurationOne.ID" href="#popnet.structures.Configuration.ID">ID</a></code></li>
<li><code><a title="popnet.structures.ConfigurationOne.Q" href="#popnet.structures.Configuration.Q">Q</a></code></li>
<li><code><a title="popnet.structures.ConfigurationOne.add_random_uniform_perturbation" href="#popnet.structures.Configuration.add_random_uniform_perturbation">add_random_uniform_perturbation</a></code></li>
<li><code><a title="popnet.structures.ConfigurationOne.add_to_initial_state" href="#popnet.structures.Configuration.add_to_initial_state">add_to_initial_state</a></code></li>
<li><code><a title="popnet.structures.ConfigurationOne.copy" href="#popnet.structures.Configuration.copy">copy</a></code></li>
<li><code><a title="popnet.structures.ConfigurationOne.delta" href="#popnet.structures.Configuration.delta">delta</a></code></li>
<li><code><a title="popnet.structures.ConfigurationOne.final_time" href="#popnet.structures.Configuration.final_time">final_time</a></code></li>
<li><code><a title="popnet.structures.ConfigurationOne.initial_state" href="#popnet.structures.Configuration.initial_state">initial_state</a></code></li>
<li><code><a title="popnet.structures.ConfigurationOne.initial_time" href="#popnet.structures.Configuration.initial_time">initial_time</a></code></li>
<li><code><a title="popnet.structures.ConfigurationOne.iterations" href="#popnet.structures.Configuration.iterations">iterations</a></code></li>
<li><code><a title="popnet.structures.ConfigurationOne.load" href="#popnet.structures.Configuration.load">load</a></code></li>
<li><code><a title="popnet.structures.ConfigurationOne.microscopized" href="#popnet.structures.Configuration.microscopized">microscopized</a></code></li>
<li><code><a title="popnet.structures.ConfigurationOne.network" href="#popnet.structures.Configuration.network">network</a></code></li>
<li><code><a title="popnet.structures.ConfigurationOne.save" href="#popnet.structures.Configuration.save">save</a></code></li>
<li><code><a title="popnet.structures.ConfigurationOne.set_initial_state_from" href="#popnet.structures.Configuration.set_initial_state_from">set_initial_state_from</a></code></li>
<li><code><a title="popnet.structures.ConfigurationOne.set_random_initial_state" href="#popnet.structures.ConfigurationOne.set_random_initial_state">set_random_initial_state</a></code></li>
<li><code><a title="popnet.structures.ConfigurationOne.set_to_fixed_point" href="#popnet.structures.ConfigurationOne.set_to_fixed_point">set_to_fixed_point</a></code></li>
<li><code><a title="popnet.structures.ConfigurationOne.state_in_domain" href="#popnet.structures.ConfigurationOne.state_in_domain">state_in_domain</a></code></li>
</ul>
</li>
<li><code><b><a title="popnet.structures.MicroConfiguration" href="#popnet.structures.MicroConfiguration">MicroConfiguration</a></b></code>:
<ul class="hlist">
<li><code><a title="popnet.structures.MicroConfiguration.executions" href="#popnet.structures.MicroConfiguration.executions">executions</a></code></li>
<li><code><a title="popnet.structures.MicroConfiguration.micro_initial_state" href="#popnet.structures.MicroConfiguration.micro_initial_state">micro_initial_state</a></code></li>
<li><code><a title="popnet.structures.MicroConfiguration.reset_micro_initial_state" href="#popnet.structures.MicroConfiguration.reset_micro_initial_state">reset_micro_initial_state</a></code></li>
<li><code><a title="popnet.structures.MicroConfiguration.resize_network" href="#popnet.structures.MicroConfiguration.resize_network">resize_network</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="popnet.structures.MicroNetwork"><code class="flex name class">
<span>class <span class="ident">MicroNetwork</span></span>
<span>(</span><span>ID, populations)</span>
</code></dt>
<dd>
<div class="desc"><p>Represent a biological neural network from a microscopic point of view.</p>
<p>The <code><a title="popnet.structures.MicroNetwork" href="#popnet.structures.MicroNetwork">MicroNetwork</a></code> class extends the <code><a title="popnet.structures.Network" href="#popnet.structures.Network">Network</a></code> class to characterize
individual neurons rather than characterizing only their mean values and
scales by populations. It introduces new attributes to get the values of
transition rates, thresholds and weights of connection for all neurons.</p>
<p>The initialization of a <code><a title="popnet.structures.MicroNetwork" href="#popnet.structures.MicroNetwork">MicroNetwork</a></code> is the same as in the base class,
except that the parameters of individual neurons of the network are also
initialized. Hence, the size of every population of the network must be
defined.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is important to understand that, even if parameters <code>alpha</code>, <code>beta</code>,
<code>gamma</code>, <code>theta</code> and <code>W</code> are generated automatically from the
corresponding mean values and scaling factors at initialization, it does
<em>not</em> mean that they will be updated upon update of the mean values or
scaling factors, or upon change in the size of the network. In order to
remain consistent when new values are set, parameters should be reset
with <code><a title="popnet.structures.MicroNetwork.reset_parameters" href="#popnet.structures.MicroNetwork.reset_parameters">MicroNetwork.reset_parameters()</a></code>.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="popnet.exceptions.PopNetError" href="exceptions.html#popnet.exceptions.PopNetError">PopNetError</a></code></dt>
<dd>If the size of a population is not defined.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MicroNetwork(Network):
    &#34;&#34;&#34;Represent a biological neural network from a microscopic point of view.

    The `MicroNetwork` class extends the `Network` class to characterize
    individual neurons rather than characterizing only their mean values and
    scales by populations. It introduces new attributes to get the values of
    transition rates, thresholds and weights of connection for all neurons.

    The initialization of a `MicroNetwork` is the same as in the base class,
    except that the parameters of individual neurons of the network are also
    initialized. Hence, the size of every population of the network must be
    defined.

    !!! note
        It is important to understand that, even if parameters `alpha`, `beta`,
        `gamma`, `theta` and `W` are generated automatically from the
        corresponding mean values and scaling factors at initialization, it does
        *not* mean that they will be updated upon update of the mean values or
        scaling factors, or upon change in the size of the network. In order to
        remain consistent when new values are set, parameters should be reset
        with `MicroNetwork.reset_parameters`.

    Raises
    ------
    popnet.exceptions.PopNetError
        If the size of a population is not defined.

    &#34;&#34;&#34;

    def __init__(self, ID, populations):
        super().__init__(ID, populations)
        if any(pop.size is None for pop in populations):
            raise PopNetError(&#39;Cannot define a MicroNetwork if the sizes of &#39;
                              &#39;its populations are not defined.&#39;)
        self.reset_parameters()

    @property
    def alpha(self):
        &#34;&#34;&#34;Transition rates from sensitive to active.
        
        Array of transition rates from sensitive to active (with sufficient
        input) of all neurons of the network. It cannot be set nor deleted, but
        it can be reset with `MicroNetwork.reset_parameters`.
        &#34;&#34;&#34;
        return self._alpha

    @property
    def beta(self):
        &#34;&#34;&#34;Transition rates from active to refractory.
        
        Array of transition rates from active to refractory of all neurons of
        the network. It cannot be set nor deleted, but can be reset with
        `MicroNetwork.reset_parameters`.
        &#34;&#34;&#34;
        return self._beta

    @property
    def gamma(self):
        &#34;&#34;&#34;Transition rates from refractory to sensitive.
        
        Array of transition rates from refractory to sensitive of all neurons of
        the network. It cannot be set nor deleted, but can be reset with
        `MicroNetwork.reset_parameters`.
        &#34;&#34;&#34;
        return self._gamma

    @property
    def theta(self):
        &#34;&#34;&#34;Thresholds.
        
        Array of thresholds of all neurons of the network. It cannot be set nor
        deleted, but it can be reset with `MicroNetwork.reset_parameters`.
        &#34;&#34;&#34;
        return self._theta

    @property
    def W(self):
        &#34;&#34;&#34;Weight matrix.
        
        Array of weights of connection between neurons of the network. An
        element `W[j,k]` of `W` is the weight of the connection *from* `k` *to*
        `j`. It has to be a real matrix of shape \\(N \\times N\\), where
        \\(N\\) is the size of the network. It cannot be deleted.
        &#34;&#34;&#34;
        return self._W

    @W.setter
    def W(self, new_value):
        try:
            new_value = np.array(new_value, float)
        except (TypeError, ValueError) as err:
            raise ValueError(&#39;A weight matrix must have real entries.&#39;) from err
        if new_value.shape != (self.size(), self.size()):
            raise PopNetError(&#39;A weight matrix should be square with shape N x &#39;
                              &#39;N, where N is the size of the network.&#39;)
        self._W = new_value

    def reset_parameters(self, params=None):
        &#34;&#34;&#34;Randomly generate the parameters of the network&#39;s neurons.

        Generate the parameters that characterize the neurons of the network.
        All parameters are taken from logistic distributions with means and
        scaling factors consistent with the values given by the populations.
        Since transition rates must be positive, the logistic distributions for
        them are in fact truncated --- see the
        [Notes](micronetwork-reset-parameters-notes) section below.

        Parameters
        ----------
        params : list or tuple of str or str, optional
            Parameters to be reset. It should contain only valid parameters
            (`&#39;alpha&#39;`, `&#39;beta&#39;`, `&#39;gamma&#39;`, `&#39;theta&#39;` or `&#39;W&#39;`), or be a single
            parameter given as a string. Defaults to `None`, in which case all
            parameters are reset.

        Raises
        ------
        TypeError
            If `params` is neither a list, a tuple nor a string.
        PopNetError
            If an entry of `params` is not a valid population parameter.

        Notes {#micronetwork-reset-parameters-notes}
        -----
        All transition rates `alpha`, `beta` and `gamma` should always be
        positive. Hence, when taking samples from logistic distributions to
        get individual values for these pararameters for all neurons of the
        network, we actually truncate the logistic distributions by rejecting
        all negative values and replacing them with other samples.
        &#34;&#34;&#34;
        valid_params = (&#39;alpha&#39;, &#39;beta&#39;, &#39;gamma&#39;, &#39;theta&#39;, &#39;W&#39;)
        if params is None:
            params = valid_params
        if isinstance(params, str):
            params = (params,)
        if not isinstance(params, (list, tuple)):
            raise TypeError(&#39;\&#39;params\&#39; should be a list, tuple or string.&#39;)
        if any(param not in valid_params for param in params):
            raise PopNetError(f&#39;An entry in {params} is not a valid population &#39;
                              &#39;parameter.&#39;)
        rng = np.random.default_rng()

        def sample_rate(rng, mean, scale, size):
            sample = rng.logistic(mean, scale, size=size)
            nsteps = 0
            while np.any(sample &lt; 0) or nsteps &gt; 100:
                sample = np.where(sample &lt; 0, rng.logistic(mean, scale), sample)
                nsteps += 1
            return sample

        if &#39;alpha&#39; in params:
            self._alpha = np.concatenate(
                        [sample_rate(rng, pop.alpha, pop.scale_alpha, pop.size)
                         for pop in self.populations])
        if &#39;beta&#39; in params:
            self._beta  = np.concatenate(
                        [sample_rate(rng, pop.beta, pop.scale_beta, pop.size)
                         for pop in self.populations])
        if &#39;gamma&#39; in params:
            self._gamma = np.concatenate(
                        [sample_rate(rng, pop.gamma, pop.scale_gamma, pop.size)
                         for pop in self.populations])
        if &#39;theta&#39; in params:
            self._theta = np.concatenate(
                        [rng.logistic(pop.theta, pop.scale_theta, size=pop.size)
                         for pop in self.populations])
        if &#39;W&#39; in params:
            self._W = np.block([[rng.logistic(
                                    self.c[J,K]/popK.size,
                                    self.scale_c[J,K]/popK.size,
                                    size=(popJ.size, popK.size)) 
                                for K, popK in enumerate(self.populations)] 
                                for J, popJ in enumerate(self.populations)])

    def size(self):
        &#34;&#34;&#34;Get the size of the network.&#34;&#34;&#34;
        return np.sum([pop.size for pop in self.populations])

    @property
    def underlying(self):
        raise AttributeError(&#39;\&#39;MicroNetwork\&#39; object has no attribute &#39;
                             &#39;\&#39;underlying\&#39;&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="popnet.structures.Network" href="#popnet.structures.Network">Network</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="popnet.structures.MicroNetwork.W"><code class="name">var <span class="ident">W</span></code></dt>
<dd>
<div class="desc"><p>Weight matrix.</p>
<p>Array of weights of connection between neurons of the network. An
element <code>W[j,k]</code> of <code>W</code> is the weight of the connection <em>from</em> <code>k</code> <em>to</em>
<code>j</code>. It has to be a real matrix of shape <span><span class="MathJax_Preview">N \times N</span><script type="math/tex">N \times N</script></span>, where
<span><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span> is the size of the network. It cannot be deleted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def W(self):
    &#34;&#34;&#34;Weight matrix.
    
    Array of weights of connection between neurons of the network. An
    element `W[j,k]` of `W` is the weight of the connection *from* `k` *to*
    `j`. It has to be a real matrix of shape \\(N \\times N\\), where
    \\(N\\) is the size of the network. It cannot be deleted.
    &#34;&#34;&#34;
    return self._W</code></pre>
</details>
</dd>
<dt id="popnet.structures.MicroNetwork.alpha"><code class="name">var <span class="ident">alpha</span></code></dt>
<dd>
<div class="desc"><p>Transition rates from sensitive to active.</p>
<p>Array of transition rates from sensitive to active (with sufficient
input) of all neurons of the network. It cannot be set nor deleted, but
it can be reset with <code><a title="popnet.structures.MicroNetwork.reset_parameters" href="#popnet.structures.MicroNetwork.reset_parameters">MicroNetwork.reset_parameters()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def alpha(self):
    &#34;&#34;&#34;Transition rates from sensitive to active.
    
    Array of transition rates from sensitive to active (with sufficient
    input) of all neurons of the network. It cannot be set nor deleted, but
    it can be reset with `MicroNetwork.reset_parameters`.
    &#34;&#34;&#34;
    return self._alpha</code></pre>
</details>
</dd>
<dt id="popnet.structures.MicroNetwork.beta"><code class="name">var <span class="ident">beta</span></code></dt>
<dd>
<div class="desc"><p>Transition rates from active to refractory.</p>
<p>Array of transition rates from active to refractory of all neurons of
the network. It cannot be set nor deleted, but can be reset with
<code><a title="popnet.structures.MicroNetwork.reset_parameters" href="#popnet.structures.MicroNetwork.reset_parameters">MicroNetwork.reset_parameters()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def beta(self):
    &#34;&#34;&#34;Transition rates from active to refractory.
    
    Array of transition rates from active to refractory of all neurons of
    the network. It cannot be set nor deleted, but can be reset with
    `MicroNetwork.reset_parameters`.
    &#34;&#34;&#34;
    return self._beta</code></pre>
</details>
</dd>
<dt id="popnet.structures.MicroNetwork.gamma"><code class="name">var <span class="ident">gamma</span></code></dt>
<dd>
<div class="desc"><p>Transition rates from refractory to sensitive.</p>
<p>Array of transition rates from refractory to sensitive of all neurons of
the network. It cannot be set nor deleted, but can be reset with
<code><a title="popnet.structures.MicroNetwork.reset_parameters" href="#popnet.structures.MicroNetwork.reset_parameters">MicroNetwork.reset_parameters()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def gamma(self):
    &#34;&#34;&#34;Transition rates from refractory to sensitive.
    
    Array of transition rates from refractory to sensitive of all neurons of
    the network. It cannot be set nor deleted, but can be reset with
    `MicroNetwork.reset_parameters`.
    &#34;&#34;&#34;
    return self._gamma</code></pre>
</details>
</dd>
<dt id="popnet.structures.MicroNetwork.theta"><code class="name">var <span class="ident">theta</span></code></dt>
<dd>
<div class="desc"><p>Thresholds.</p>
<p>Array of thresholds of all neurons of the network. It cannot be set nor
deleted, but it can be reset with <code><a title="popnet.structures.MicroNetwork.reset_parameters" href="#popnet.structures.MicroNetwork.reset_parameters">MicroNetwork.reset_parameters()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def theta(self):
    &#34;&#34;&#34;Thresholds.
    
    Array of thresholds of all neurons of the network. It cannot be set nor
    deleted, but it can be reset with `MicroNetwork.reset_parameters`.
    &#34;&#34;&#34;
    return self._theta</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="popnet.structures.MicroNetwork.reset_parameters"><code class="name flex">
<span>def <span class="ident">reset_parameters</span></span>(<span>self, params=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Randomly generate the parameters of the network's neurons.</p>
<p>Generate the parameters that characterize the neurons of the network.
All parameters are taken from logistic distributions with means and
scaling factors consistent with the values given by the populations.
Since transition rates must be positive, the logistic distributions for
them are in fact truncated &mdash; see the
<a href="micronetwork-reset-parameters-notes">Notes</a> section below.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>list</code> or <code>tuple</code> of <code>str</code> or <code>str</code>, optional</dt>
<dd>Parameters to be reset. It should contain only valid parameters
(<code>'alpha'</code>, <code>'beta'</code>, <code>'gamma'</code>, <code>'theta'</code> or <code>'W'</code>), or be a single
parameter given as a string. Defaults to <code>None</code>, in which case all
parameters are reset.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>params</code> is neither a list, a tuple nor a string.</dd>
<dt><code>PopNetError</code></dt>
<dd>If an entry of <code>params</code> is not a valid population parameter.</dd>
</dl>
<h2 id="micronetwork-reset-parameters-notes">Notes</h2>
<p>All transition rates <code>alpha</code>, <code>beta</code> and <code>gamma</code> should always be
positive. Hence, when taking samples from logistic distributions to
get individual values for these pararameters for all neurons of the
network, we actually truncate the logistic distributions by rejecting
all negative values and replacing them with other samples.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_parameters(self, params=None):
    &#34;&#34;&#34;Randomly generate the parameters of the network&#39;s neurons.

    Generate the parameters that characterize the neurons of the network.
    All parameters are taken from logistic distributions with means and
    scaling factors consistent with the values given by the populations.
    Since transition rates must be positive, the logistic distributions for
    them are in fact truncated --- see the
    [Notes](micronetwork-reset-parameters-notes) section below.

    Parameters
    ----------
    params : list or tuple of str or str, optional
        Parameters to be reset. It should contain only valid parameters
        (`&#39;alpha&#39;`, `&#39;beta&#39;`, `&#39;gamma&#39;`, `&#39;theta&#39;` or `&#39;W&#39;`), or be a single
        parameter given as a string. Defaults to `None`, in which case all
        parameters are reset.

    Raises
    ------
    TypeError
        If `params` is neither a list, a tuple nor a string.
    PopNetError
        If an entry of `params` is not a valid population parameter.

    Notes {#micronetwork-reset-parameters-notes}
    -----
    All transition rates `alpha`, `beta` and `gamma` should always be
    positive. Hence, when taking samples from logistic distributions to
    get individual values for these pararameters for all neurons of the
    network, we actually truncate the logistic distributions by rejecting
    all negative values and replacing them with other samples.
    &#34;&#34;&#34;
    valid_params = (&#39;alpha&#39;, &#39;beta&#39;, &#39;gamma&#39;, &#39;theta&#39;, &#39;W&#39;)
    if params is None:
        params = valid_params
    if isinstance(params, str):
        params = (params,)
    if not isinstance(params, (list, tuple)):
        raise TypeError(&#39;\&#39;params\&#39; should be a list, tuple or string.&#39;)
    if any(param not in valid_params for param in params):
        raise PopNetError(f&#39;An entry in {params} is not a valid population &#39;
                          &#39;parameter.&#39;)
    rng = np.random.default_rng()

    def sample_rate(rng, mean, scale, size):
        sample = rng.logistic(mean, scale, size=size)
        nsteps = 0
        while np.any(sample &lt; 0) or nsteps &gt; 100:
            sample = np.where(sample &lt; 0, rng.logistic(mean, scale), sample)
            nsteps += 1
        return sample

    if &#39;alpha&#39; in params:
        self._alpha = np.concatenate(
                    [sample_rate(rng, pop.alpha, pop.scale_alpha, pop.size)
                     for pop in self.populations])
    if &#39;beta&#39; in params:
        self._beta  = np.concatenate(
                    [sample_rate(rng, pop.beta, pop.scale_beta, pop.size)
                     for pop in self.populations])
    if &#39;gamma&#39; in params:
        self._gamma = np.concatenate(
                    [sample_rate(rng, pop.gamma, pop.scale_gamma, pop.size)
                     for pop in self.populations])
    if &#39;theta&#39; in params:
        self._theta = np.concatenate(
                    [rng.logistic(pop.theta, pop.scale_theta, size=pop.size)
                     for pop in self.populations])
    if &#39;W&#39; in params:
        self._W = np.block([[rng.logistic(
                                self.c[J,K]/popK.size,
                                self.scale_c[J,K]/popK.size,
                                size=(popJ.size, popK.size)) 
                            for K, popK in enumerate(self.populations)] 
                            for J, popJ in enumerate(self.populations)])</code></pre>
</details>
</dd>
<dt id="popnet.structures.MicroNetwork.size"><code class="name flex">
<span>def <span class="ident">size</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the size of the network.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def size(self):
    &#34;&#34;&#34;Get the size of the network.&#34;&#34;&#34;
    return np.sum([pop.size for pop in self.populations])</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="popnet.structures.Network" href="#popnet.structures.Network">Network</a></b></code>:
<ul class="hlist">
<li><code><a title="popnet.structures.Network.ID" href="#popnet.structures.Network.ID">ID</a></code></li>
<li><code><a title="popnet.structures.Network.c" href="#popnet.structures.Network.c">c</a></code></li>
<li><code><a title="popnet.structures.Network.copy" href="#popnet.structures.Network.copy">copy</a></code></li>
<li><code><a title="popnet.structures.Network.extend" href="#popnet.structures.Network.extend">extend</a></code></li>
<li><code><a title="popnet.structures.Network.load" href="#popnet.structures.Network.load">load</a></code></li>
<li><code><a title="popnet.structures.Network.populations" href="#popnet.structures.Network.populations">populations</a></code></li>
<li><code><a title="popnet.structures.Network.save" href="#popnet.structures.Network.save">save</a></code></li>
<li><code><a title="popnet.structures.Network.scale_c" href="#popnet.structures.Network.scale_c">scale_c</a></code></li>
<li><code><a title="popnet.structures.Network.set_random_c" href="#popnet.structures.Network.set_random_c">set_random_c</a></code></li>
<li><code><a title="popnet.structures.Network.underlying" href="#popnet.structures.Network.underlying">underlying</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="popnet.structures.Network"><code class="flex name class">
<span>class <span class="ident">Network</span></span>
<span>(</span><span>ID, populations)</span>
</code></dt>
<dd>
<div class="desc"><p>Represent a biological neural network from a macroscopic point of view.</p>
<p>Represents a biological neural network split into different populations.
Each population of such a network is expected to be a <code><a title="popnet.structures.Population" href="#popnet.structures.Population">Population</a></code> instance.
The purpose of this class is to have a consistent interface to define,
modify, save, or load the parameters of a network.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ID</code></strong> :&ensp;<code>str</code></dt>
<dd>ID of the network.</dd>
<dt><strong><code>populations</code></strong> :&ensp;<code>tuple</code> of <code><a title="popnet.structures.Population" href="#popnet.structures.Population">Population</a>,</code> or <code><a title="popnet.structures.Population" href="#popnet.structures.Population">Population</a></code></dt>
<dd>Defines the populations that constitute the network. Can be given as a
<code><a title="popnet.structures.Population" href="#popnet.structures.Population">Population</a></code> instance to make a network with a single population.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>ID</code></strong> :&ensp;<code>str</code></dt>
<dd>ID of the network. See <code><a title="popnet.structures.Network.ID" href="#popnet.structures.Network.ID">Network.ID</a></code>.</dd>
<dt><strong><code>populations</code></strong> :&ensp;<code>tuple</code> of <code><a title="popnet.structures.Population" href="#popnet.structures.Population">Population</a></code></dt>
<dd>Populations of the network. See <code><a title="popnet.structures.Network.populations" href="#popnet.structures.Network.populations">Network.populations</a></code>.</dd>
<dt><strong><code>c</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Connection matrix. See <code><a title="popnet.structures.Network.c" href="#popnet.structures.Network.c">Network.c</a></code>.</dd>
<dt><strong><code>scale_c</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Scale of connection weights. See <code><a title="popnet.structures.Network.scale_c" href="#popnet.structures.Network.scale_c">Network.scale_c</a></code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>populations</code> cannot be converted to a tuple of <code><a title="popnet.structures.Population" href="#popnet.structures.Population">Population</a></code>
instances.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Network:
    &#34;&#34;&#34;Represent a biological neural network from a macroscopic point of view.

    Represents a biological neural network split into different populations.
    Each population of such a network is expected to be a `Population` instance.
    The purpose of this class is to have a consistent interface to define,
    modify, save, or load the parameters of a network.

    Parameters
    ----------
    ID : str
        ID of the network.
    populations : tuple of Population, or Population
        Defines the populations that constitute the network. Can be given as a
        `Population` instance to make a network with a single population. 

    Attributes
    ----------
    ID : str
        ID of the network. See `Network.ID`.
    populations : tuple of Population
        Populations of the network. See `Network.populations`.
    c : array_like
        Connection matrix. See `Network.c`.
    scale_c : array_like
        Scale of connection weights. See `Network.scale_c`.

    Raises
    ------
    TypeError
        If `populations` cannot be converted to a tuple of `Population`
        instances.

    &#34;&#34;&#34;

    def __init__(self, ID, populations):
        try:
            self._populations = tuple(populations)
        except TypeError:
            self._populations = (populations,)
        if not all(isinstance(pop, Population) for pop in self._populations):
            raise TypeError(&#39;The &#34;populations&#34; attribute of a Network instance &#39;
                            &#39;should be a tuple of Population instances.&#39;)
        self.ID = ID
        self.c = np.ones((p := len(self.populations), p))
        self.scale_c = np.zeros((p, p))

    def __str__(self):
        string = f&#39;Network {self.ID}\n\n&#39;
        for pop in self.populations:
            string += str(pop)
            string += &#39;\n\n&#39;
        string += f&#39;Connection matrix:\n{self.c}&#39;
        return string

    @staticmethod
    def load(load_ID, new_ID=None, folder=None):
        &#34;&#34;&#34;Alias for `load_network`.&#34;&#34;&#34;
        return load_network(load_ID, new_ID=new_ID, folder=folder)

    @property
    def ID(self):
        &#34;&#34;&#34;ID of the network.

        ID given to the network. Its first character has to be the number of
        populations of the network, else an error is raised when setting it.
        The ID is used to name files when saving the network parameters.
        &#34;&#34;&#34;
        return self._ID

    @ID.setter
    def ID(self, new_ID):
        if not isinstance(new_ID, str):
            raise TypeError(&#39;The network\&#39;s ID should be a string.&#39;)
        if int(new_ID[0]) != len(self.populations):
            raise PopNetError(&#39;The first character of the network\&#39;s ID should &#39;
                              &#39;be its number of populations.&#39;)
        self._ID = new_ID

    @property
    def populations(self):
        &#34;&#34;&#34;Populations of the network.

        Tuple containing the populations of the network, given as `Population`
        instances. It is set at initialization, but it cannot be reset nor
        deleted afterwards.
        &#34;&#34;&#34;
        return self._populations

    @property
    def c(self):
        &#34;&#34;&#34;Connection matrix of the network.

        Describes the weights of connections between populations of the network.
        The exact relation to the weights of links between individual neurons of
        the network is described in the [Notes](#network-c-notes) section below.
        It has to be a square matrix, but it can be given as a float if the
        network has only one population.

        Notes {#network-c-notes}
        -----
        For clarity, let *J* and *K* be the *j*th and *k*th populations of the
        network respectively, following the order given in the `populations`
        attribute. Then, the element `c[j,k]` of `c` describes the link *from K
        to J*. From the microscopic point of view, it is the product of the size
        of *K* with the mean value of the weights of links from neurons of *K*
        to neurons of *J*. 
        &#34;&#34;&#34;
        return self._c

    @c.setter
    def c(self, new_c):
        try:
            float_new_c = float(new_c)
        except:
            pass
        else:
            new_c = np.array([[float_new_c]])
        if np.shape(new_c) != (p := len(self.populations), p):
            raise PopNetError(&#39;The connection matrix c should be a square &#39;
                              &#39;array whose size corresponds to the number of &#39;
                              &#39;populations of the network.&#39;)
        self._c = np.array(new_c, float)

    @property
    def scale_c(self):
        &#34;&#34;&#34;Scaling factor of the weights&#39; distributions.

        Scaling factors used to define the weights&#39; distributions, which are all
        assumed to be logistic. The exact relation to the weights of links
        between individual neurons of the network is described in the
        [Notes](#network-scale-c-notes) section below. It has to be a square
        matrix, but it can be given as a float if the network has only one
        population.

        Notes {#network-scale-c-notes}
        -----
        If *J* and *K* are respectively the *j*th and the *k*th populations of
        the network, following the order given in the `populations` attribute,
        the actual scaling factor of the *non-zero* weights of links from
        neurons of *K* to neurons of *J* is

        \\[ \\frac{ s_{JK} P_{JK} }{ |K| } \\]

        where \\(s_{JK}\\) is `scale_c[j,k]`, \\(P_{JK}\\) is the probability of
        connection from neurons of *J* to neurons of *K*, and \\(|K|\\) is the
        size of *K*. 
        &#34;&#34;&#34;
        return self._scale_c

    @scale_c.setter
    def scale_c(self, new_scale):
        try:
            float_new_scale = float(new_scale)
        except:
            pass
        else:
            new_scale = np.array([[float_new_scale]])
        if np.shape(new_scale) != (p := len(self.populations), p):
            raise PopNetError(&#39;The scales of the weights should be a square &#39;
                              &#39;array whose size corresponds to the number of &#39;
                              &#39;populations of the network.&#39;)
        self._scale_c = np.array(new_scale, float)

    def copy(self, new_ID):
        &#34;&#34;&#34;Copy the network.

        Return a copy of the network with a new ID. 

        Parameters
        ----------
        new_ID : str
            ID to give to the new network.

        Returns
        -------
        Network
            The copied network.
        &#34;&#34;&#34;
        other = deepcopy(self)
        other.ID = new_ID
        return other

    def extend(self, ID):
        &#34;&#34;&#34;Extend the network.

        Return an extension of the present network, that is, return a new
        network with the same populations and the same connexions, but with
        more populations as well.

        The new network will have the number of populations given by the first
        character of `ID`. This number should be higher than the number of
        populations of the present network. If it is equal, a copy of the
        network is simply returned.

        Note that the resulting network never has a microscopic structure,
        since the new populations will be defined with no sizes.
        
        Parameters
        ----------
        ID : str
            ID of the new network. Its first character will give the number of
            populations of the new network.

        Raises
        ------
        popnet.exceptions.PopNetError
            If the network is asked to be extended into a smaller network.
        &#34;&#34;&#34;
        new_p = int(ID[0])
        p = len(self.populations)
        if new_p &lt; p:
            raise PopNetError(&#39;Can\&#39;t extend a network into a smaller one.&#39;)
        if new_p == p:
            return self.copy()
        pops = [pop.copy(pop.name) for pop in self.populations]
        for j in range(p, new_p):
            pops.append(Population(f&#39;Population {j+1}&#39;))
        net = Network(ID, pops)
        net.c[:p,:p] = self.c
        net.scale_c[:p,:p] = self.scale_c
        return net

    def save(self, folder=None, note=None):
        &#34;&#34;&#34;Save the network&#39;s parameters in a text file.

        Save the string representation of the network in a text file, under the
        name *ID - Network parameters.txt*, where *ID* is the `ID` attribute.

        Parameters
        ----------
        folder : str, optional
            A folder in which the file is saved. If it does not exist in the
            current directory, it is created. Defaults to `None`, in which case
            the file is saved in the current directory.
        note : str, optional
            If given, an additional section &#34;Additional notes:&#34; is written in
            the file, and `note` is written there. 
        &#34;&#34;&#34;
        filename = _internals._format_filename(folder, self.ID, 
                                               &#39;Network parameters&#39;)
        _internals._make_sure_folder_exists(folder)
        with open(filename, &#39;w&#39;, encoding=&#39;utf-8&#39;) as file:
            file.write(str(self))
            if note is not None:
                file.write(&#39;\n\nAdditional notes:\n&#39;)
                file.write(note)

    def set_random_c(self, distribution=&#39;uniform&#39;, signs=None, **kwargs):
        &#34;&#34;&#34;Randomly set the connection matrix. 

        Choose random values for entries of the connection matrix from a given
        distribution family with given parameters. The random value is generated
        using a [`Generator`](https://tinyurl.com/numpy-random-generator)
        instance from NumPy&#39;s `random` module, and keyword arguments can be
        passed to the `Generator`&#39;s method used to generate the random values.

        Parameters
        ----------
        distribution : {&#39;uniform&#39;, &#39;exponential&#39;}, optional
            The distribution family used to choose a value for the threshold. If
            a positive distribution is chosen, the signs of the components of
            `c` are supposed to be fixed by `signs`. Defaults to `&#39;uniform&#39;`. 
        signs : array_like, optional
            A matrix that multiplies the random results. It is intended to be
            used to assign specific signs to the components of `c`. It should be
            a square matrix of -1&#39;s and 1&#39;s of the same shape as `c`. Defaults
            to `None`, in which case it is replaced by an array of ones.
        **kwargs
            Keyword arguments to be passed to the method of `Generator` 
            corresponding to the correct distribution family. 

        Raises
        ------
        NotImplementedError
            If the requested distribution family is not implemented. 
        &#34;&#34;&#34;
        shape = (p := len(self.populations), p)
        if signs is None:
            signs = np.ones(shape)
        else:
            signs = np.array(signs, float)
        rng = np.random.default_rng()
        if distribution == &#39;uniform&#39;:
            self.c = signs * rng.uniform(size=shape, **kwargs)
            return
        elif distribution == &#39;exponential&#39;:
            self.c = signs * rng.exponential(size=shape, **kwargs)
            return
        raise NotImplementedError(f&#39;No {distribution} distribution available &#39;
                                  &#39;to randomly set a connection matrix.&#39;)

    def underlying(self):
        &#34;&#34;&#34;Get the microscopic network underlying the present macroscopic one.

        Return the microscopic network underlying the present macroscopic
        network of populations. The returned network has the same ID, the same
        populations and the same parameters as the present one.

        Returns
        -------
        MicroNetwork
            The underlying microscopic network.
        &#34;&#34;&#34;
        microself = MicroNetwork(self.ID, self.populations)
        microself.c = self.c
        microself.scale_c = self.scale_c
        microself.reset_parameters()
        return microself

    def _set_c_from_string(self, string):
        &#34;&#34;&#34;Set the connection matrix from a string.

        Set the connection matrix `c` from a string.

        Parameters
        ----------
        string : str
            String from which the connection matrix is set. It should have the
            format of a string representation of a NumPy array. 

        Raises
        ------
        FormatError
            If the string does not have the correct format. 
        &#34;&#34;&#34;
        if string[-1] == &#39;\n&#39;:
            string = string[:-1]
        string = re.sub(r&#39;\[\s+&#39;, &#39;[&#39;, string)
        string = re.sub(r&#39;\s+\]&#39;, &#39;]&#39;, string)
        string = re.sub(r&#39;\s+&#39;, &#39;,&#39;, string)
        try:
            new_c = ast.literal_eval(string)
        except:
            raise FormatError(&#39;It seems that the string cannot be converted &#39;
                              &#39;to a connection matrix.&#39;)
        self.c = new_c</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="popnet.structures.MicroNetwork" href="#popnet.structures.MicroNetwork">MicroNetwork</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="popnet.structures.Network.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>load_ID, new_ID=None, folder=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for <code><a title="popnet.structures.load_network" href="#popnet.structures.load_network">load_network()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(load_ID, new_ID=None, folder=None):
    &#34;&#34;&#34;Alias for `load_network`.&#34;&#34;&#34;
    return load_network(load_ID, new_ID=new_ID, folder=folder)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="popnet.structures.Network.ID"><code class="name">var <span class="ident">ID</span></code></dt>
<dd>
<div class="desc"><p>ID of the network.</p>
<p>ID given to the network. Its first character has to be the number of
populations of the network, else an error is raised when setting it.
The ID is used to name files when saving the network parameters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ID(self):
    &#34;&#34;&#34;ID of the network.

    ID given to the network. Its first character has to be the number of
    populations of the network, else an error is raised when setting it.
    The ID is used to name files when saving the network parameters.
    &#34;&#34;&#34;
    return self._ID</code></pre>
</details>
</dd>
<dt id="popnet.structures.Network.c"><code class="name">var <span class="ident">c</span></code></dt>
<dd>
<div class="desc"><p>Connection matrix of the network.</p>
<p>Describes the weights of connections between populations of the network.
The exact relation to the weights of links between individual neurons of
the network is described in the <a href="#network-c-notes">Notes</a> section below.
It has to be a square matrix, but it can be given as a float if the
network has only one population.</p>
<h2 id="network-c-notes">Notes</h2>
<p>For clarity, let <em>J</em> and <em>K</em> be the <em>j</em>th and <em>k</em>th populations of the
network respectively, following the order given in the <code>populations</code>
attribute. Then, the element <code>c[j,k]</code> of <code>c</code> describes the link <em>from K
to J</em>. From the microscopic point of view, it is the product of the size
of <em>K</em> with the mean value of the weights of links from neurons of <em>K</em>
to neurons of <em>J</em>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def c(self):
    &#34;&#34;&#34;Connection matrix of the network.

    Describes the weights of connections between populations of the network.
    The exact relation to the weights of links between individual neurons of
    the network is described in the [Notes](#network-c-notes) section below.
    It has to be a square matrix, but it can be given as a float if the
    network has only one population.

    Notes {#network-c-notes}
    -----
    For clarity, let *J* and *K* be the *j*th and *k*th populations of the
    network respectively, following the order given in the `populations`
    attribute. Then, the element `c[j,k]` of `c` describes the link *from K
    to J*. From the microscopic point of view, it is the product of the size
    of *K* with the mean value of the weights of links from neurons of *K*
    to neurons of *J*. 
    &#34;&#34;&#34;
    return self._c</code></pre>
</details>
</dd>
<dt id="popnet.structures.Network.populations"><code class="name">var <span class="ident">populations</span></code></dt>
<dd>
<div class="desc"><p>Populations of the network.</p>
<p>Tuple containing the populations of the network, given as <code><a title="popnet.structures.Population" href="#popnet.structures.Population">Population</a></code>
instances. It is set at initialization, but it cannot be reset nor
deleted afterwards.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def populations(self):
    &#34;&#34;&#34;Populations of the network.

    Tuple containing the populations of the network, given as `Population`
    instances. It is set at initialization, but it cannot be reset nor
    deleted afterwards.
    &#34;&#34;&#34;
    return self._populations</code></pre>
</details>
</dd>
<dt id="popnet.structures.Network.scale_c"><code class="name">var <span class="ident">scale_c</span></code></dt>
<dd>
<div class="desc"><p>Scaling factor of the weights' distributions.</p>
<p>Scaling factors used to define the weights' distributions, which are all
assumed to be logistic. The exact relation to the weights of links
between individual neurons of the network is described in the
<a href="#network-scale-c-notes">Notes</a> section below. It has to be a square
matrix, but it can be given as a float if the network has only one
population.</p>
<h2 id="network-scale-c-notes">Notes</h2>
<p>If <em>J</em> and <em>K</em> are respectively the <em>j</em>th and the <em>k</em>th populations of
the network, following the order given in the <code>populations</code> attribute,
the actual scaling factor of the <em>non-zero</em> weights of links from
neurons of <em>K</em> to neurons of <em>J</em> is</p>
<p><span><span class="MathJax_Preview"> \frac{ s_{JK} P_{JK} }{ |K| } </span><script type="math/tex; mode=display"> \frac{ s_{JK} P_{JK} }{ |K| } </script></span></p>
<p>where <span><span class="MathJax_Preview">s_{JK}</span><script type="math/tex">s_{JK}</script></span> is <code>scale_c[j,k]</code>, <span><span class="MathJax_Preview">P_{JK}</span><script type="math/tex">P_{JK}</script></span> is the probability of
connection from neurons of <em>J</em> to neurons of <em>K</em>, and <span><span class="MathJax_Preview">|K|</span><script type="math/tex">|K|</script></span> is the
size of <em>K</em>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def scale_c(self):
    &#34;&#34;&#34;Scaling factor of the weights&#39; distributions.

    Scaling factors used to define the weights&#39; distributions, which are all
    assumed to be logistic. The exact relation to the weights of links
    between individual neurons of the network is described in the
    [Notes](#network-scale-c-notes) section below. It has to be a square
    matrix, but it can be given as a float if the network has only one
    population.

    Notes {#network-scale-c-notes}
    -----
    If *J* and *K* are respectively the *j*th and the *k*th populations of
    the network, following the order given in the `populations` attribute,
    the actual scaling factor of the *non-zero* weights of links from
    neurons of *K* to neurons of *J* is

    \\[ \\frac{ s_{JK} P_{JK} }{ |K| } \\]

    where \\(s_{JK}\\) is `scale_c[j,k]`, \\(P_{JK}\\) is the probability of
    connection from neurons of *J* to neurons of *K*, and \\(|K|\\) is the
    size of *K*. 
    &#34;&#34;&#34;
    return self._scale_c</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="popnet.structures.Network.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, new_ID)</span>
</code></dt>
<dd>
<div class="desc"><p>Copy the network.</p>
<p>Return a copy of the network with a new ID. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>new_ID</code></strong> :&ensp;<code>str</code></dt>
<dd>ID to give to the new network.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="popnet.structures.Network" href="#popnet.structures.Network">Network</a></code></dt>
<dd>The copied network.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self, new_ID):
    &#34;&#34;&#34;Copy the network.

    Return a copy of the network with a new ID. 

    Parameters
    ----------
    new_ID : str
        ID to give to the new network.

    Returns
    -------
    Network
        The copied network.
    &#34;&#34;&#34;
    other = deepcopy(self)
    other.ID = new_ID
    return other</code></pre>
</details>
</dd>
<dt id="popnet.structures.Network.extend"><code class="name flex">
<span>def <span class="ident">extend</span></span>(<span>self, ID)</span>
</code></dt>
<dd>
<div class="desc"><p>Extend the network.</p>
<p>Return an extension of the present network, that is, return a new
network with the same populations and the same connexions, but with
more populations as well.</p>
<p>The new network will have the number of populations given by the first
character of <code>ID</code>. This number should be higher than the number of
populations of the present network. If it is equal, a copy of the
network is simply returned.</p>
<p>Note that the resulting network never has a microscopic structure,
since the new populations will be defined with no sizes.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ID</code></strong> :&ensp;<code>str</code></dt>
<dd>ID of the new network. Its first character will give the number of
populations of the new network.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="popnet.exceptions.PopNetError" href="exceptions.html#popnet.exceptions.PopNetError">PopNetError</a></code></dt>
<dd>If the network is asked to be extended into a smaller network.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extend(self, ID):
    &#34;&#34;&#34;Extend the network.

    Return an extension of the present network, that is, return a new
    network with the same populations and the same connexions, but with
    more populations as well.

    The new network will have the number of populations given by the first
    character of `ID`. This number should be higher than the number of
    populations of the present network. If it is equal, a copy of the
    network is simply returned.

    Note that the resulting network never has a microscopic structure,
    since the new populations will be defined with no sizes.
    
    Parameters
    ----------
    ID : str
        ID of the new network. Its first character will give the number of
        populations of the new network.

    Raises
    ------
    popnet.exceptions.PopNetError
        If the network is asked to be extended into a smaller network.
    &#34;&#34;&#34;
    new_p = int(ID[0])
    p = len(self.populations)
    if new_p &lt; p:
        raise PopNetError(&#39;Can\&#39;t extend a network into a smaller one.&#39;)
    if new_p == p:
        return self.copy()
    pops = [pop.copy(pop.name) for pop in self.populations]
    for j in range(p, new_p):
        pops.append(Population(f&#39;Population {j+1}&#39;))
    net = Network(ID, pops)
    net.c[:p,:p] = self.c
    net.scale_c[:p,:p] = self.scale_c
    return net</code></pre>
</details>
</dd>
<dt id="popnet.structures.Network.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, folder=None, note=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Save the network's parameters in a text file.</p>
<p>Save the string representation of the network in a text file, under the
name <em>ID - Network parameters.txt</em>, where <em>ID</em> is the <code>ID</code> attribute.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>folder</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>A folder in which the file is saved. If it does not exist in the
current directory, it is created. Defaults to <code>None</code>, in which case
the file is saved in the current directory.</dd>
<dt><strong><code>note</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>If given, an additional section "Additional notes:" is written in
the file, and <code>note</code> is written there.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, folder=None, note=None):
    &#34;&#34;&#34;Save the network&#39;s parameters in a text file.

    Save the string representation of the network in a text file, under the
    name *ID - Network parameters.txt*, where *ID* is the `ID` attribute.

    Parameters
    ----------
    folder : str, optional
        A folder in which the file is saved. If it does not exist in the
        current directory, it is created. Defaults to `None`, in which case
        the file is saved in the current directory.
    note : str, optional
        If given, an additional section &#34;Additional notes:&#34; is written in
        the file, and `note` is written there. 
    &#34;&#34;&#34;
    filename = _internals._format_filename(folder, self.ID, 
                                           &#39;Network parameters&#39;)
    _internals._make_sure_folder_exists(folder)
    with open(filename, &#39;w&#39;, encoding=&#39;utf-8&#39;) as file:
        file.write(str(self))
        if note is not None:
            file.write(&#39;\n\nAdditional notes:\n&#39;)
            file.write(note)</code></pre>
</details>
</dd>
<dt id="popnet.structures.Network.set_random_c"><code class="name flex">
<span>def <span class="ident">set_random_c</span></span>(<span>self, distribution='uniform', signs=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Randomly set the connection matrix. </p>
<p>Choose random values for entries of the connection matrix from a given
distribution family with given parameters. The random value is generated
using a <a href="https://tinyurl.com/numpy-random-generator"><code>Generator</code></a>
instance from NumPy's <code>random</code> module, and keyword arguments can be
passed to the <code>Generator</code>'s method used to generate the random values.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>distribution</code></strong> :&ensp;<code>{'uniform', 'exponential'}</code>, optional</dt>
<dd>The distribution family used to choose a value for the threshold. If
a positive distribution is chosen, the signs of the components of
<code>c</code> are supposed to be fixed by <code>signs</code>. Defaults to <code>'uniform'</code>.</dd>
<dt><strong><code>signs</code></strong> :&ensp;<code>array_like</code>, optional</dt>
<dd>A matrix that multiplies the random results. It is intended to be
used to assign specific signs to the components of <code>c</code>. It should be
a square matrix of -1's and 1's of the same shape as <code>c</code>. Defaults
to <code>None</code>, in which case it is replaced by an array of ones.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments to be passed to the method of <code>Generator</code>
corresponding to the correct distribution family.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NotImplementedError</code></dt>
<dd>If the requested distribution family is not implemented.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_random_c(self, distribution=&#39;uniform&#39;, signs=None, **kwargs):
    &#34;&#34;&#34;Randomly set the connection matrix. 

    Choose random values for entries of the connection matrix from a given
    distribution family with given parameters. The random value is generated
    using a [`Generator`](https://tinyurl.com/numpy-random-generator)
    instance from NumPy&#39;s `random` module, and keyword arguments can be
    passed to the `Generator`&#39;s method used to generate the random values.

    Parameters
    ----------
    distribution : {&#39;uniform&#39;, &#39;exponential&#39;}, optional
        The distribution family used to choose a value for the threshold. If
        a positive distribution is chosen, the signs of the components of
        `c` are supposed to be fixed by `signs`. Defaults to `&#39;uniform&#39;`. 
    signs : array_like, optional
        A matrix that multiplies the random results. It is intended to be
        used to assign specific signs to the components of `c`. It should be
        a square matrix of -1&#39;s and 1&#39;s of the same shape as `c`. Defaults
        to `None`, in which case it is replaced by an array of ones.
    **kwargs
        Keyword arguments to be passed to the method of `Generator` 
        corresponding to the correct distribution family. 

    Raises
    ------
    NotImplementedError
        If the requested distribution family is not implemented. 
    &#34;&#34;&#34;
    shape = (p := len(self.populations), p)
    if signs is None:
        signs = np.ones(shape)
    else:
        signs = np.array(signs, float)
    rng = np.random.default_rng()
    if distribution == &#39;uniform&#39;:
        self.c = signs * rng.uniform(size=shape, **kwargs)
        return
    elif distribution == &#39;exponential&#39;:
        self.c = signs * rng.exponential(size=shape, **kwargs)
        return
    raise NotImplementedError(f&#39;No {distribution} distribution available &#39;
                              &#39;to randomly set a connection matrix.&#39;)</code></pre>
</details>
</dd>
<dt id="popnet.structures.Network.underlying"><code class="name flex">
<span>def <span class="ident">underlying</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the microscopic network underlying the present macroscopic one.</p>
<p>Return the microscopic network underlying the present macroscopic
network of populations. The returned network has the same ID, the same
populations and the same parameters as the present one.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="popnet.structures.MicroNetwork" href="#popnet.structures.MicroNetwork">MicroNetwork</a></code></dt>
<dd>The underlying microscopic network.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def underlying(self):
    &#34;&#34;&#34;Get the microscopic network underlying the present macroscopic one.

    Return the microscopic network underlying the present macroscopic
    network of populations. The returned network has the same ID, the same
    populations and the same parameters as the present one.

    Returns
    -------
    MicroNetwork
        The underlying microscopic network.
    &#34;&#34;&#34;
    microself = MicroNetwork(self.ID, self.populations)
    microself.c = self.c
    microself.scale_c = self.scale_c
    microself.reset_parameters()
    return microself</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="popnet.structures.Population"><code class="flex name class">
<span>class <span class="ident">Population</span></span>
<span>(</span><span>name, ID=None, size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represent a population of biological neurons.</p>
<p>This class is used to describe a population of biological neurons. It allows
to easily attribute parameters, such as the threshold and the transition
rates, to the same population. Its methods allow to change easily the values
of these parameters. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the population.</dd>
<dt><strong><code>ID</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>ID of the population. It must be a single character. If it is not
given, the last character of <code>name</code> is used if it is a number, and
else the first one is used.</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of neurons of the population. It must be positive. Defaults to
<code>None</code>, in which case no size is defined for the population.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name given to the population. See <code><a title="popnet.structures.Population.name" href="#popnet.structures.Population.name">Population.name</a></code>.</dd>
<dt><strong><code>ID</code></strong> :&ensp;<code>str</code></dt>
<dd>ID of the population. See <code><a title="popnet.structures.Population.ID" href="#popnet.structures.Population.ID">Population.ID</a></code>.</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>int</code></dt>
<dd>Size of the population. See <code><a title="popnet.structures.Population.size" href="#popnet.structures.Population.size">Population.size</a></code>.</dd>
<dt><strong><code>alpha</code></strong> :&ensp;<code>float</code></dt>
<dd>Mean transition rate from sensitive to active. See <code><a title="popnet.structures.Population.alpha" href="#popnet.structures.Population.alpha">Population.alpha</a></code>.</dd>
<dt><strong><code>beta</code></strong> :&ensp;<code>float</code></dt>
<dd>Mean transition rate from active to refractory. See <code><a title="popnet.structures.Population.beta" href="#popnet.structures.Population.beta">Population.beta</a></code>.</dd>
<dt><strong><code>gamma</code></strong> :&ensp;<code>float</code></dt>
<dd>Mean transition rate from refractory to sensitive. See
<code><a title="popnet.structures.Population.gamma" href="#popnet.structures.Population.gamma">Population.gamma</a></code>.</dd>
<dt><strong><code>theta</code></strong> :&ensp;<code>float</code></dt>
<dd>Mean threshold. See <code><a title="popnet.structures.Population.theta" href="#popnet.structures.Population.theta">Population.theta</a></code>.</dd>
<dt><strong><code>scale_alpha</code></strong> :&ensp;<code>float</code></dt>
<dd>Scale of transition rates from sensitive to active. See
<code><a title="popnet.structures.Population.scale_alpha" href="#popnet.structures.Population.scale_alpha">Population.scale_alpha</a></code>.</dd>
<dt><strong><code>scale_beta</code></strong> :&ensp;<code>float</code></dt>
<dd>Scale of transition rates from active to refractory. See
<code><a title="popnet.structures.Population.scale_beta" href="#popnet.structures.Population.scale_beta">Population.scale_beta</a></code>.</dd>
<dt><strong><code>scale_gamma</code></strong> :&ensp;<code>float</code></dt>
<dd>Scale of transition rates from refractory to sensitive. See
<code><a title="popnet.structures.Population.scale_gamma" href="#popnet.structures.Population.scale_gamma">Population.scale_gamma</a></code>.</dd>
<dt><strong><code>scale_theta</code></strong> :&ensp;<code>float</code></dt>
<dd>Scale of thresholds. See <code><a title="popnet.structures.Population.scale_theta" href="#popnet.structures.Population.scale_theta">Population.scale_theta</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Population:
    &#34;&#34;&#34;Represent a population of biological neurons.

    This class is used to describe a population of biological neurons. It allows
    to easily attribute parameters, such as the threshold and the transition
    rates, to the same population. Its methods allow to change easily the values
    of these parameters. 

    Parameters
    ----------
    name : str
        Name of the population.
    ID : str, optional
        ID of the population. It must be a single character. If it is not
        given, the last character of `name` is used if it is a number, and
        else the first one is used.
    size : int, optional
        Number of neurons of the population. It must be positive. Defaults to
        `None`, in which case no size is defined for the population.

    Attributes
    ----------
    name : str
        Name given to the population. See `Population.name`.
    ID : str
        ID of the population. See `Population.ID`.
    size : int
        Size of the population. See `Population.size`.
    alpha : float
        Mean transition rate from sensitive to active. See `Population.alpha`.
    beta : float
        Mean transition rate from active to refractory. See `Population.beta`.
    gamma : float
        Mean transition rate from refractory to sensitive. See
        `Population.gamma`.
    theta : float
        Mean threshold. See `Population.theta`.
    scale_alpha : float
        Scale of transition rates from sensitive to active. See
        `Population.scale_alpha`.
    scale_beta : float
        Scale of transition rates from active to refractory. See
        `Population.scale_beta`.
    scale_gamma : float
        Scale of transition rates from refractory to sensitive. See
        `Population.scale_gamma`.
    scale_theta : float
        Scale of thresholds. See `Population.scale_theta`.

    &#34;&#34;&#34;

    def __init__(self, name, ID=None, size=None):
        self.name = name
        if ID is None:
            ID = self._default_ID()
        self.ID = ID
        self.size = size

        self._means = {&#39;alpha&#39;: 1., &#39;beta&#39;: 1., &#39;gamma&#39;: 1., &#39;theta&#39;: 0.}
        self._scales = {&#39;alpha&#39;: 0., &#39;beta&#39;: 0., &#39;gamma&#39;: 0., &#39;theta&#39;: 1.}
        self._update_means()
        self._update_scales()

    def __str__(self):
        string = f&#39;{self.name}&#39;
        if self.size is not None:
            string += f&#39; - {self.size} neurons&#39;
        for mean in self._means:
            string += f&#39;\n{mean:&gt;11} = {self._means[mean]}&#39;
        for scale in self._scales:
            scale_name = &#39;scale &#39; + str(scale)
            string += f&#39;\n{scale_name:&gt;11} = {self._scales[scale]}&#39;
        return string

    @property
    def name(self):
        &#34;&#34;&#34;Name of the population. 

        Name given to the population to identify it in a network. It has to be
        a string. When setting a new name, if the population&#39;s ID was the
        default one, then the ID is updated according to the new name. 

        A population&#39;s name should never contain the string &#34; - &#34;, because this
        could lead to unexpected behavior when saving and loading data. An error
        will be raised if a name containing this string is set.
        &#34;&#34;&#34;
        return self._name

    @name.setter
    def name(self, new_name):
        if not isinstance(new_name, str):
            raise TypeError(&#39;A population\&#39;s name must be a string.&#39;)
        try:
            assert self.ID == self._default_ID()
        except (AttributeError, AssertionError):
            pass
        else:
            self.ID = self._default_ID(new_name)
        if &#39; - &#39; in new_name:
            raise PopNetError(&#39;A population\&#39;s name cannot contain the string &#39;
                              &#39;\&#39; - \&#39;.&#39;)
        self._name = new_name

    @property
    def ID(self):
        &#34;&#34;&#34;ID of the population. 

        ID given to the population. It must be a single character, else an
        error is raised when setting it. The ID is used as a subscript to
        identify state variables. 
        &#34;&#34;&#34;
        return self._ID

    @ID.setter
    def ID(self, new_ID):
        if len(str(new_ID)) != 1:
            raise PopNetError(&#39;A population\&#39;s ID must be a single character.&#39;)
        self._ID = str(new_ID)

    @property
    def size(self):
        &#34;&#34;&#34;Number of neurons in the population. 

        Number of neurons in the population. When it is defined, it must be a
        positive integer.
        &#34;&#34;&#34;
        return self._size

    @size.setter
    def size(self, new_value):
        if new_value is None:
            self._size = None
            return
        try:
            new_value = int(new_value)
        except TypeError as error:
            raise TypeError(&#39;A population\&#39;s size must be a number.&#39;) from error
        else:
            if not new_value &gt; 0:
                raise ValueError(&#39;A population\&#39;s size must be positive.&#39;)
        self._size = new_value

    @property
    def alpha(self):
        &#34;&#34;&#34;Mean `alpha` transition rate in the population.

        Mean value of the transition rates from sensitive to active (with
        sufficient input) in the population. 
        &#34;&#34;&#34;
        return self._alpha

    @alpha.setter
    def alpha(self, new_value):
        self._means[&#39;alpha&#39;] = float(new_value)
        self._alpha = float(new_value)

    @property
    def beta(self):
        &#34;&#34;&#34;Mean `beta` transition rate in the population.

        Mean value of the transition rates from active to refractory in the
        population.
        &#34;&#34;&#34;
        return self._beta

    @beta.setter
    def beta(self, new_value):
        self._means[&#39;beta&#39;] = float(new_value)
        self._beta = float(new_value)

    @property
    def gamma(self):
        &#34;&#34;&#34;Mean `gamma` transition rate in the population.

        Mean value of the transition rates from refractory to sensitive in the
        population. 
        &#34;&#34;&#34;
        return self._gamma

    @gamma.setter
    def gamma(self, new_value):
        self._means[&#39;gamma&#39;] = float(new_value)
        self._gamma = float(new_value)

    @property
    def theta(self):
        &#34;&#34;&#34;Mean threshold in the population. 

        Mean value of the thresholds of activation in the population. 
        &#34;&#34;&#34;
        return self._theta

    @theta.setter
    def theta(self, new_value):
        self._means[&#39;theta&#39;] = float(new_value)
        self._theta = float(new_value)

    @property
    def scale_alpha(self):
        &#34;&#34;&#34;Scaling factor of the `alpha` transition rate in the population.

        Scaling factor of the distribution of the transition rates from
        sensitive to active (with sufficient input) in the population, which is
        assumed to be a logistic distribution.
        &#34;&#34;&#34;
        return self._scale_alpha

    @scale_alpha.setter
    def scale_alpha(self, new_value):
        self._scales[&#39;alpha&#39;] = float(new_value)
        self._scale_alpha = float(new_value)

    @property
    def scale_beta(self):
        &#34;&#34;&#34;Scaling factor of the `beta` transition rate in the population.

        Scaling factor of the distribution of the transition rates from
        active to refractory in the population, which is assumed to be a
        logistic distribution.
        &#34;&#34;&#34;
        return self._scale_beta

    @scale_beta.setter
    def scale_beta(self, new_value):
        self._scales[&#39;beta&#39;] = float(new_value)
        self._scale_beta = float(new_value)

    @property
    def scale_gamma(self):
        &#34;&#34;&#34;Scaling factor of the `gamma` transition rate in the population.

        Scaling factor of the distribution of the transition rates from
        refractory to sensitive in the population, which is assumed to be a
        logistic distribution. 
        &#34;&#34;&#34;
        return self._scale_gamma

    @scale_gamma.setter
    def scale_gamma(self, new_value):
        self._scales[&#39;gamma&#39;] = float(new_value)
        self._scale_gamma = float(new_value)

    @property
    def scale_theta(self):
        &#34;&#34;&#34;Scaling factor of the thresholds in the population.

        Scaling factor of the distribution of the thresholds in the population,
        which is assumed to be a logistic distribution.
        &#34;&#34;&#34;
        return self._scale_theta

    @scale_theta.setter
    def scale_theta(self, new_value):
        self._scales[&#39;theta&#39;] = float(new_value)
        self._scale_theta = float(new_value)

    def copy(self, name, ID=None):
        &#34;&#34;&#34;Copy the population.

        Return a copy of the population with a new name and ID.

        Parameters
        ----------
        name : str
            Name to give to the new population.
        ID : str, optional
            ID to give to the new population. Defaults to `None`, in which case
            a default one is taken from the name.

        Returns
        -------
        Population
            The copied population.
        &#34;&#34;&#34;
        other = deepcopy(self)
        other.name = name
        if ID is None:
            ID = other._default_ID()
        other.ID = ID
        return other

    def F(self, y):
        &#34;&#34;&#34;Cumulative distribution function of the thresholds.

        Cumulative distribution function (CDF) of the thresholds in the
        population, assuming they follow a logistic distribution of mean `theta`
        and of scale factor `scale_theta`. 
        &#34;&#34;&#34;
        return expit((y - self.theta) / self.scale_theta)

    def dF(self, y):
        &#34;&#34;&#34;First derivative of the thresholds&#39; CDF. See `Population.F`.&#34;&#34;&#34;
        return 1 / self.scale_theta * self.F(y) * (1 - self.F(y))

    def ddF(self, y):
        &#34;&#34;&#34;Second derivative of the thresholds&#39; CDF. See `Population.F`.&#34;&#34;&#34;
        return 1 / self.scale_theta**2 * ( 
                                self.F(y) * (1 - self.F(y)) * (1 - 2*self.F(y)))

    def dddF(self, y):
        &#34;&#34;&#34;Third derivative of the thresholds&#39; CDF. See `Population.F`.&#34;&#34;&#34;
        return 1 / self.scale_theta**3 * (
               self.F(y) * (1 - self.F(y)) * (1 - 6*self.F(y) + 6*self.F(y)**2))

    def Finv(self, y):
        &#34;&#34;&#34;Inverse of the thresholds&#39; CDF. See `Population.F`.&#34;&#34;&#34;
        return self.theta + self.scale_theta * logit(y)

    def g(self, x, y):
        &#34;&#34;&#34;Scale factor added to `F` to define `G`.&#34;&#34;&#34;
        return np.where(x == self.theta, y / (4 * self.scale_theta**2),
                        (y / (2 * (self.theta - x) * self.scale_theta)
                                * (1 - 2*self.F(x))))

    def G(self, x, y):
        &#34;&#34;&#34;Rescaled cumulative distribution function of the thresholds.&#34;&#34;&#34;
        return self.F((x + self.theta * self.g(x,y)) / (1 + self.g(x,y)))

    def H(self, X, S, B, CXS, CXB, CSB, VarB):
        &#34;&#34;&#34;Approximation of the covariance between *X* and *SF(B)*.

        Function used to approximate the covariance between *X* and *SF(B)* in
        terms of the expectations and covariances of *X*, *S* and *B* and of the
        variance of *B*. Here *F* is `Population.F`. This method is mainly
        intended to be used in the dynamical system for the extended
        Wilson--Cowan model.
        &#34;&#34;&#34;
        return np.where(S == 0, 0, 
                        np.where(X == 0, 0,
                                 ((X*S + CXS) * self.G(B + CSB/S + CXB/X, VarB)
                                    - X*S * self.G(B + CSB/S, VarB))))

    def set_means(self, **new_values):
        &#34;&#34;&#34;Set the means of population parameters.

        Assign new values to some of the means of the population&#39;s parameters:
        `alpha`, `beta`, `gamma` and `theta`.

        Parameters
        ----------
        **new_values
            New values to assign to means of valid population parameters. 

        Raises
        ------
        KeyError
            If non-valid parameters are requested.
        &#34;&#34;&#34;
        for key in new_values:
            if key not in self._means:
                raise KeyError(f&#39;{key} is not a valid population parameter.&#39;)
            self._means[key] = float(new_values[key])
        self._update_means()

    def set_random_rates(self, rates=None, distribution=&#39;exponential&#39;, **kwargs):
        &#34;&#34;&#34;Randomly set the transition rates from a given distribution.

        Choose a random value for the transition rates from a given distribution
        family with given parameters. The random value is generated using a
        [`Generator`](https://tinyurl.com/numpy-random-generator) instance from
        NumPy&#39;s `random` module, and keyword arguments can be passed to the
        `Generator`&#39;s method used to generate the random values.

        Parameters
        ----------
        rates : list or tuple of str, or str, optional
            The transition rates that should be chosen randomly. It should
            contain valid rates in `alpha`, `beta` or `gamma`, or be one of
            these strings. 
        distribution : {&#39;uniform&#39;, &#39;exponential&#39;}, optional
            The distribution family used to choose a value for the rates.
            Defaults to `&#39;uniform&#39;`. 
        **kwargs
            Keyword arguments to be passed to the method of `Generator`
            corresponding to the correct distribution family. 

        Raises
        ------
        TypeError
            If `rates` is not a list, tuple, or str.
        KeyError
            If the strings given in `rates` are not valid transition rates.
        NotImplementedError
            If the requested distribution family is not implemented.
        &#34;&#34;&#34;
        if rates is None:
            rates = [&#39;alpha&#39;, &#39;beta&#39;, &#39;gamma&#39;]
        if isinstance(rates, str):
            rates = [rates]
        if not isinstance(rates, (list, tuple)):
            raise TypeError(&#39;Population.set_random_rates expects its first &#39;
                            &#39;argument to be either a list of rates given as &#39;
                            &#39;strings, or a single rate given as a string.&#39;)
        for rate in rates:
            if rate not in [&#39;alpha&#39;, &#39;beta&#39;, &#39;gamma&#39;]:
                raise KeyError(f&#39;{rate} is not a valid transition rate.&#39;)
            rng = np.random.default_rng()
            if distribution == &#39;uniform&#39;:
                self._means[rate] = rng.uniform(**kwargs)
                continue
            elif distribution == &#39;exponential&#39;:
                self._means[rate] = rng.exponential(**kwargs)
                continue
            raise NotImplementedError(f&#39;No {distribution} distribution available&#39;
                                      &#39; to randomly set a transition rate.&#39;)
        self._update_means()

    def set_random_threshold(self, distribution=&#39;uniform&#39;, **kwargs):
        &#34;&#34;&#34;Randomly set the threshold from a given distribution.

        Choose a random value for the threshold from a given distribution family
        with given parameters. The random value is generated using a
        [`Generator`](https://tinyurl.com/numpy-random-generator) instance from
        NumPy&#39;s `random` module, and keyword arguments can be passed to the
        `Generator`&#39;s method used to generate the random values.

        Parameters
        ----------
        distribution : {&#39;uniform&#39;}, optional
            The distribution family used to choose a value for the threshold.
            Defaults to `&#39;uniform&#39;`, which is for now the only implemented
            distribution. 
        **kwargs
            Keyword arguments to be passed to the method of `Generator`
            corresponding to the correct distribution family. 

        Raises
        ------
        NotImplementedError
            If the requested distribution family is not implemented. 
        &#34;&#34;&#34;
        if distribution == &#39;uniform&#39;:
            self.theta = np.random.default_rng().uniform(**kwargs)
            return
        raise NotImplementedError(f&#39;No {distribution} distribution available &#39;
                                  &#39;to randomly set a threshold.&#39;)

    def set_scales(self, **new_values):
        &#34;&#34;&#34;Set the scales of population parameters.

        Assign new values to some of the scales of the population&#39;s parameters:
        `alpha`, `beta`, `gamma` and `theta`.

        Parameters
        ----------
        **new_values
            New values to assign to scales of valid population parameters. 

        Raises
        ------
        KeyError
            If non-valid parameters are requested.
        &#34;&#34;&#34;
        for key in new_values:
            if key not in self._scales:
                raise KeyError(f&#39;{key} is not a valid population parameter.&#39;)
            self._scales[key] = float(new_values[key])
        self._update_scales()

    def _default_ID(self, name=None):
        &#34;&#34;&#34;Get a default ID based on `name`.

        Get a default ID based on the name `name`. If `name` ends with a number,
        this number is returned. Else, the first letter of `name` is returned.

        Parameters
        ----------
        name : str, optional
            Name from which to get an ID. Defaults to `None`, in which case the
            `name` attribute is used instead.

        Returns
        -------
        str
            The said default ID.
        &#34;&#34;&#34;
        if name is None:
            name = self.name
        assert isinstance(name, str), &#39;\&#39;name\&#39; argument should be a string.&#39;
        try:
            no = int(name[-1])
        except:
            return name[0]
        else:
            return str(no)

    @classmethod
    def _load(cls, lines):
        &#34;&#34;&#34;Load a population.

        Load a population&#39;s parameters from a list of strings, which should be
        the lines of a string representation of a `Population` instance.

        Parameters
        ----------
        lines : list of str
            Strings from which the parameters are to be set. It should be the
            lines of a string representation of a `Population` instance.

        Returns
        -------
        Population
            The loaded population.

        Raises
        ------
        KeyError
            If `string` contains assignments to non-valid parameters.
        popnet.exceptions.FormatError
            If `string` does not have the expected format. 
        &#34;&#34;&#34;
        lines = [line.replace(&#39;\n&#39;, &#39;&#39;) for line in lines]
        name_line = lines[0].split(&#39; - &#39;)
        pop = Population(name_line[0].strip())
        if len(name_line) == 2:
            try:
                pop.size = name_line[-1].strip().split()[0]
            except ValueError as error:
                raise PopNetError(&#39;An unexpected error occurred when loading &#39;
                                  &#39;data for a population. It might be due to a &#39;
                                  &#39;name containing the string &#34; - &#34;.&#39;) from error
        for line in lines[1:]:
            # Take the part of the line specifying the parameter to set.
            param_spec = line[:11].strip().split()
            if (n := len(param_spec)) == 0:
                # If there is nothing on the line, continue to the next one.
                continue
            if n == 1:
                # If there is a single word, it should give a parameter&#39;s mean.
                param = param_spec[0]
                if param not in pop._means:
                    raise KeyError(f&#39;{param} is not a valid parameter.&#39;)
                pop._means[param] = float(line[14:])
            elif n == 2:
                # If there is two words, it should give a parameter&#39;s scale.
                scale = param_spec[0]
                param = param_spec[1]
                if scale != &#39;scale&#39; or param not in pop._scales:
                    raise KeyError(f&#39;{scale} {param} is not a valid parameter.&#39;)
                pop._scales[param] = float(line[14:])
            else:
                # If there more than two words, something is wrong...
                raise FormatError(&#39;It seems that the string cannot be used to &#39;
                                  &#39;define the parameters of a Population &#39;
                                  &#39;instance.&#39;)
        pop._update_means()
        pop._update_scales()
        return pop

    def _update_means(self):
        &#34;&#34;&#34;Update the parameters&#39; means according to `_means` values.

        Update the attributes `alpha`, `beta`, `gamma` and `theta` according to
        the values of the corresponding entries of `._means`. It is intended to
        be used internally in other methods when setting new values to
        parameters, to ensure that the values in `_means` are consistent
        with the values of the corresponding attributes.
        &#34;&#34;&#34;
        self.alpha = self._means[&#39;alpha&#39;]
        self.beta  = self._means[&#39;beta&#39;]
        self.gamma = self._means[&#39;gamma&#39;]
        self.theta = self._means[&#39;theta&#39;]

    def _update_scales(self):
        &#34;&#34;&#34;Update the parameters&#39; scales according to `_scales` values.

        Update the attributes `scale_alpha`, `scale_beta`, `scale_gamma` and
        `scale_theta` according to the values of the corresponding entries of
        `_scales`. It is intended to be used internally in other methods when
        setting new values to parameters, to ensure that the values in `_scales`
        are consistent with the values of the corresponding attributes.
        &#34;&#34;&#34;
        self.scale_alpha = self._scales[&#39;alpha&#39;]
        self.scale_beta  = self._scales[&#39;beta&#39;]
        self.scale_gamma = self._scales[&#39;gamma&#39;]
        self.scale_theta = self._scales[&#39;theta&#39;]</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="popnet.structures.Population.ID"><code class="name">var <span class="ident">ID</span></code></dt>
<dd>
<div class="desc"><p>ID of the population. </p>
<p>ID given to the population. It must be a single character, else an
error is raised when setting it. The ID is used as a subscript to
identify state variables.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ID(self):
    &#34;&#34;&#34;ID of the population. 

    ID given to the population. It must be a single character, else an
    error is raised when setting it. The ID is used as a subscript to
    identify state variables. 
    &#34;&#34;&#34;
    return self._ID</code></pre>
</details>
</dd>
<dt id="popnet.structures.Population.alpha"><code class="name">var <span class="ident">alpha</span></code></dt>
<dd>
<div class="desc"><p>Mean <code>alpha</code> transition rate in the population.</p>
<p>Mean value of the transition rates from sensitive to active (with
sufficient input) in the population.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def alpha(self):
    &#34;&#34;&#34;Mean `alpha` transition rate in the population.

    Mean value of the transition rates from sensitive to active (with
    sufficient input) in the population. 
    &#34;&#34;&#34;
    return self._alpha</code></pre>
</details>
</dd>
<dt id="popnet.structures.Population.beta"><code class="name">var <span class="ident">beta</span></code></dt>
<dd>
<div class="desc"><p>Mean <code>beta</code> transition rate in the population.</p>
<p>Mean value of the transition rates from active to refractory in the
population.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def beta(self):
    &#34;&#34;&#34;Mean `beta` transition rate in the population.

    Mean value of the transition rates from active to refractory in the
    population.
    &#34;&#34;&#34;
    return self._beta</code></pre>
</details>
</dd>
<dt id="popnet.structures.Population.gamma"><code class="name">var <span class="ident">gamma</span></code></dt>
<dd>
<div class="desc"><p>Mean <code>gamma</code> transition rate in the population.</p>
<p>Mean value of the transition rates from refractory to sensitive in the
population.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def gamma(self):
    &#34;&#34;&#34;Mean `gamma` transition rate in the population.

    Mean value of the transition rates from refractory to sensitive in the
    population. 
    &#34;&#34;&#34;
    return self._gamma</code></pre>
</details>
</dd>
<dt id="popnet.structures.Population.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>Name of the population. </p>
<p>Name given to the population to identify it in a network. It has to be
a string. When setting a new name, if the population's ID was the
default one, then the ID is updated according to the new name. </p>
<p>A population's name should never contain the string " - ", because this
could lead to unexpected behavior when saving and loading data. An error
will be raised if a name containing this string is set.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self):
    &#34;&#34;&#34;Name of the population. 

    Name given to the population to identify it in a network. It has to be
    a string. When setting a new name, if the population&#39;s ID was the
    default one, then the ID is updated according to the new name. 

    A population&#39;s name should never contain the string &#34; - &#34;, because this
    could lead to unexpected behavior when saving and loading data. An error
    will be raised if a name containing this string is set.
    &#34;&#34;&#34;
    return self._name</code></pre>
</details>
</dd>
<dt id="popnet.structures.Population.scale_alpha"><code class="name">var <span class="ident">scale_alpha</span></code></dt>
<dd>
<div class="desc"><p>Scaling factor of the <code>alpha</code> transition rate in the population.</p>
<p>Scaling factor of the distribution of the transition rates from
sensitive to active (with sufficient input) in the population, which is
assumed to be a logistic distribution.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def scale_alpha(self):
    &#34;&#34;&#34;Scaling factor of the `alpha` transition rate in the population.

    Scaling factor of the distribution of the transition rates from
    sensitive to active (with sufficient input) in the population, which is
    assumed to be a logistic distribution.
    &#34;&#34;&#34;
    return self._scale_alpha</code></pre>
</details>
</dd>
<dt id="popnet.structures.Population.scale_beta"><code class="name">var <span class="ident">scale_beta</span></code></dt>
<dd>
<div class="desc"><p>Scaling factor of the <code>beta</code> transition rate in the population.</p>
<p>Scaling factor of the distribution of the transition rates from
active to refractory in the population, which is assumed to be a
logistic distribution.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def scale_beta(self):
    &#34;&#34;&#34;Scaling factor of the `beta` transition rate in the population.

    Scaling factor of the distribution of the transition rates from
    active to refractory in the population, which is assumed to be a
    logistic distribution.
    &#34;&#34;&#34;
    return self._scale_beta</code></pre>
</details>
</dd>
<dt id="popnet.structures.Population.scale_gamma"><code class="name">var <span class="ident">scale_gamma</span></code></dt>
<dd>
<div class="desc"><p>Scaling factor of the <code>gamma</code> transition rate in the population.</p>
<p>Scaling factor of the distribution of the transition rates from
refractory to sensitive in the population, which is assumed to be a
logistic distribution.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def scale_gamma(self):
    &#34;&#34;&#34;Scaling factor of the `gamma` transition rate in the population.

    Scaling factor of the distribution of the transition rates from
    refractory to sensitive in the population, which is assumed to be a
    logistic distribution. 
    &#34;&#34;&#34;
    return self._scale_gamma</code></pre>
</details>
</dd>
<dt id="popnet.structures.Population.scale_theta"><code class="name">var <span class="ident">scale_theta</span></code></dt>
<dd>
<div class="desc"><p>Scaling factor of the thresholds in the population.</p>
<p>Scaling factor of the distribution of the thresholds in the population,
which is assumed to be a logistic distribution.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def scale_theta(self):
    &#34;&#34;&#34;Scaling factor of the thresholds in the population.

    Scaling factor of the distribution of the thresholds in the population,
    which is assumed to be a logistic distribution.
    &#34;&#34;&#34;
    return self._scale_theta</code></pre>
</details>
</dd>
<dt id="popnet.structures.Population.size"><code class="name">var <span class="ident">size</span></code></dt>
<dd>
<div class="desc"><p>Number of neurons in the population. </p>
<p>Number of neurons in the population. When it is defined, it must be a
positive integer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self):
    &#34;&#34;&#34;Number of neurons in the population. 

    Number of neurons in the population. When it is defined, it must be a
    positive integer.
    &#34;&#34;&#34;
    return self._size</code></pre>
</details>
</dd>
<dt id="popnet.structures.Population.theta"><code class="name">var <span class="ident">theta</span></code></dt>
<dd>
<div class="desc"><p>Mean threshold in the population. </p>
<p>Mean value of the thresholds of activation in the population.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def theta(self):
    &#34;&#34;&#34;Mean threshold in the population. 

    Mean value of the thresholds of activation in the population. 
    &#34;&#34;&#34;
    return self._theta</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="popnet.structures.Population.F"><code class="name flex">
<span>def <span class="ident">F</span></span>(<span>self, y)</span>
</code></dt>
<dd>
<div class="desc"><p>Cumulative distribution function of the thresholds.</p>
<p>Cumulative distribution function (CDF) of the thresholds in the
population, assuming they follow a logistic distribution of mean <code>theta</code>
and of scale factor <code>scale_theta</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def F(self, y):
    &#34;&#34;&#34;Cumulative distribution function of the thresholds.

    Cumulative distribution function (CDF) of the thresholds in the
    population, assuming they follow a logistic distribution of mean `theta`
    and of scale factor `scale_theta`. 
    &#34;&#34;&#34;
    return expit((y - self.theta) / self.scale_theta)</code></pre>
</details>
</dd>
<dt id="popnet.structures.Population.Finv"><code class="name flex">
<span>def <span class="ident">Finv</span></span>(<span>self, y)</span>
</code></dt>
<dd>
<div class="desc"><p>Inverse of the thresholds' CDF. See <code><a title="popnet.structures.Population.F" href="#popnet.structures.Population.F">Population.F()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Finv(self, y):
    &#34;&#34;&#34;Inverse of the thresholds&#39; CDF. See `Population.F`.&#34;&#34;&#34;
    return self.theta + self.scale_theta * logit(y)</code></pre>
</details>
</dd>
<dt id="popnet.structures.Population.G"><code class="name flex">
<span>def <span class="ident">G</span></span>(<span>self, x, y)</span>
</code></dt>
<dd>
<div class="desc"><p>Rescaled cumulative distribution function of the thresholds.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def G(self, x, y):
    &#34;&#34;&#34;Rescaled cumulative distribution function of the thresholds.&#34;&#34;&#34;
    return self.F((x + self.theta * self.g(x,y)) / (1 + self.g(x,y)))</code></pre>
</details>
</dd>
<dt id="popnet.structures.Population.H"><code class="name flex">
<span>def <span class="ident">H</span></span>(<span>self, X, S, B, CXS, CXB, CSB, VarB)</span>
</code></dt>
<dd>
<div class="desc"><p>Approximation of the covariance between <em>X</em> and <em>SF(B)</em>.</p>
<p>Function used to approximate the covariance between <em>X</em> and <em>SF(B)</em> in
terms of the expectations and covariances of <em>X</em>, <em>S</em> and <em>B</em> and of the
variance of <em>B</em>. Here <em>F</em> is <code><a title="popnet.structures.Population.F" href="#popnet.structures.Population.F">Population.F()</a></code>. This method is mainly
intended to be used in the dynamical system for the extended
Wilson&ndash;Cowan model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def H(self, X, S, B, CXS, CXB, CSB, VarB):
    &#34;&#34;&#34;Approximation of the covariance between *X* and *SF(B)*.

    Function used to approximate the covariance between *X* and *SF(B)* in
    terms of the expectations and covariances of *X*, *S* and *B* and of the
    variance of *B*. Here *F* is `Population.F`. This method is mainly
    intended to be used in the dynamical system for the extended
    Wilson--Cowan model.
    &#34;&#34;&#34;
    return np.where(S == 0, 0, 
                    np.where(X == 0, 0,
                             ((X*S + CXS) * self.G(B + CSB/S + CXB/X, VarB)
                                - X*S * self.G(B + CSB/S, VarB))))</code></pre>
</details>
</dd>
<dt id="popnet.structures.Population.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, name, ID=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Copy the population.</p>
<p>Return a copy of the population with a new name and ID.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name to give to the new population.</dd>
<dt><strong><code>ID</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>ID to give to the new population. Defaults to <code>None</code>, in which case
a default one is taken from the name.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="popnet.structures.Population" href="#popnet.structures.Population">Population</a></code></dt>
<dd>The copied population.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self, name, ID=None):
    &#34;&#34;&#34;Copy the population.

    Return a copy of the population with a new name and ID.

    Parameters
    ----------
    name : str
        Name to give to the new population.
    ID : str, optional
        ID to give to the new population. Defaults to `None`, in which case
        a default one is taken from the name.

    Returns
    -------
    Population
        The copied population.
    &#34;&#34;&#34;
    other = deepcopy(self)
    other.name = name
    if ID is None:
        ID = other._default_ID()
    other.ID = ID
    return other</code></pre>
</details>
</dd>
<dt id="popnet.structures.Population.dF"><code class="name flex">
<span>def <span class="ident">dF</span></span>(<span>self, y)</span>
</code></dt>
<dd>
<div class="desc"><p>First derivative of the thresholds' CDF. See <code><a title="popnet.structures.Population.F" href="#popnet.structures.Population.F">Population.F()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dF(self, y):
    &#34;&#34;&#34;First derivative of the thresholds&#39; CDF. See `Population.F`.&#34;&#34;&#34;
    return 1 / self.scale_theta * self.F(y) * (1 - self.F(y))</code></pre>
</details>
</dd>
<dt id="popnet.structures.Population.ddF"><code class="name flex">
<span>def <span class="ident">ddF</span></span>(<span>self, y)</span>
</code></dt>
<dd>
<div class="desc"><p>Second derivative of the thresholds' CDF. See <code><a title="popnet.structures.Population.F" href="#popnet.structures.Population.F">Population.F()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ddF(self, y):
    &#34;&#34;&#34;Second derivative of the thresholds&#39; CDF. See `Population.F`.&#34;&#34;&#34;
    return 1 / self.scale_theta**2 * ( 
                            self.F(y) * (1 - self.F(y)) * (1 - 2*self.F(y)))</code></pre>
</details>
</dd>
<dt id="popnet.structures.Population.dddF"><code class="name flex">
<span>def <span class="ident">dddF</span></span>(<span>self, y)</span>
</code></dt>
<dd>
<div class="desc"><p>Third derivative of the thresholds' CDF. See <code><a title="popnet.structures.Population.F" href="#popnet.structures.Population.F">Population.F()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dddF(self, y):
    &#34;&#34;&#34;Third derivative of the thresholds&#39; CDF. See `Population.F`.&#34;&#34;&#34;
    return 1 / self.scale_theta**3 * (
           self.F(y) * (1 - self.F(y)) * (1 - 6*self.F(y) + 6*self.F(y)**2))</code></pre>
</details>
</dd>
<dt id="popnet.structures.Population.g"><code class="name flex">
<span>def <span class="ident">g</span></span>(<span>self, x, y)</span>
</code></dt>
<dd>
<div class="desc"><p>Scale factor added to <code>F</code> to define <code>G</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def g(self, x, y):
    &#34;&#34;&#34;Scale factor added to `F` to define `G`.&#34;&#34;&#34;
    return np.where(x == self.theta, y / (4 * self.scale_theta**2),
                    (y / (2 * (self.theta - x) * self.scale_theta)
                            * (1 - 2*self.F(x))))</code></pre>
</details>
</dd>
<dt id="popnet.structures.Population.set_means"><code class="name flex">
<span>def <span class="ident">set_means</span></span>(<span>self, **new_values)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the means of population parameters.</p>
<p>Assign new values to some of the means of the population's parameters:
<code>alpha</code>, <code>beta</code>, <code>gamma</code> and <code>theta</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>**new_values</code></strong></dt>
<dd>New values to assign to means of valid population parameters.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>KeyError</code></dt>
<dd>If non-valid parameters are requested.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_means(self, **new_values):
    &#34;&#34;&#34;Set the means of population parameters.

    Assign new values to some of the means of the population&#39;s parameters:
    `alpha`, `beta`, `gamma` and `theta`.

    Parameters
    ----------
    **new_values
        New values to assign to means of valid population parameters. 

    Raises
    ------
    KeyError
        If non-valid parameters are requested.
    &#34;&#34;&#34;
    for key in new_values:
        if key not in self._means:
            raise KeyError(f&#39;{key} is not a valid population parameter.&#39;)
        self._means[key] = float(new_values[key])
    self._update_means()</code></pre>
</details>
</dd>
<dt id="popnet.structures.Population.set_random_rates"><code class="name flex">
<span>def <span class="ident">set_random_rates</span></span>(<span>self, rates=None, distribution='exponential', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Randomly set the transition rates from a given distribution.</p>
<p>Choose a random value for the transition rates from a given distribution
family with given parameters. The random value is generated using a
<a href="https://tinyurl.com/numpy-random-generator"><code>Generator</code></a> instance from
NumPy's <code>random</code> module, and keyword arguments can be passed to the
<code>Generator</code>'s method used to generate the random values.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>rates</code></strong> :&ensp;<code>list</code> or <code>tuple</code> of <code>str,</code> or <code>str</code>, optional</dt>
<dd>The transition rates that should be chosen randomly. It should
contain valid rates in <code>alpha</code>, <code>beta</code> or <code>gamma</code>, or be one of
these strings.</dd>
<dt><strong><code>distribution</code></strong> :&ensp;<code>{'uniform', 'exponential'}</code>, optional</dt>
<dd>The distribution family used to choose a value for the rates.
Defaults to <code>'uniform'</code>.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments to be passed to the method of <code>Generator</code>
corresponding to the correct distribution family.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>rates</code> is not a list, tuple, or str.</dd>
<dt><code>KeyError</code></dt>
<dd>If the strings given in <code>rates</code> are not valid transition rates.</dd>
<dt><code>NotImplementedError</code></dt>
<dd>If the requested distribution family is not implemented.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_random_rates(self, rates=None, distribution=&#39;exponential&#39;, **kwargs):
    &#34;&#34;&#34;Randomly set the transition rates from a given distribution.

    Choose a random value for the transition rates from a given distribution
    family with given parameters. The random value is generated using a
    [`Generator`](https://tinyurl.com/numpy-random-generator) instance from
    NumPy&#39;s `random` module, and keyword arguments can be passed to the
    `Generator`&#39;s method used to generate the random values.

    Parameters
    ----------
    rates : list or tuple of str, or str, optional
        The transition rates that should be chosen randomly. It should
        contain valid rates in `alpha`, `beta` or `gamma`, or be one of
        these strings. 
    distribution : {&#39;uniform&#39;, &#39;exponential&#39;}, optional
        The distribution family used to choose a value for the rates.
        Defaults to `&#39;uniform&#39;`. 
    **kwargs
        Keyword arguments to be passed to the method of `Generator`
        corresponding to the correct distribution family. 

    Raises
    ------
    TypeError
        If `rates` is not a list, tuple, or str.
    KeyError
        If the strings given in `rates` are not valid transition rates.
    NotImplementedError
        If the requested distribution family is not implemented.
    &#34;&#34;&#34;
    if rates is None:
        rates = [&#39;alpha&#39;, &#39;beta&#39;, &#39;gamma&#39;]
    if isinstance(rates, str):
        rates = [rates]
    if not isinstance(rates, (list, tuple)):
        raise TypeError(&#39;Population.set_random_rates expects its first &#39;
                        &#39;argument to be either a list of rates given as &#39;
                        &#39;strings, or a single rate given as a string.&#39;)
    for rate in rates:
        if rate not in [&#39;alpha&#39;, &#39;beta&#39;, &#39;gamma&#39;]:
            raise KeyError(f&#39;{rate} is not a valid transition rate.&#39;)
        rng = np.random.default_rng()
        if distribution == &#39;uniform&#39;:
            self._means[rate] = rng.uniform(**kwargs)
            continue
        elif distribution == &#39;exponential&#39;:
            self._means[rate] = rng.exponential(**kwargs)
            continue
        raise NotImplementedError(f&#39;No {distribution} distribution available&#39;
                                  &#39; to randomly set a transition rate.&#39;)
    self._update_means()</code></pre>
</details>
</dd>
<dt id="popnet.structures.Population.set_random_threshold"><code class="name flex">
<span>def <span class="ident">set_random_threshold</span></span>(<span>self, distribution='uniform', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Randomly set the threshold from a given distribution.</p>
<p>Choose a random value for the threshold from a given distribution family
with given parameters. The random value is generated using a
<a href="https://tinyurl.com/numpy-random-generator"><code>Generator</code></a> instance from
NumPy's <code>random</code> module, and keyword arguments can be passed to the
<code>Generator</code>'s method used to generate the random values.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>distribution</code></strong> :&ensp;<code>{'uniform'}</code>, optional</dt>
<dd>The distribution family used to choose a value for the threshold.
Defaults to <code>'uniform'</code>, which is for now the only implemented
distribution.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments to be passed to the method of <code>Generator</code>
corresponding to the correct distribution family.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NotImplementedError</code></dt>
<dd>If the requested distribution family is not implemented.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_random_threshold(self, distribution=&#39;uniform&#39;, **kwargs):
    &#34;&#34;&#34;Randomly set the threshold from a given distribution.

    Choose a random value for the threshold from a given distribution family
    with given parameters. The random value is generated using a
    [`Generator`](https://tinyurl.com/numpy-random-generator) instance from
    NumPy&#39;s `random` module, and keyword arguments can be passed to the
    `Generator`&#39;s method used to generate the random values.

    Parameters
    ----------
    distribution : {&#39;uniform&#39;}, optional
        The distribution family used to choose a value for the threshold.
        Defaults to `&#39;uniform&#39;`, which is for now the only implemented
        distribution. 
    **kwargs
        Keyword arguments to be passed to the method of `Generator`
        corresponding to the correct distribution family. 

    Raises
    ------
    NotImplementedError
        If the requested distribution family is not implemented. 
    &#34;&#34;&#34;
    if distribution == &#39;uniform&#39;:
        self.theta = np.random.default_rng().uniform(**kwargs)
        return
    raise NotImplementedError(f&#39;No {distribution} distribution available &#39;
                              &#39;to randomly set a threshold.&#39;)</code></pre>
</details>
</dd>
<dt id="popnet.structures.Population.set_scales"><code class="name flex">
<span>def <span class="ident">set_scales</span></span>(<span>self, **new_values)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the scales of population parameters.</p>
<p>Assign new values to some of the scales of the population's parameters:
<code>alpha</code>, <code>beta</code>, <code>gamma</code> and <code>theta</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>**new_values</code></strong></dt>
<dd>New values to assign to scales of valid population parameters.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>KeyError</code></dt>
<dd>If non-valid parameters are requested.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_scales(self, **new_values):
    &#34;&#34;&#34;Set the scales of population parameters.

    Assign new values to some of the scales of the population&#39;s parameters:
    `alpha`, `beta`, `gamma` and `theta`.

    Parameters
    ----------
    **new_values
        New values to assign to scales of valid population parameters. 

    Raises
    ------
    KeyError
        If non-valid parameters are requested.
    &#34;&#34;&#34;
    for key in new_values:
        if key not in self._scales:
            raise KeyError(f&#39;{key} is not a valid population parameter.&#39;)
        self._scales[key] = float(new_values[key])
    self._update_scales()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#classes-and-hierarchy">Classes and hierarchy</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="popnet" href="index.html">popnet</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="popnet.structures.build_network" href="#popnet.structures.build_network">build_network</a></code></li>
<li><code><a title="popnet.structures.config" href="#popnet.structures.config">config</a></code></li>
<li><code><a title="popnet.structures.default_config" href="#popnet.structures.default_config">default_config</a></code></li>
<li><code><a title="popnet.structures.default_network" href="#popnet.structures.default_network">default_network</a></code></li>
<li><code><a title="popnet.structures.load_config" href="#popnet.structures.load_config">load_config</a></code></li>
<li><code><a title="popnet.structures.load_network" href="#popnet.structures.load_network">load_network</a></code></li>
<li><code><a title="popnet.structures.network" href="#popnet.structures.network">network</a></code></li>
<li><code><a title="popnet.structures.population" href="#popnet.structures.population">population</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="popnet.structures.Configuration" href="#popnet.structures.Configuration">Configuration</a></code></h4>
<ul class="">
<li><code><a title="popnet.structures.Configuration.ID" href="#popnet.structures.Configuration.ID">ID</a></code></li>
<li><code><a title="popnet.structures.Configuration.Q" href="#popnet.structures.Configuration.Q">Q</a></code></li>
<li><code><a title="popnet.structures.Configuration.add_random_uniform_perturbation" href="#popnet.structures.Configuration.add_random_uniform_perturbation">add_random_uniform_perturbation</a></code></li>
<li><code><a title="popnet.structures.Configuration.add_to_initial_state" href="#popnet.structures.Configuration.add_to_initial_state">add_to_initial_state</a></code></li>
<li><code><a title="popnet.structures.Configuration.copy" href="#popnet.structures.Configuration.copy">copy</a></code></li>
<li><code><a title="popnet.structures.Configuration.delta" href="#popnet.structures.Configuration.delta">delta</a></code></li>
<li><code><a title="popnet.structures.Configuration.final_time" href="#popnet.structures.Configuration.final_time">final_time</a></code></li>
<li><code><a title="popnet.structures.Configuration.initial_state" href="#popnet.structures.Configuration.initial_state">initial_state</a></code></li>
<li><code><a title="popnet.structures.Configuration.initial_time" href="#popnet.structures.Configuration.initial_time">initial_time</a></code></li>
<li><code><a title="popnet.structures.Configuration.iterations" href="#popnet.structures.Configuration.iterations">iterations</a></code></li>
<li><code><a title="popnet.structures.Configuration.load" href="#popnet.structures.Configuration.load">load</a></code></li>
<li><code><a title="popnet.structures.Configuration.microscopized" href="#popnet.structures.Configuration.microscopized">microscopized</a></code></li>
<li><code><a title="popnet.structures.Configuration.network" href="#popnet.structures.Configuration.network">network</a></code></li>
<li><code><a title="popnet.structures.Configuration.save" href="#popnet.structures.Configuration.save">save</a></code></li>
<li><code><a title="popnet.structures.Configuration.set_initial_state_from" href="#popnet.structures.Configuration.set_initial_state_from">set_initial_state_from</a></code></li>
<li><code><a title="popnet.structures.Configuration.set_random_initial_state" href="#popnet.structures.Configuration.set_random_initial_state">set_random_initial_state</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="popnet.structures.ConfigurationOne" href="#popnet.structures.ConfigurationOne">ConfigurationOne</a></code></h4>
<ul class="">
<li><code><a title="popnet.structures.ConfigurationOne.set_random_initial_state" href="#popnet.structures.ConfigurationOne.set_random_initial_state">set_random_initial_state</a></code></li>
<li><code><a title="popnet.structures.ConfigurationOne.set_to_fixed_point" href="#popnet.structures.ConfigurationOne.set_to_fixed_point">set_to_fixed_point</a></code></li>
<li><code><a title="popnet.structures.ConfigurationOne.state_in_domain" href="#popnet.structures.ConfigurationOne.state_in_domain">state_in_domain</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="popnet.structures.MicroConfiguration" href="#popnet.structures.MicroConfiguration">MicroConfiguration</a></code></h4>
<ul class="">
<li><code><a title="popnet.structures.MicroConfiguration.executions" href="#popnet.structures.MicroConfiguration.executions">executions</a></code></li>
<li><code><a title="popnet.structures.MicroConfiguration.micro_initial_state" href="#popnet.structures.MicroConfiguration.micro_initial_state">micro_initial_state</a></code></li>
<li><code><a title="popnet.structures.MicroConfiguration.microscopized" href="#popnet.structures.MicroConfiguration.microscopized">microscopized</a></code></li>
<li><code><a title="popnet.structures.MicroConfiguration.reset_micro_initial_state" href="#popnet.structures.MicroConfiguration.reset_micro_initial_state">reset_micro_initial_state</a></code></li>
<li><code><a title="popnet.structures.MicroConfiguration.resize_network" href="#popnet.structures.MicroConfiguration.resize_network">resize_network</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="popnet.structures.MicroConfigurationOne" href="#popnet.structures.MicroConfigurationOne">MicroConfigurationOne</a></code></h4>
</li>
<li>
<h4><code><a title="popnet.structures.MicroNetwork" href="#popnet.structures.MicroNetwork">MicroNetwork</a></code></h4>
<ul class="two-column">
<li><code><a title="popnet.structures.MicroNetwork.W" href="#popnet.structures.MicroNetwork.W">W</a></code></li>
<li><code><a title="popnet.structures.MicroNetwork.alpha" href="#popnet.structures.MicroNetwork.alpha">alpha</a></code></li>
<li><code><a title="popnet.structures.MicroNetwork.beta" href="#popnet.structures.MicroNetwork.beta">beta</a></code></li>
<li><code><a title="popnet.structures.MicroNetwork.gamma" href="#popnet.structures.MicroNetwork.gamma">gamma</a></code></li>
<li><code><a title="popnet.structures.MicroNetwork.reset_parameters" href="#popnet.structures.MicroNetwork.reset_parameters">reset_parameters</a></code></li>
<li><code><a title="popnet.structures.MicroNetwork.size" href="#popnet.structures.MicroNetwork.size">size</a></code></li>
<li><code><a title="popnet.structures.MicroNetwork.theta" href="#popnet.structures.MicroNetwork.theta">theta</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="popnet.structures.Network" href="#popnet.structures.Network">Network</a></code></h4>
<ul class="two-column">
<li><code><a title="popnet.structures.Network.ID" href="#popnet.structures.Network.ID">ID</a></code></li>
<li><code><a title="popnet.structures.Network.c" href="#popnet.structures.Network.c">c</a></code></li>
<li><code><a title="popnet.structures.Network.copy" href="#popnet.structures.Network.copy">copy</a></code></li>
<li><code><a title="popnet.structures.Network.extend" href="#popnet.structures.Network.extend">extend</a></code></li>
<li><code><a title="popnet.structures.Network.load" href="#popnet.structures.Network.load">load</a></code></li>
<li><code><a title="popnet.structures.Network.populations" href="#popnet.structures.Network.populations">populations</a></code></li>
<li><code><a title="popnet.structures.Network.save" href="#popnet.structures.Network.save">save</a></code></li>
<li><code><a title="popnet.structures.Network.scale_c" href="#popnet.structures.Network.scale_c">scale_c</a></code></li>
<li><code><a title="popnet.structures.Network.set_random_c" href="#popnet.structures.Network.set_random_c">set_random_c</a></code></li>
<li><code><a title="popnet.structures.Network.underlying" href="#popnet.structures.Network.underlying">underlying</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="popnet.structures.Population" href="#popnet.structures.Population">Population</a></code></h4>
<ul class="">
<li><code><a title="popnet.structures.Population.F" href="#popnet.structures.Population.F">F</a></code></li>
<li><code><a title="popnet.structures.Population.Finv" href="#popnet.structures.Population.Finv">Finv</a></code></li>
<li><code><a title="popnet.structures.Population.G" href="#popnet.structures.Population.G">G</a></code></li>
<li><code><a title="popnet.structures.Population.H" href="#popnet.structures.Population.H">H</a></code></li>
<li><code><a title="popnet.structures.Population.ID" href="#popnet.structures.Population.ID">ID</a></code></li>
<li><code><a title="popnet.structures.Population.alpha" href="#popnet.structures.Population.alpha">alpha</a></code></li>
<li><code><a title="popnet.structures.Population.beta" href="#popnet.structures.Population.beta">beta</a></code></li>
<li><code><a title="popnet.structures.Population.copy" href="#popnet.structures.Population.copy">copy</a></code></li>
<li><code><a title="popnet.structures.Population.dF" href="#popnet.structures.Population.dF">dF</a></code></li>
<li><code><a title="popnet.structures.Population.ddF" href="#popnet.structures.Population.ddF">ddF</a></code></li>
<li><code><a title="popnet.structures.Population.dddF" href="#popnet.structures.Population.dddF">dddF</a></code></li>
<li><code><a title="popnet.structures.Population.g" href="#popnet.structures.Population.g">g</a></code></li>
<li><code><a title="popnet.structures.Population.gamma" href="#popnet.structures.Population.gamma">gamma</a></code></li>
<li><code><a title="popnet.structures.Population.name" href="#popnet.structures.Population.name">name</a></code></li>
<li><code><a title="popnet.structures.Population.scale_alpha" href="#popnet.structures.Population.scale_alpha">scale_alpha</a></code></li>
<li><code><a title="popnet.structures.Population.scale_beta" href="#popnet.structures.Population.scale_beta">scale_beta</a></code></li>
<li><code><a title="popnet.structures.Population.scale_gamma" href="#popnet.structures.Population.scale_gamma">scale_gamma</a></code></li>
<li><code><a title="popnet.structures.Population.scale_theta" href="#popnet.structures.Population.scale_theta">scale_theta</a></code></li>
<li><code><a title="popnet.structures.Population.set_means" href="#popnet.structures.Population.set_means">set_means</a></code></li>
<li><code><a title="popnet.structures.Population.set_random_rates" href="#popnet.structures.Population.set_random_rates">set_random_rates</a></code></li>
<li><code><a title="popnet.structures.Population.set_random_threshold" href="#popnet.structures.Population.set_random_threshold">set_random_threshold</a></code></li>
<li><code><a title="popnet.structures.Population.set_scales" href="#popnet.structures.Population.set_scales">set_scales</a></code></li>
<li><code><a title="popnet.structures.Population.size" href="#popnet.structures.Population.size">size</a></code></li>
<li><code><a title="popnet.structures.Population.theta" href="#popnet.structures.Population.theta">theta</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>